#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2012 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#
#
# This file incorporates work covered by the following copyright and
# permission notice:
#
# Copyright 2004 The Apache Software Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# Message IDs reserved for this file: PWC6600-PWC6624
#
object.invalidScope=PWC6600: Dieses Objekt kann nicht au\u00DFerhalb der Servicemethode eines Servlets oder au\u00DFerhalb der doFilter-Methode eines Filters verwendet werden

#
# Message IDs reserved for this file: PWC3980-PWC4209
#
coyoteConnector.alreadyInitialized=PWC3980: Der Connector wurde bereits initialisiert
coyoteConnector.alreadyStarted=PWC3981: Der Connector wurde bereits gestartet
coyoteConnector.cannotRegisterProtocol=PWC3982: MBean kann nicht f\u00FCr das Protokoll registriert werden
coyoteConnector.notStarted=PWC3983: Coyote Connector wurde nicht gestartet
coyoteConnector.protocolHandlerDestroyFailed=PWC3984: Protokoll-Handler konnte nicht zerst\u00F6rt werden: {0}
coyoteConnector.protocolHandlerInitializationFailed=PWC3985: Protokoll-Handler konnte nicht initialisiert werden: {0}
coyoteConnector.protocolHandlerInstantiationFailed=PWC3986: Protokoll-Handler konnte nicht instanziiert werden: {0}
coyoteConnector.protocolHandlerStartFailed=PWC3987: Protokoll-Handler konnte nicht gestartet werden: {0}
coyoteConnector.protocolRegistrationFailed=PWC3988: Protokoll-JMX konnte nicht registriert werden
coyoteConnector.illegalAdapter=PWC4015: mod_jk - ung\u00FCltige Adapterimplementierung: {0} 
coyoteAdapter.service=PWC3989: Exception oder Fehler bei der Anforderungsverarbeitung im Container aufgetreten
coyoteResponse.getOutputStream.ise=PWC3990: getWriter() wurde f\u00FCr diese Antwort bereits aufgerufen
coyoteResponse.getWriter.ise=PWC3991: getOutputStream() wurde f\u00FCr diese Antwort bereits aufgerufen
coyoteResponse.resetBuffer.ise=PWC3992: Puffer kann nicht zur\u00FCckgesetzt werden, nachdem die Antwort festgeschrieben wurde
coyoteResponse.sendError.ise=PWC3993: sendError() kann nicht aufgerufen werden, nachdem die Antwort festgeschrieben wurde
coyoteResponse.sendRedirect.ise=PWC3994: sendRedirect() kann nicht aufgerufen werden, nachdem die Antwort festgeschrieben wurde
coyoteResponse.setBufferSize.ise=PWC3995: Puffergr\u00F6\u00DFe kann nicht ge\u00E4ndert werden, nachdem die Daten geschrieben wurden
responseFacade.nullResponse=PWC3996: Null-Antwortobjekt
coyoteRequest.getInputStream.ise=PWC3997: getReader() wurde f\u00FCr diese Anforderung bereits aufgerufen
coyoteRequest.getReader.ise=PWC3998: getInputStream() wurde f\u00FCr diese Anforderung bereits aufgerufen
coyoteRequest.sessionCreateCommitted=PWC3999: Session kann nicht erstellt werden, nachdem die Antwort festgeschrieben wurde
coyoteRequest.setAttribute.namenull=PWC4000: setAttribute kann nicht mit einem Null-Namen aufgerufen werden
coyoteRequest.listenerStart=PWC4001: Exception beim Senden des Kontextinitialisierungsereignisses an die Listener-Instanz der Klasse {0}
coyoteRequest.listenerStop=PWC4002: Exception beim Senden des Kontextzerst\u00F6rungsereignisses an die Listener-Instanz der Klasse {0}
coyoteRequest.attributeEvent=PWC4003: Exception vom Attributereignis-Listener ausgel\u00F6st
coyoteRequest.postTooLarge=PWC4004: Parameter wurden nicht geparst, da die geposteten Daten zu gro\u00DF waren. Verwenden Sie das Attribut "maxPostSize" des Connectors, um dieses Problem zu l\u00F6sen, wenn die Anwendung gro\u00DFe POSTs akzeptieren soll.
requestFacade.nullRequest=PWC4005: Anforderungsobjekt darf nicht au\u00DFerhalb des Geltungsbereichs des Service eines Servlets oder der doFilter-Methode eines Filters verwendet werden
coyoteAdapter.proxyAuthCertError=PWC4009: Fehler beim Parsen der Client-Cert-Kette in ein Array von java.security.cert.X509Certificate-Instanzen
coyoteAdapter.listenerOff=PWC4010: HTTP-Listener auf Port {0} wurde deaktiviert
#no ID on coyoteAdapter.noHost as it is sent to client
coyoteAdapter.noHost=Kein Host stimmt mit dem Servernamen {0} \u00FCberein
coyoteRequest.setCharacterEncoding.ise=PWC4011: Die Zeichencodierung der Anforderung kann nicht von Kontext {1} auf {0} gesetzt werden, da die Anforderungsparameter bereits gelesen wurden oder ServletRequest.getReader() bereits aufgerufen wurde.
coyoteRequest.unknownHost=PWC4012: IP-Adresse {0} konnte nicht als Hostname aufgel\u00F6st werden
coyoteRequest.nullRemoteAddressFromProxy=PWC4013: Client-Remote-Adresse konnte nicht aus Proxy bestimmt werden (gibt Null zur\u00FCck)
object.invalidScope=PWC4014: Dieses Objekt kann nicht au\u00DFerhalb der Servicemethode eines Servlets oder au\u00DFerhalb der doFilter-Methode eines Filters verwendet werden
inputBuffer.streamClosed=PWC4015: Stream geschlossen
coyoteRequest.sendfileNotCanonical=PWC4016: Kanonischer Name der Datei [{0}], die f\u00FCr die Verwendung mit sendfile angegeben wurde, kann nicht bestimmt werden
coyoteRequest.multipart.not.configured=PWC4017: Anforderung {0} wird ohne mehrteilige Konfiguration aufgerufen. F\u00FCgen Sie entweder @MultipartConfig zum Servlet oder ein multipart-config-Element zu web.xml hinzu
inputBuffer.alreadysetReadListener=PWC4018: Der ReadListener wurde bereits festgelegt.
outputBuffer.alreadysetWriteListener=PWC4019: Der WriteListener wurde bereits festgelegt.
coyoteRequest.changeSessionId.ise=PWC4020: changeSessionId wurde ohne Session aufgerufen
coyoteReader.readline.skipFailure=PWC4021: {0} Zeichen im zugrunde liegenden Puffer von CoyoteReader in readLine() konnten nicht \u00FCbersprungen werden.

#
# Messages related to async processing mode
#
async.dispatchInProgress=Asynchrone Verteilung wird bereits ausgef\u00FChrt. ServletRequest.startAsync muss zun\u00E4chst aufgerufen werden
async.addListenerIllegalState=AsyncContext.addListener darf nicht aufgerufen werden, nachdem die vom Container gestartete Verteilung, bei der ServletRequest.startAsync aufgerufen wurde, zum Container zur\u00FCckgekehrt ist
async.setTimeoutIllegalState=AsyncContext.setTimeout darf nicht aufgerufen werden, nachdem die vom Container gestartete Verteilung, bei der ServletRequest.startAsync aufgerufen wurde, zum Container zur\u00FCckgekehrt ist
async.listenerInvocationError=Fehler beim Aufrufen von AsyncListener
request.notInAsyncMode=Die Anforderung wurde nicht in den asynchronen Modus versetzt. ServletRequest.startAsync muss zun\u00E4chst aufgerufen werden
request.startAsync.notSupported=Anforderung liegt innerhalb des Geltungsbereichs eines Filters oder Servlets, der bzw. das keine asynchronen Vorg\u00E4nge unterst\u00FCtzt
request.startAsync.alreadyCalled=ServletRequest.startAsync erneut ohne asynchrone Verteilung aufgerufen oder au\u00DFerhalb des Geltungsbereichs einer solchen Verteilung aufgerufen oder erneut innerhalb des Geltungsbereichs derselben Verteilung aufgerufen
request.startAsync.alreadyComplete=Antwort bereits geschlossen
request.startAsync.notInScope=ServletRequest.startAsync au\u00DFerhalb des Geltungsbereichs einer asynchronen Verteilung aufgerufen
request.asyncComplete.alreadyComplete=Anforderung wurde bereits aus dem asynchronen Modus freigegeben
