# translation of intro.po to Traditional Chinese
# Language zh-TW translations for Introduction_to_Web_Beans package.
# 
# Automatically generated, 2009.
# Terry Chuang <tchuang@redhat.com>, 2009.
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2012-01-16T16:07:16\n"
"PO-Revision-Date: 2009-01-21 12:44+1000\n"
"Last-Translator: Terry Chuang <tchuang@redhat.com>\n"
"Language-Team: Traditional Chinese <zh@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Introduction"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"So you're keen to get started writing your first bean? Or perhaps you're "
"skeptical, wondering what kinds of hoops the CDI specification will make you"
" jump through! The good news is that you've probably already written and "
"used hundreds, perhaps thousands of beans. CDI just makes it easier to "
"actually use them to build an application!"
msgstr ""
"您是否已準備好開始編寫您的第一個 Web Bean 了呢？或是您針對於 Web Bean "
"本身的規格還是存有著一些疑問呢？不過好消息就是您從以前到現在可能早就已經編寫並使用了上百甚至是上千個 Web Bean "
"了。您可能根本已經不記得您所編寫的第一個 Web Bean 為何了。"

#. Tag: title
#, fuzzy, no-c-format
msgid "What is a bean?"
msgstr "Web Bean 是什麼？"

#. Tag: para
#, no-c-format
msgid ""
"A bean is exactly what you think it is. Only now, it has a true identity in "
"the container environment."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Prior to Java EE 6, there was no clear definition of the term \"bean\" in "
"the Java EE platform. Of course, we've been calling Java classes used in web"
" and enterprise applications \"beans\" for years. There were even a couple "
"of different kinds of things called \"beans\" in EE specifications, "
"including EJB beans and JSF managed beans. Meanwhile, other third-party "
"frameworks such as Spring and Seam introduced their own ideas of what it "
"meant to be a \"bean\". What we've been missing is a common definition."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Java EE 6 finally lays down that common definition in the Managed Beans "
"specification. Managed Beans are defined as container-managed objects with "
"minimal programming restrictions, otherwise known by the acronym POJO (Plain"
" Old Java Object). They support a small set of basic services, such as "
"resource injection, lifecycle callbacks and interceptors. Companion "
"specifications, such as EJB and CDI, build on this basic model. But, "
"<emphasis>at last</emphasis>, there's a uniform concept of a bean and a "
"lightweight component model that's aligned across the Java EE platform."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"With very few exceptions, almost every concrete Java class that has a "
"constructor with no parameters (or a constructor designated with the "
"annotation <literal>@Inject</literal>) is a bean. This includes every "
"JavaBean and every EJB session bean. If you've already got some JavaBeans or"
" session beans lying around, they're already beans&mdash;you won't need any "
"additional special metadata. There's just little one thing you need to do "
"before you can start injecting them into stuff: you need to put them in an "
"archive (a jar, or a Java EE module such as a war or EJB jar) that contains "
"a special marker file: <literal>META-INF/beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The JavaBeans and EJBs you've been writing every day, up until now, have not"
" been able to take advantage of the new services defined by the CDI "
"specification. But you'll be able to use every one of them with "
"CDI&mdash;allowing the container to create and destroy instances of your "
"beans and associate them with a designated context, injecting them into "
"other beans, using them in EL expressions, specializing them with qualifier "
"annotations, even adding interceptors and decorators to them&mdash;without "
"modifying your existing code. At most, you'll need to add some annotations."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now let's see how to create your first bean that actually uses CDI."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Getting our feet wet"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Suppose that we have two existing Java classes that we've been using for "
"years in various applications. The first class parses a string into a list "
"of sentences:"
msgstr "假設我們目前有兩個使用於各種應用程式中多年的 Java class。第一個 class 會將一個字串剖析入一列句子中："

#. Tag: programlisting
#, no-c-format
msgid ""
"public class SentenceParser {\n"
"   public List&lt;String&gt; parse(String text) { ... }\n"
"}"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The second existing class is a stateless session bean front-end for an "
"external system that is able to translate sentences from one language to "
"another:"
msgstr "第二個 class 則是個外部系統的無狀態 session bean 前端，並且它可將句子由一種語言翻譯成另一種語言："

#. Tag: programlisting
#, no-c-format
msgid ""
"@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"   public String translate(String sentence) { ... }\n"
"}"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Where <literal>Translator</literal> is the EJB local interface:"
msgstr "<literal>Translator</literal> 為本地介面："

#. Tag: programlisting
#, no-c-format
msgid ""
"@Local\n"
"public interface Translator {\n"
"   public String translate(String sentence);\n"
"}"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Unfortunately, we don't have a class that translates whole text documents. "
"So let's write a bean for this job:"
msgstr "不巧的是，我們沒有一個可翻譯整個文字文件的現有 class。所以讓我們來編寫一個能夠完成這項工作的 Web Bean 吧："

#. Tag: programlisting
#, no-c-format
msgid ""
"public class TextTranslator {\n"
"   private SentenceParser sentenceParser;\n"
"   private Translator sentenceTranslator;\n"
"    \n"
"   @Inject\n"
"   TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"      this.sentenceParser = sentenceParser;\n"
"      this.sentenceTranslator = sentenceTranslator;\n"
"   }\n"
"    \n"
"   public String translate(String text) {\n"
"      StringBuilder sb = new StringBuilder();\n"
"      for (String sentence: sentenceParser.parse(text)) {\n"
"          sb.append(sentenceTranslator.translate(sentence));\n"
"      }\n"
"      return sb.toString();\n"
"   }\n"
"}"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"But wait! <literal>TextTranslator</literal> does not have a constructor with"
" no parameters! Is it still a bean? If you remember, a class that does not "
"have a constructor with no parameters can still be a bean if it has a "
"constructor annotated <literal>@Inject</literal>."
msgstr ""
"不過請稍等：<literal>TextTranslator</literal> 並沒有一個無參數的 constructor！這樣它還是個 Web "
"Bean 嗎？一個沒有無參數 constructor 的 class 若有個被標記了 <literal>@Initializer</literal> 的"
" constructor 的話，它還是能夠是個 Web Bean。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"As you've guessed, the <literal>@Inject</literal> annotation has something "
"to do with dependency injection! <literal>@Inject</literal> may be applied "
"to a constructor or method of a bean, and tells the container to call that "
"constructor or method when instantiating the bean. The container will inject"
" other beans into the parameters of the constructor or method."
msgstr ""
"就如您所猜測地，<literal>@Initializer</literal> "
"這個標記和依賴注入有關係！<literal>@Initializer</literal> 可套用至一個 Web Bean 的 constructor "
"或是 method 來指示 Web Bean 管理員在例示 Web Bean 時去調用該 constructor 或 method。Web Bean "
"管理員會將其它 Web Bean 注入至該 constructor 或 method 的參數中。"

#. Tag: para
#, no-c-format
msgid ""
"We may obtain an instance of <literal>TextTranslator</literal> by injecting "
"it into a constructor, method or field of a bean, or a field or method of a "
"Java EE component class such as a servlet. The container chooses the object "
"to be injected based on the type of the injection point, not the name of the"
" field, method or parameter."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Let's create a UI controller bean that uses field injection to obtain an "
"instance of the <literal>TextTranslator</literal>, translating the text "
"entered by a user:"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"@Named @RequestScoped\n"
"public class TranslateController {\n"
"   @Inject TextTranslator textTranslator;\n"
"\n"
"   private String inputText;\n"
"   private String translation;\n"
"\n"
"   // JSF action method, perhaps\n"
"   public void translate() {\n"
"      translation = textTranslator.translate(inputText); \n"
"   }\n"
"\n"
"   public String getInputText() {\n"
"      return inputText;\n"
"   }\n"
"\n"
"   public void setInputText(String text) {\n"
"      this.inputText = text;\n"
"   }\n"
"\n"
"   public String getTranslation() {\n"
"      return translation;\n"
"   }\n"
"}"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Field injection of <literal>TextTranslator</literal> instance"
msgstr "<literal>Translator</literal> 為本地介面："

#. Tag: para
#, no-c-format
msgid ""
"Notice the controller bean is request-scoped and named. Since this "
"combination is so common in web applications, there's a built-in annotation "
"for it in CDI that we could have used as a shorthand. When the (stereotype) "
"annotation <literal>@Model</literal> is declared on a class, it creates a "
"request-scoped and named bean."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Alternatively, we may obtain an instance of "
"<literal>TextTranslator</literal> programmatically from an injected instance"
" of <literal>Instance</literal>, parameterized with the bean type:"
msgstr ""
"我們能夠藉由將注入一個 <literal>TextTranslator</literal> 的 instance 注入 Web Bean、Servlet"
" 或是 EJB 中來取得這個 instance："

#. Tag: programlisting
#, no-c-format
msgid ""
"@Inject Instance&lt;TextTranslator&gt; textTranslatorInstance;\n"
"...\n"
"public void translate() {\n"
"   textTranslatorInstance.get().translate(inputText);\n"
"}"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Notice that it isn't necessary to create a getter or setter method to inject"
" one bean into another. CDI can access an injected field directly (even if "
"it's private!), which sometimes helps eliminate some wasteful code. The name"
" of the field is arbitrary. It's the field's type that determines what is "
"injected."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"At system initialization time, the container must validate that exactly one "
"bean exists which satisfies each injection point. In our example, if no "
"implementation of <literal>Translator</literal> is available&mdash;if the "
"<literal>SentenceTranslator</literal> EJB was not deployed&mdash;the "
"container would inform us of an <emphasis>unsatisfied dependency</emphasis>."
" If more than one implementation of <literal>Translator</literal> were "
"available, the container would inform us of the <emphasis>ambiguous "
"dependency</emphasis>."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Before we get too deep in the details, let's pause and examine a bean's "
"anatomy. What aspects of the bean are significant, and what gives it its "
"identity? Instead of just giving examples of beans, we're going to define "
"what <emphasis>makes</emphasis> something a bean."
msgstr ""
