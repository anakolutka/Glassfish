#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2012 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#
#
# This file incorporates work covered by the following copyright and
# permission notice:
#
# Copyright 2004 The Apache Software Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# Message IDs reserved for this file: PWC6600-PWC6624
#
object.invalidScope=PWC6600 : impossible d'utiliser cet objet en dehors de la m\u00E9thode de service d'un servlet ou en dehors de la m\u00E9thode doFilter d'un filtre

#
# Message IDs reserved for this file: PWC3980-PWC4209
#
coyoteConnector.alreadyInitialized=PWC3980 : le connecteur a d\u00E9j\u00E0 \u00E9t\u00E9 initialis\u00E9
coyoteConnector.alreadyStarted=PWC3981 : le connecteur a d\u00E9j\u00E0 \u00E9t\u00E9 d\u00E9marr\u00E9
coyoteConnector.cannotRegisterProtocol=PWC3982 : impossible d'inscrire le MBean pour le protocole
coyoteConnector.notStarted=PWC3983 : le connecteur Coyote n'a pas \u00E9t\u00E9 d\u00E9marr\u00E9
coyoteConnector.protocolHandlerDestroyFailed=PWC3984 : \u00E9chec de la destruction du gestionnaire de protocoles : {0}
coyoteConnector.protocolHandlerInitializationFailed=PWC3985 : \u00E9chec de l''initialisation du gestionnaire de protocoles : {0}
coyoteConnector.protocolHandlerInstantiationFailed=PWC3986 : \u00E9chec de l''instanciation du gestionnaire de protocoles : {0}
coyoteConnector.protocolHandlerStartFailed=PWC3987 : \u00E9chec du d\u00E9marrage du gestionnaire de protocoles : {0}
coyoteConnector.protocolRegistrationFailed=PWC3988 : \u00E9chec de l'inscription JMX du protocole
coyoteConnector.illegalAdapter=PWC4015 : impl\u00E9mentation d''adaptateur non valide mod_jk : {0} 
coyoteAdapter.service=PWC3989 : une exception ou une erreur s'est produite dans le conteneur lors du traitement de demande
coyoteResponse.getOutputStream.ise=PWC3990 : getWriter() a d\u00E9j\u00E0 \u00E9t\u00E9 appel\u00E9 pour cette r\u00E9ponse
coyoteResponse.getWriter.ise=PWC3991 : getOutputStream() a d\u00E9j\u00E0 \u00E9t\u00E9 appel\u00E9 pour cette r\u00E9ponse
coyoteResponse.resetBuffer.ise=PWC3992 : impossible de r\u00E9initialiser le tampon une fois que la r\u00E9ponse a \u00E9t\u00E9 valid\u00E9e (commit)
coyoteResponse.sendError.ise=PWC3993 : impossible d'appeler sendError() une fois que la r\u00E9ponse a \u00E9t\u00E9 valid\u00E9e (commit)
coyoteResponse.sendRedirect.ise=PWC3994 : impossible d'appeler sendRedirect() une fois que la r\u00E9ponse a \u00E9t\u00E9 valid\u00E9e (commit)
coyoteResponse.setBufferSize.ise=PWC3995 : impossible de modifier la taille de tampon une fois que les donn\u00E9es ont \u00E9t\u00E9 \u00E9crites
responseFacade.nullResponse=PWC3996 : objet de r\u00E9ponse NULL
coyoteRequest.getInputStream.ise=PWC3997 : getReader() a d\u00E9j\u00E0 \u00E9t\u00E9 appel\u00E9 pour cette demande
coyoteRequest.getReader.ise=PWC3998 : getInputStream() a d\u00E9j\u00E0 \u00E9t\u00E9 appel\u00E9 pour cette demande
coyoteRequest.sessionCreateCommitted=PWC3999 : impossible de cr\u00E9er une session une fois que la r\u00E9ponse a \u00E9t\u00E9 valid\u00E9e (commit)
coyoteRequest.setAttribute.namenull=PWC4000 : impossible d'appeler setAttribute avec un nom NULL
coyoteRequest.listenerStart=PWC4001 : exception lors de l''envoi d''un \u00E9v\u00E9nement initialis\u00E9 de contexte \u00E0 l''instance de processus d''\u00E9coute de classe {0}
coyoteRequest.listenerStop=PWC4002 : exception lors de l''envoi d''un \u00E9v\u00E9nement d\u00E9truit de contexte \u00E0 l''instance de processus d''\u00E9coute de classe {0}
coyoteRequest.attributeEvent=PWC4003 : exception g\u00E9n\u00E9r\u00E9e par un processus d'\u00E9coute d'\u00E9v\u00E9nement d'attributs
coyoteRequest.postTooLarge=PWC4004 : les param\u00E8tres n'ont pas \u00E9t\u00E9 analys\u00E9s car la taille des donn\u00E9es envoy\u00E9es \u00E9tait trop importante. Si l'application doit accepter les POST volumineux, utilisez l'attribut maxPostSize du connecteur afin de r\u00E9soudre le probl\u00E8me.
requestFacade.nullRequest=PWC4005 : vous ne devez pas utiliser d'objet de demande hors de la port\u00E9e du service d'un servlet ou de la m\u00E9thode doFilter d'un filtre
coyoteAdapter.proxyAuthCertError=PWC4009 : erreur lors de l'analyse de la cha\u00EEne de certificat client dans le tableau des instances java.security.cert.X509Certificate
coyoteAdapter.listenerOff=PWC4010 : le processus d''\u00E9coute HTTP sur le port {0} a \u00E9t\u00E9 d\u00E9sactiv\u00E9
#no ID on coyoteAdapter.noHost as it is sent to client
coyoteAdapter.noHost=Aucun h\u00F4te ne correspond au nom de serveur {0}
coyoteRequest.setCharacterEncoding.ise=PWC4011 : impossible de d\u00E9finir l''encodage de caract\u00E8res de demande sur {0} \u00E0 partir du contexte {1}, car les param\u00E8tres de demande ont d\u00E9j\u00E0 \u00E9t\u00E9 lus ou ServletRequest.getReader() a d\u00E9j\u00E0 \u00E9t\u00E9 appel\u00E9
coyoteRequest.unknownHost=PWC4012 : impossible de r\u00E9soudre l''adresse IP {0} en nom d''h\u00F4te
coyoteRequest.nullRemoteAddressFromProxy=PWC4013 : impossible de d\u00E9terminer l'adresse distante client \u00E0 partir du proxy (renvoie NULL)
object.invalidScope=PWC4014 : impossible d'utiliser cet objet en dehors de la m\u00E9thode de service d'un servlet ou en dehors de la m\u00E9thode doFilter d'un filtre
inputBuffer.streamClosed=PWC4015 : flux ferm\u00E9
coyoteRequest.sendfileNotCanonical=PWC4016 : impossible de d\u00E9terminer le nom canonique du fichier [{0}] indiqu\u00E9 \u00E0 utiliser avec sendfile
coyoteRequest.multipart.not.configured=PWC4017 : Request.{0} est appel\u00E9 sans configuration multipart. Ajoutez un @MultipartConfig au servlet ou un \u00E9l\u00E9ment multipart-config \u00E0 web.xml
inputBuffer.alreadysetReadListener=PWC4018 : l'\u00E9l\u00E9ment ReadListener a d\u00E9j\u00E0 \u00E9t\u00E9 d\u00E9fini.
outputBuffer.alreadysetWriteListener=PWC4019 : l'\u00E9l\u00E9ment WriteListener a d\u00E9j\u00E0 \u00E9t\u00E9 d\u00E9fini.
coyoteRequest.changeSessionId.ise=PWC4020 : l'\u00E9l\u00E9ment changeSessionId a \u00E9t\u00E9 appel\u00E9 sans session
coyoteReader.readline.skipFailure=PWC4021 : impossible d''ignorer {0} caract\u00E8res dans le tampon sous-jacent de CoyoteReader sur readLine().

#
# Messages related to async processing mode
#
async.dispatchInProgress=R\u00E9partition asynchrone d\u00E9j\u00E0 en cours, vous devez d'abord appeler ServletRequest.startAsync
async.addListenerIllegalState=Vous ne devez pas appeler AsyncContext.addListener apr\u00E8s que la r\u00E9partition initi\u00E9e par conteneur pendant laquelle ServletRequest.startAsync a \u00E9t\u00E9 appel\u00E9 a \u00E9t\u00E9 renvoy\u00E9e au conteneur
async.setTimeoutIllegalState=Vous ne devez pas appeler AsyncContext.setTimeout apr\u00E8s que la r\u00E9partition initi\u00E9e par conteneur pendant laquelle ServletRequest.startAsync a \u00E9t\u00E9 appel\u00E9 a \u00E9t\u00E9 renvoy\u00E9e au conteneur
async.listenerInvocationError=Erreur lors de l'appel de AsyncListener
request.notInAsyncMode=La demande n'a pas \u00E9t\u00E9 pass\u00E9e en mode asynchrone, vous devez d'abord appeler ServletRequest.startAsync
request.startAsync.notSupported=La demande se trouve dans la port\u00E9e d'un filtre ou d'un servlet qui ne prend pas en charge les op\u00E9rations asynchrones
request.startAsync.alreadyCalled=ServletRequest.startAsync appel\u00E9 de nouveau sans aucune r\u00E9partition asynchrone, ou appel\u00E9 hors de la port\u00E9e de ce type de r\u00E9partition, ou appel\u00E9 de nouveau dans la port\u00E9e de la m\u00EAme r\u00E9partition
request.startAsync.alreadyComplete=R\u00E9ponse d\u00E9j\u00E0 ferm\u00E9e
request.startAsync.notInScope=ServletRequest.startAsync appel\u00E9 hors de la port\u00E9e d'une r\u00E9partition asynchrone
request.asyncComplete.alreadyComplete=Demande d\u00E9j\u00E0 lib\u00E9r\u00E9e du mode asynchrone
