/*
 * The contents of this file are subject to the terms 
 * of the Common Development and Distribution License 
 * (the "License").  You may not use this file except 
 * in compliance with the License.
 * 
 * You can obtain a copy of the license at 
 * glassfish/bootstrap/legal/CDDLv1.0.txt or 
 * https://glassfish.dev.java.net/public/CDDLv1.0.html. 
 * See the License for the specific language governing 
 * permissions and limitations under the License.
 * 
 * When distributing Covered Code, include this CDDL 
 * HEADER in each file and include the License file at 
 * glassfish/bootstrap/legal/CDDLv1.0.txt.  If applicable, 
 * add the following below this CDDL HEADER, with the 
 * fields enclosed by brackets "[]" replaced with your 
 * own identifying information: Portions Copyright [yyyy] 
 * [name of copyright owner]
 */

/*
 * Copyright 2005 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 */

/*
 * File:           JDOParser.java
 * Date:           July 3, 2001  2:16 PM
 *
 * @author  michael
 * @version generated by FFJ XML module
 */
package com.sun.org.apache.jdo.impl.model.jdo.xml;

import java.io.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;

import com.sun.org.apache.jdo.model.jdo.JDOModel;
import com.sun.org.apache.jdo.util.I18NHelper;
import org.xml.sax.*;
import org.xml.sax.helpers.*;

/**
 * The class reads XML documents according to specified DTD and
 * translates all related events into JDOHandler events.
 * <p>Usage sample:
 * <pre>
 *    JDOParser parser = new JDOParser(...);
 *    parser.parse(new InputSource("..."));
 * </pre>
 * <p><b>Warning:</b> the class is machine generated. DO NOT MODIFY</p>
 */
public class JDOParser 
    implements ContentHandler {
    
    /** I18N support. */
    private static final I18NHelper msg = I18NHelper.getInstance(
        "com.sun.org.apache.jdo.impl.model.jdo.Bundle", JDOParser.class.getClassLoader()); //NOI18N

    private StringBuffer buffer;
    
    private JDOHandler handler;
    
    private java.util.Stack context;
    
    public JDOParser(final JDOHandler handler) 
    {
        this.handler = handler;
        buffer = new StringBuffer(111);
        context = new java.util.Stack();
    }
    
    public void setDocumentLocator(Locator locator) 
    {
    }
    
    public void startDocument() throws SAXException 
    {
    }
    
    public void endDocument() throws SAXException 
    {
    }
    
    public void startElement(String ns, String name, String qname, Attributes attrs) 
        throws SAXException 
    {
        dispatch(true);
        context.push(new Object[] {qname, new org.xml.sax.helpers.AttributesImpl(attrs)});
        
        if ("package".equals(name)) { //NOI18N
            handler.start_package(attrs);
        } else if ("jdo".equals(name)) { //NOI18N
            handler.start_jdo(attrs);
        } else if ("class".equals(name)) { //NOI18N
            handler.start_class(attrs);
        } else if ("map".equals(name)) { //NOI18N
            handler.start_map(attrs);
        } else if ("field".equals(name)) { //NOI18N
            handler.start_field(attrs);
        } else if ("collection".equals(name)) { //NOI18N
            handler.start_collection(attrs);
        } else if ("extension".equals(name)) { //NOI18N
            handler.start_extension(attrs);
        } else if ("array".equals(name)) { //NOI18N
            handler.start_array(attrs);
        }
    }
    
    public void endElement(String ns, String name, String qname) 
        throws SAXException 
    {
        dispatch(false);
        context.pop();
        if ("package".equals(name)) { //NOI18N
            handler.end_package();
        } else if ("jdo".equals(name)) { //NOI18N
            handler.end_jdo();
        } else if ("class".equals(name)) { //NOI18N
            handler.end_class();
        } else if ("map".equals(name)) { //NOI18N
            handler.end_map();
        } else if ("field".equals(name)) { //NOI18N
            handler.end_field();
        } else if ("collection".equals(name)) { //NOI18N
            handler.end_collection();
        } else if ("extension".equals(name)) { //NOI18N
            handler.end_extension();
        } else if ("array".equals(name)) { //NOI18N
            handler.end_array();
        }
    }
    
    public void characters(char[] chars, int start, int len) 
        throws SAXException 
    {
        buffer.append(chars, start, len);
    }
    
    public void ignorableWhitespace(char[] chars, int start, int len) 
        throws SAXException 
    {
    }
    
    public void processingInstruction(String target, String data) 
        throws SAXException 
    {
    }
    
    public void startPrefixMapping(final String prefix, final String uri) 
        throws SAXException 
    {
    }
    
    public void endPrefixMapping(final String prefix) 
        throws SAXException 
    {
    }
    
    public void skippedEntity(String name) 
        throws SAXException 
    {
    }
    
    private void dispatch(final boolean fireOnlyIfMixed) 
        throws SAXException 
    {
        if (fireOnlyIfMixed && buffer.length() == 0)
            return; //skip it
        
        Object[] ctx = (Object[]) context.peek();
        String here = (String) ctx[0];
        Attributes attrs = (Attributes) ctx[1];
        buffer.delete(0, buffer.length());
    }
    
    /**
     * The recognizer entry method taking an InputSource.
     * @param input InputSource to be parsed.
     * @throws java.io.IOException on I/O error.
     * @throws SAXException propagated exception thrown by a DocumentHandler.
     * @throws javax.xml.parsers.ParserConfigurationException a parser 
     * satisfining requested configuration can not be created.
     * @throws javax.xml.parsers.FactoryConfigurationError if the implementation 
     * can not be instantiated.
     */
    public void parse(final InputSource input) 
        throws SAXException, ParserConfigurationException, IOException 
    {
        parse(input, this);
    }
    
    /**
     * The recognizer entry method taking a URL.
     * @param url URL source to be parsed.
     * @throws java.io.IOException on I/O error.
     * @throws SAXException propagated exception thrown by a DocumentHandler.
     * @throws javax.xml.parsers.ParserConfigurationException a parser 
     * satisfining requested configuration can not be created.
     * @throws javax.xml.parsers.FactoryConfigurationError if the implementation 
     * can not be instantiated.
     */
    public void parse(final java.net.URL url) 
        throws SAXException, ParserConfigurationException, IOException 
    {
        parse(new InputSource(url.toExternalForm()), this);
    }
    
    /**
     * The recognizer entry method taking an Inputsource.
     * @param input InputSource to be parsed.
     * @throws java.io.IOException on I/O error.
     * @throws SAXException propagated exception thrown by a DocumentHandler.
     * @throws javax.xml.parsers.ParserConfigurationException a parser 
     * satisfining requested configuration can not be created.
     * @throws javax.xml.parsers.FactoryConfigurationError if the implementation 
     * can not be instantiated.
     */
    public static void parse(final InputSource input, final JDOHandler handler) 
        throws SAXException, ParserConfigurationException, IOException 
    {
        parse(input, new JDOParser(handler));
    }
    
    /**
     * The recognizer entry method taking a URL.
     * @param url URL source to be parsed.
     * @throws java.io.IOException on I/O error.
     * @throws SAXException propagated exception thrown by a DocumentHandler.
     * @throws javax.xml.parsers.ParserConfigurationException a parser 
     * satisfining requested configuration can not be created.
     * @throws javax.xml.parsers.FactoryConfigurationError if the implementation 
     * can not be instantiated.
     */
    public static void parse(final java.net.URL url, final JDOHandler handler) 
        throws SAXException, ParserConfigurationException, IOException 
    {
        parse(new InputSource(url.toExternalForm()), handler);
    }
    
    private static void parse(final InputSource input, final JDOParser recognizer) 
        throws SAXException, ParserConfigurationException, IOException 
    {
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setValidating(true);
        factory.setNamespaceAware(true);
        XMLReader parser = factory.newSAXParser().getXMLReader();
        parser.setEntityResolver(new JDOEntityResolver());
        parser.setContentHandler(recognizer);
        parser.setErrorHandler(recognizer.getDefaultErrorHandler());
        parser.parse(input);
    }
    
    private ErrorHandler getDefaultErrorHandler() 
    {
        return new ErrorHandler() {
            public void error(SAXParseException ex) 
                throws SAXException  {
                if (context.isEmpty()) 
                    System.err.println("Missing DOCTYPE."); //NOI18N
                throw ex;
            }
            
            public void fatalError(SAXParseException ex) 
                throws SAXException {
                throw ex;
            }
            
            public void warning(SAXParseException ex) 
                throws SAXException {
                // ignore
            }
        };
    }
    
    /**
     * Implementation of EntityResolver interface to check the jdo.dtd location
     **/
    private static class JDOEntityResolver 
        implements EntityResolver 
    {
        private static final String RECOGNIZED_PUBLIC_ID = 
            "-//Sun Microsystems, Inc.//DTD Java Data Objects Metadata 1.0//EN"; //NOI18N
        private static final String RECOGNIZED_SYSTEM_ID = 
            "file:/javax/jdo/jdo.dtd"; //NOI18N

        public InputSource resolveEntity(String publicId, String systemId)
            throws SAXException, IOException 
        {
            // check for recognized ids
            if (((publicId != null) && RECOGNIZED_PUBLIC_ID.equals(publicId)) ||
                ((publicId == null) && (systemId != null) && 
                 RECOGNIZED_SYSTEM_ID.equals(systemId))) {
                // Substitute the dtd with the one from
                // com.sun.persistence.support.jdo.dtd, but only if the
                // publicId is equal to RECOGNIZED_PUBLIC_ID or there is no
                // publicID and the systemID is equal to RECOGNIZED_SYSTEM_ID.
                    InputStream stream = (InputStream) AccessController.doPrivileged (
                        new PrivilegedAction () {
                            public Object run () {
                            return getClass().getClassLoader().
                                getResourceAsStream("com/sun/persistence/support/jdo.dtd"); //NOI18N
                            }
                         }
                     );
                    if (stream == null) {
                        throw new RuntimeException(
                            msg.msg("EXC_MissingJDODTD", //NOI18N
                                publicId, systemId)); 
                    }
                return new InputSource(new InputStreamReader(stream));
            }
            return null;
        }
    }
}


