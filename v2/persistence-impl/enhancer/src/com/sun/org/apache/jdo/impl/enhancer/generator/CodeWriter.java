/*
 * The contents of this file are subject to the terms 
 * of the Common Development and Distribution License 
 * (the "License").  You may not use this file except 
 * in compliance with the License.
 * 
 * You can obtain a copy of the license at 
 * glassfish/bootstrap/legal/CDDLv1.0.txt or 
 * https://glassfish.dev.java.net/public/CDDLv1.0.html. 
 * See the License for the specific language governing 
 * permissions and limitations under the License.
 * 
 * When distributing Covered Code, include this CDDL 
 * HEADER in each file and include the License file at 
 * glassfish/bootstrap/legal/CDDLv1.0.txt.  If applicable, 
 * add the following below this CDDL HEADER, with the 
 * fields enclosed by brackets "[]" replaced with your 
 * own identifying information: Portions Copyright [yyyy] 
 * [name of copyright owner]
 */

/*
 * Copyright 2005 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 */

package com.sun.org.apache.jdo.impl.enhancer.generator;

import java.lang.reflect.Modifier;

import java.util.List;

import java.io.Writer;
import java.io.FileWriter;
import java.io.IOException;


/**
 *
 */
final class CodeWriter
    extends NameHelper
{
    static private final String lineSeparator
    = System.getProperty("line.separator");

    static private final String indent = "    ";

    private Writer writer = null;

    private int initialIndents = 0;

    public final void setWriter(Writer writer)
    {
        this.writer = writer;
    }

    public final void setInitialIndents(int indents)
    {
        this.initialIndents = indents;
    }

    public void writePackage(final String packagename,
                             final String[] comments)
        throws IOException
    {
        writeComment(0, "Generated by " + Main.class);
        writeComments(0, comments);
        if (packagename != null  &&  packagename.length() > 0) {
            writeln();
            writeln(0, "package " + normalizeClassName(packagename) + ';');
        }
        writeln();
    }

    public void writeImports(final List imports,
                             final String[] comments)
        throws IOException
    {
        writeComments(0, comments);
        final int n = (imports != null ? imports.size() : 0);
        for (int i = 0; i < n; i++) {
            String imp = (String)imports.get(i);
            if (imp != null && imp.length() > 0) {
                writeln(0, "import " + imp + ';');
            } else {
                writeln();
            }
        }
        writeln();
    }

    public void writeClassHeader(final int modifiers,
                                 String classname,
                                 String superclass,
                                 final String[] interfaces,
                                 final String[] comments)
        throws IOException
    {
        writeComments(0, comments);

        classname = getClassName(classname);
        superclass = normalizeClassName(superclass);

        // write class
        final String mod = Modifier.toString(modifiers);
        writeln(0, mod +(mod.length() > 0 ? " " : "") + "class " + classname);

        // write extends
        if (superclass != null) {
            writeln(1, "extends " + superclass);
        }

        // write implements
        {
            final int n = (interfaces != null ? interfaces.length : 0);
            if (n > 0) {
                write(1, "implements ");
                for (int i = 0; i < n; i++) {
                    write((String)interfaces[i]);
                    if (i < n - 1) {
                        write(0, ", ");
                    }
                }
                writeln();
            }
        }

        writeln(0, "{");
    }

    public void writeClassEnd()
        throws IOException
    {
        writeln(0, "}");
        writeln();
    }

    public void writeField(final String name,
                           final int modifiers,
                           String type,
                           final String init_value,
                           final String[] comments)
        throws IOException
    {
        writeComments(1, comments);
        type = normalizeClassName(type);
        String s = Modifier.toString(modifiers) + ' ' + type + ' ' + name;
        if (init_value != null) {
            s += " = " + init_value;
        }
        writeln(1, s + ';');
        writeln();
    }

    public void writeStaticInitializer(final List impl,
                                       final String[] comments)
        throws IOException
    {
        writeComments(1, comments);

        // header
        writeln(1, "static");
        writeln(1, "{");

        // implementation
        final int n =(impl != null ? impl.size() : 0);
        for (int i = 0; i < n; i++) {
            writeln(2, (String)impl.get(i));
        }

        // end
        writeln(1, "}");
        writeln();
    }

    public void writeMethod(final String name,
                            final int modifiers,
                            final String return_type,
                            final String[] param_names,
                            final String[] param_types,
                            final String[] exceptions,
                            final List impl,
                            final String[] comments)
        throws IOException
    {
        writeComments(1, comments);

        // header
        String sig = createMethodSignature(name, modifiers,
                                           return_type,
                                           param_names, param_types,
                                           exceptions);
        // sig==null if we have an instance initializer
        if (sig.length() > 0) {
            writeln(1, sig);
        }
        writeln(1, "{");

        // implementation
        final int n =(impl != null ? impl.size() : 0);
        for (int i = 0; i < n; i++) {
            writeln(2,(String) impl.get(i));
        }

        // end
        writeln(1, "}");
        writeln();
    }

    public void writeConstructor(final String name,
                                 final int modifiers,
                                 final String[] param_names,
                                 final String[] param_types,
                                 final String[] exceptions,
                                 final List impl,
                                 final String[] comments)
        throws IOException
    {
        writeMethod(name, modifiers, null,
                    param_names, param_types, exceptions, impl,
                    comments);
    }

    static private String createMethodSignature(final String name,
                                                final int modifiers,
                                                String return_type,
                                                final String[] param_names,
                                                final String[] param_types,
                                                final String[] exceptions)
        throws IOException
    {
        return_type = normalizeClassName(return_type);
        String s = "";
        if (modifiers != 0) {
            s += Modifier.toString(modifiers) + ' ';
        }
        s += (return_type != null ? return_type + " " : "") + name;

        // parameters
        {
            s += "(";
            final int n = (param_names != null ? param_names.length : 0);
            for (int i = 0; i < n; i++) {
                s += (normalizeClassName(param_types[i]) + ' '
                      + param_names[i]);
                if (i < n - 1) {
                    s += ", ";
                }
            }
            s += ')';
        }
            
        // exceptions
        {
            final int n = (exceptions != null ? exceptions.length : 0);
            if (n > 0) {
                s += " throws ";
                for (int i = 0; i < n; i++) {
                    s += exceptions[i];
                    if (i < n - 1) {
                        s += ", ";
                    }
                }
            }
        }

        return s;
    }

    public void writeComment(final int indents,
                              final String comment)
        throws IOException
    {
        if (comment != null) {
            writeln(indents, "// " + comment);
        }
    }

    public void writeComments(final int indents,
                              final String[] comments)
        throws IOException
    {
        final int n = (comments != null ? comments.length : 0);
        for (int i = 0; i < n; i++) {
            final String s = comments[i];
            writeln(indents, "// " + (s != null ? s : ""));
        }
    }

    private void _write(final int indents,
                        final String s)
        throws IOException
    {
        for (int i = 0; i < indents; i++) {
            writer.write(indent);
        }
        writer.write(s);
    }

    private void write(final int indents,
                       final String s)
        throws IOException
    {
        _write(indents + this.initialIndents, s);
    }

    private void write(final String s)
        throws IOException
    {
        _write(0, s);
    }

    private void writeln(final int indents,
                         final String s)
        throws IOException
    {
        if (this.initialIndents > 0) {
            _write(this.initialIndents, "");
        }
        _write(indents, s + lineSeparator);
    }

    public void writeln()
        throws IOException
    {
        writeln(0, "");
    }
}
