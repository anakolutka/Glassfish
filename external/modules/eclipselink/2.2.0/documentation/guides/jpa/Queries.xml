<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article lang="en-US"><sect1><title>Overview of EclipseLink Queries</title>
   <orderedlist>
      <listitem>
         <title>JPQL</title>
      </listitem>
      <listitem>
         <title>Criteria</title>
      </listitem>
      <listitem>
         <title>Native </title>
      </listitem>
   </orderedlist></sect1><sect1><title>JPQL</title>
   <listitem>
      <title>Criteria</title>
   </listitem></sect1><sect1><title>Criteria</title>
   <listitem>
      <title>Native </title>
   </listitem></sect1><sect1><title>Native </title></sect1><sect1><title>Using Basic Query API (ELUG)</title><sect1 id="bodyContent"><title>For more information, see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29">Using Advanced Query API</ulink>. </title>
   <title/>
   <title>
      <anchor id="Using_Session_Queries"/>Using Session Queries</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note We recommend that you perform all data source operations using a unit of work: doing so is the most efficient way to manage transactions, concurrency, and referential constraints. For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Transactions_%28ELUG%29">Introduction to EclipseLink Transactions</ulink>. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <title>For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29#Session_Queries">Session Queries</ulink>. </title>
   <title/>
   <title>
      <anchor id="How_to_Read_Objects_with_a_Session_Query"/>How to Read Objects with a Session Query</title>
   <title>Using the session query API, you can perform the following read operations: </title>
   <orderedlist>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_an_Object_with_a_Session_Query">Reading an Object with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_All_Objects_with_a_Session_Query">Reading All Objects with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Refreshing_an_Object_with_a_Session_Query">Refreshing an Object with a Session Query</ulink> 
         </title>
      </listitem>
   </orderedlist>
   <title/>
   <title>
      <anchor id="Reading_an_Object_with_a_Session_Query"/>Reading an Object with a Session Query</title>
   <title>The readObject method retrieves a single object from the database. The application must specify the class of object to read. If no object matches the criteria, a null value is returned. </title>
   <title>For example, the basic read operation is: </title>
   <title>session.readObject(MyDomainObject.class);</title>
   <title>The following example returns the first instance of MyDomainObject found in the table used for MyDomainObject. EclipseLink provides the Expression class to specify querying parameters for a specific object. </title>
   <title>When you search for a single, specific object using a primary key, the readObject method is more efficient than the readAllObjects method, because readObject can find an instance in the cache without accessing database. Because a readAllObjects method does not know how many objects match the criteria, it always searches the database to find matching objects, even if it finds matching objects in the cache. </title>
   <title>
      <anchor id="Example_105-1"/>readObject Using an Expression </title>
   <title>import org.eclipse.persistence.sessions.*;</title>
   <title>import org.eclipse.persistence.expressions.*;</title>
   <title>...</title>
   <title/>
   <title>// Use an expression to read in the employee whose last name is Smith.</title>
   <title>// Create an expression using the Expression Builder and use it as the selection criterion of the search </title>
   <title>Employee employee = (Employee) session.readObject(Employee.class, new ExpressionBuilder().get("lastName").equal("Smith"));</title>
   <title/>
   <title>
      <anchor id="Reading_All_Objects_with_a_Session_Query"/>Reading All Objects with a Session Query</title>
   <title>The readAllObjects method retrieves a List of objects from the database and does not put the returned objects in order. If the query does not find any matching objects, it returns an empty List. </title>
   <title>Specify the class for the query. You can also include an expression to define more complex search criteria, as illustrated in the following example. </title>
   <title>
      <anchor id="Example_105-2"/>readAllObjects Using an Expression </title>
   <title>// Returns a List of employees whose employee salary is greater than 10000</title>
   <title>List employees = session.readAllObjects(Employee.class,new ExpressionBuilder.get("salary").greaterThan(10000));</title>
   <title/>
   <title>
      <anchor id="Refreshing_an_Object_with_a_Session_Query"/>Refreshing an Object with a Session Query</title>
   <title>The refreshObject method causes EclipseLink to update the object in memory using data from the database. This operation refreshes any privately owned objects as well. </title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: A privately owned object is one that cannot exist without its parent, or source object. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <title/>
   <title>
      <anchor id="How_to_Create.2C_Update.2C_and_Delete_Objects_with_a_Session_Query"/>How to Create, Update, and Delete Objects with a Session Query</title>
   <title>Using the session query API, you can perform the following create, update, and delete operations: </title>
   <orderedlist>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Writing_a_Single_Object_to_the_Database_with_a_Session_Query">Writing a Single Object to the Database with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Writing_All_Objects_to_the_Database_with_a_Session_Query">Writing All Objects to the Database with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Adding_New_Objects_to_the_Database_with_a_Session_Query">Adding New Objects to the Database with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Modifying_Existing_Objects_in_the_Database_with_a_Session_Query">Modifying Existing Objects in the Database with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Deleting_Objects_in_the_Database_with_a_Session_Query">Deleting Objects in the Database with a Session Query</ulink> 
         </title>
      </listitem>
   </orderedlist>
   <title/>
   <title>
      <anchor id="Writing_a_Single_Object_to_the_Database_with_a_Session_Query"/>Writing a Single Object to the Database with a Session Query</title>
   <title>When you invoke the writeObject method, the method performs a does-exist check to determine whether or not an object exists. If the object exists, writeObject updates the object; if it does not exist, writeObject inserts a new object. </title>
   <title>The writeObject method writes privately owned objects in the correct order to maintain referential integrity. </title>
   <title>Call the writeObject method when you cannot verify that an object exists in the database. </title>
   <title>
      <anchor id="Example_105-3"/>Writing a Single Object Using writeObject </title>
   <title>// Create an instance of the employee and write it to the database</title>
   <title>Employee susan = new Employee();</title>
   <title>susan.setName("Susan");</title>
   <title>...</title>
   <title>// Initialize the susan object with all other instance variables</title>
   <title>session.writeObject(susan); </title>
   <title/>
   <title>
      <anchor id="Writing_All_Objects_to_the_Database_with_a_Session_Query"/>Writing All Objects to the Database with a Session Query</title>
   <title>You can call the writeAllObjects method to write multiple objects to the database. The writeAllObjects method performs the same does-exist check as the writeObject method and then performs the appropriate insert or update operations. </title>
   <title>'Writing Several Objects Using writeAllObjects </title>
   <title>// Read a List of all the current employees in the database.</title>
   <title>List employees = session.readAllObjects(Employee.class);</title>
   <title/>
   <title>// Modify any employee data as necessary</title>
   <title>...</title>
   <title/>
   <title>// Create a new employee and add it to the list of employees</title>
   <title>Employee susan = new Employee();</title>
   <title>...</title>
   <title>// Initialize the new instance of employee</title>
   <title>employees.add(susan);</title>
   <title>// Write all employees to the database. </title>
   <title>// The new instance of susan not currently in the database will be inserted. </title>
   <title>// All the other employees currently stored in the database will be updated</title>
   <title>session.writeAllObjects(employees);</title>
   <title/>
   <title>
      <anchor id="Adding_New_Objects_to_the_Database_with_a_Session_Query"/>Adding New Objects to the Database with a Session Query</title>
   <title>The insertObject method creates a new object in the database, but does not perform the does-exist check before it attempts the insert operation. The insertObject method is more efficient than the writeObject method if you are certain that the object does not yet exist in the database. If the object does exist, the database throws an exception when you execute the insertObject method. </title>
   <title/>
   <title>
      <anchor id="Modifying_Existing_Objects_in_the_Database_with_a_Session_Query"/>Modifying Existing Objects in the Database with a Session Query</title>
   <title>The updateObject method updates existing objects in the database, but does not perform the does-exist check before it attempts the update operation. The updateObject is more efficient than the writeObject method if you are certain that the object does exist in the database. If the object does not exist, the database throws an exception when you execute the updateObject method. </title>
   <title/>
   <title>
      <anchor id="Deleting_Objects_in_the_Database_with_a_Session_Query"/>Deleting Objects in the Database with a Session Query</title>
   <title>To delete an EclipseLink object from the database, read the object from the database and then call the deleteObject method. This method deletes both the specified object and any privately owned data. </title>
   <title/>
   <title>
      <anchor id="Using_DatabaseQuery_Queries"/>Using DatabaseQuery Queries</title>
   <title>This section describes creating and executing DatabaseQuery queries to perform a variety of basic persistence operations, showing how to do the following: </title>
   <orderedlist>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Read_Objects_Using_a_DatabaseQuery">How to Read Objects Using a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Create.2C_Update.2C_and_Delete_Objects_with_a_DatabaseQuery">How to Create, Update, and Delete Objects with a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Update_and_Delete_Multiple_Objects_with_a_DatabaseQuery">How to Update and Delete Multiple Objects with a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Read_Data_with_a_DatabaseQuery">How to Read Data with a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Update_Data_with_a_DatabaseQuery">How to Update Data with a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_SQL_String_in_a_DatabaseQuery">How to Specify a Custom SQL String in a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_JPQL_String_in_a_DatabaseQuery">How to Specify a Custom JPQL String in a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Use_Parameterized_SQL_and_Statement_Caching_in_a_DatabaseQuery">How to Use Parameterized SQL and Statement Caching in a DatabaseQuery</ulink> 
         </title>
      </listitem>
   </orderedlist>
   <title/>
   <title>
      <anchor id="How_to_Read_Objects_Using_a_DatabaseQuery"/>How to Read Objects Using a DatabaseQuery</title>
   <title>This section provides examples of how to read objects using a DatabaseQuery, including the following: </title>
   <orderedlist>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Performing_Basic_DatabaseQuery_Read_Operations">Performing Basic DatabaseQuery Read Operations</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Partial_Object_Queries">Reading Objects Using Partial Object Queries</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Report_Queries">Reading Objects Using Report Queries</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Query-By-Example">Reading Objects Using Query-By-Example</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_Read_Ordering">Specifying Read Ordering</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_a_Collection_Class">Specifying a Collection Class</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_the_Maximum_Rows_Returned">Specifying the Maximum Rows Returned</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Configuring_Query_Timeout_at_the_Query_Level">Configuring Query Timeout at the Query Level</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Batch_Reading">Using Batch Reading</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Join_Reading_with_ObjectLevelReadQuery">Using Join Reading with ObjectLevelReadQuery</ulink> 
         </title>
      </listitem>
   </orderedlist>
   <title/>
   <title>
      <anchor id="Performing_Basic_DatabaseQuery_Read_Operations"/>Performing Basic DatabaseQuery Read Operations</title>
   <title>The following example illustrates a simple read query. It uses an EclipseLink expression, but does not use its own arguments for the query. Instead, it relies on the search parameters the expression provides. This example builds the expression within its code, but does not register the query with the session. </title>
   <title>
      <anchor id="Example_105-5"/>Simple ReadAllQuery </title>
   <title>// This example returns a List of employees whose employee ID is &gt; 100</title>
   <title/>
   <title>// Initialize the DatabaseQuery by specifying the query type</title>
   <title>// and set the reference class for the query</title>
   <title/>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title/>
   <title>// Retrieve ExpressionBuilder from the query</title>
   <title>ExpressionBuilder builder = query.getExpressionBuilder();</title>
   <title/>
   <title>// Configure the query execution. Because this example uses </title>
   <title>// an expression, it uses the setSelectionCriteria method</title>
   <title>query.setSelectionCriteria(builder.get("id").greaterThan(100)); </title>
   <title/>
   <title>// Execute the query</title>
   <title>List employees = (List) session.executeQuery(query);</title>
   <title>The following example illustrates a complex readObject query that uses all available configuration options. </title>
   <title>
      <anchor id="Example_105-6"/>Named Read Query with Two Arguments </title>
   <title>// Initialize the DatabaseQuery by specifying the query type</title>
   <title>// and set the reference class for the query</title>
   <title>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</title>
   <title>// Retrieve ExpressionBuilder from the query</title>
   <title>ExpressionBuilder builder = query.getExpressionBuilder();</title>
   <title>// Define two expressions that map to the first and last names of the employee</title>
   <title>Expression firstNameExpression = builder.get("firstName").equal(emp.getParameter("firstName"));</title>
   <title>Expression lastNameExpression = builder.get("lastName").equal(emp.getParameter("lastName"));</title>
   <title/>
   <title>// Configure the query execution. Because this example uses an expression, </title>
   <title>// it uses the setSelectionCriteria method </title>
   <title>query.setSelectionCriteria(firstNameExpression.and(lastNameExpression)); </title>
   <title>// Specify the required arguments for the query</title>
   <title>query.addArgument("firstName");</title>
   <title>query.addArgument("lastName");</title>
   <title/>
   <title>// Add the query to the session</title>
   <title>session.addQuery("getEmployeeWithName", query);</title>
   <title/>
   <title>// Execute the query by referencing its name and providing values for the specified arguments</title>
   <title>Employee employee = (Employee) session.executeQuery("getEmployeeWithName","Bob","Smith");</title>
   <title>
      <anchor id="Reading_Objects_Using_Partial_Object_Queries"/>Reading Objects Using Partial Object Queries</title>
   <title>The following example demonstrates the use of partial object reading. It reads only the last name and primary key for the employees. This reduces the amount of data read from the database. </title>
   <title>
      <anchor id="Example_105-7"/>Using Partial Object Reading </title>
   <title>// Read all the employees from the database, ask the user to choose one and return it. </title>
   <title>// This uses partial object reading to read just the last name of the employees. Since  </title>
   <title>// EclipseLink automatically includes the primary key of the object, the full object </title>
   <title>// can easily be read for editing</title>
   <title>List list;</title>
   <title>// Fetch data from database and add to list box</title>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title>query.addPartialAttribute("lastName");</title>
   <title/>
   <title>// The next line avoids a query exception</title>
   <title>query.dontMaintainCache();</title>
   <title>List employees = (List) session.executeQuery(query);</title>
   <title>list.addAll(employees);</title>
   <title/>
   <title>// Display list box</title>
   <title>...</title>
   <title>// Get selected employee from list</title>
   <title>Employee selectedEmployee = (Employee)session.readObject(list.getSelectedItem());</title>
   <title>return selectedEmployee;</title>
   <title>
      <anchor id="Reading_Objects_Using_Report_Queries"/>Reading Objects Using Report Queries</title>
   <title>The following example reports the total and average salaries for Canadian employees grouped by their city. </title>
   <title>
      <anchor id="Example_105-8"/>Querying Reporting Information on Employees </title>
   <title>ExpressionBuilder emp = new ExpressionBuilder();</title>
   <title>ReportQuery query = new ReportQuery(Employee.class, emp);</title>
   <title>query.addMaximum("max-salary", emp.get("salary"));</title>
   <title>query.addAverage("average-salary", emp.get("salary"));</title>
   <title>query.addAttribute("city", emp.get("address").get("city"));</title>
   <title/>
   <title>query.setSelectionCriteria(emp.get("address").get("country").equal("Canada"));</title>
   <title>query.addOrdering(emp.get("address").get("city"));</title>
   <title>query.addGrouping(emp.get("address").get("city"));</title>
   <title>List reports = (List) session.executeQuery(query);</title>
   <title>The ReportQuery class provides an extensive reporting API, including methods for computing average, maximum, minimum, sum, standard deviation, variance, and count of attributes. For more information about the available methods for the ReportQuery, see the EclipseLink API Reference. </title>
   <title/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: Because ReportQuery inherits from ReadAllQuery, it also supports most ReadAllQuery properties. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <title>
      <anchor id="Reading_Objects_Using_Query-By-Example"/>Reading Objects Using Query-By-Example</title>
   <title>Query-by-example enables you to specify query selection criteria in the form of a sample object instance that you populate with only the attributes you want to use for the query. </title>
   <title>To define a query-by-example, provide a ReadObjectQuery or a ReadAllQuery with a sample persistent object instance and an optional query-by-example policy. The sample instance contains the data to query, and, optionally, a QueryByExamplePolicy (see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Defining_a_QueryByExamplePolicy">Defining a QueryByExamplePolicy</ulink>) that specifies configuration settings, such as the operators to use and the attribute values to ignore. You can also combine a query-by-example with an expression (see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Combining_Query-by-Example_and_Expressions">Combining Query-by-Example and Expressions</ulink>). </title>
   <title>For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Query-by-Example</ulink>. </title>
   <title>The following example queries the employee Bob Smith. </title>
   <title>
      <anchor id="Example_105-9"/>Using Query-by-Example to Query an Employee </title>
   <title>Employee employee = new Employee();</title>
   <title>employee.setFirstName("Bob");</title>
   <title>employee.setLastName("Smith");</title>
   <title/>
   <title>// Create a query and set Employee as its reference class</title>
   <title>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</title>
   <title>query.setExampleObject(employee);</title>
   <title/>
   <title>Employee result = (Employee) session.executeQuery(query);</title>
   <title>The following example queries across the employee's address. </title>
   <title>
      <anchor id="Example_105-10"/>Using Query-by-Example to Query an Employee's Address </title>
   <title>Employee employee = new Employee();</title>
   <title>Address address = new Address();</title>
   <title>address.setCity("Ottawa");</title>
   <title>employee.setAddress(address);</title>
   <title/>
   <title>// Create a query and set Employee as its reference class</title>
   <title>ReadAllQuery query = new ReadAllQuery (Employee.class);</title>
   <title>query.setExampleObject(employee);</title>
   <title/>
   <title>List results = (List) session.executeQuery(query);</title>
   <title>Defining a QueryByExamplePolicy </title>
   <title>EclipseLink support for query-by-example includes a query-by-example policy. You can edit the policy to modify query-by-example default behavior. You can modify the policy to do the following: </title>
   <orderedlist>
      <listitem>
         <title>Use LIKE or other operations to compare attributes. By default, query-by-example allows only EQUALS. </title>
      </listitem>
      <listitem>
         <title>Modify the set of values query-by-example ignores (the IGNORE set). The default ignored values are zero (0), empty strings, and FALSE. </title>
      </listitem>
      <listitem>
         <title>Force query-by-example to consider attribute values, even if the value is in the IGNORE set. </title>
      </listitem>
      <listitem>
         <title>Use isNull or notNull for attribute values. </title>
      </listitem>
   </orderedlist>
   <title>To specify a query-by-example policy, include an instance of QueryByExamplePolicy with the query. </title>
   <title>The following example uses like operator for strings and includes only objects whose salary is greater than zero. </title>
   <title>
      <anchor id="Example_105-11"/>Query-by-Example Policy Using like Operator </title>
   <title>Employee employee = new Employee();</title>
   <title>employee.setFirstName("B%");</title>
   <title>employee.setLastName("S%");</title>
   <title>employee.setSalary(0);</title>
   <title/>
   <title>// Create a query and set Employee as its reference class</title>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title>query.setExampleObject(employee);</title>
   <title>// Query by example policy section adds like and greaterThan </title>
   <title>QueryByExamplePolicy policy = new QueryByExamplePolicy();</title>
   <title>policy.addSpecialOperation(String.class, "like");</title>
   <title>policy.addSpecialOperation(Integer.class, "greaterThan");</title>
   <title>policy.alwaysIncludeAttribute(Employee.class, "salary");</title>
   <title>query.setQueryByExamplePolicy(policy);</title>
   <title>List results = (List) session.executeQuery(query);</title>
   <title>This example uses keywords for strings and ignores the value -1. </title>
   <title>
      <anchor id="Example_105-12"/>Query-by-Example Policy Using Keywords </title>
   <title>Employee employee = new Employee();</title>
   <title>employee.setFirstName("bob joe fred");</title>
   <title>employee.setLastName("smith mc mac");</title>
   <title>employee.setSalary(-1);</title>
   <title/>
   <title>// Create a query and set Employee as its reference class</title>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title>query.setExampleObject(employee);</title>
   <title>// Query by example policy section </title>
   <title>QueryByExamplePolicy policy = new QueryByExamplePolicy();</title>
   <title>policy.addSpecialOperation(String.class, "containsAnyKeyWords");</title>
   <title>policy.excludeValue(-1);</title>
   <title>query.setQueryByExamplePolicy(policy);</title>
   <title>List results = (List) session.executeQuery(query);</title>
   <title>Combining Query-by-Example and Expressions </title>
   <title>To create more complex query-by-example queries, combine query-by-example with EclipseLink expressions, as shown in the following example. </title>
   <title>
      <anchor id="Example_105-13"/>Combining Query-by-Example with Expressions </title>
   <title>Employee employee = new Employee();</title>
   <title>employee.setFirstName("Bob");</title>
   <title>employee.setLastName("Smith");</title>
   <title/>
   <title>// Create a query and set Employee as its reference class</title>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title/>
   <title>query.setExampleObject(employee);</title>
   <title/>
   <title>// Specify expression </title>
   <title>ExpressionBuilder builder = query.getExpressionBuilder();</title>
   <title>query.setSelectionCriteria(builder.get("salary").between(100000,200000);</title>
   <title>List results = (List) session.executeQuery(query);</title>
   <title>
      <anchor id="Specifying_Read_Ordering"/>Specifying Read Ordering</title>
   <title>Ordering is a common DatabaseQuery option. You can order a collection of objects returned from a ReadAllQuery using the addOrdering, addAscendingOrdering, or addDescendingOrdering methods. You can apply order based on attribute names or query keys and expressions. </title>
   <title>
      <anchor id="Example_105-14"/>A Query with Simple Ordering </title>
   <title>// Retrieves objects ordered by last name then first name in ascending order </title>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title>query.addAscendingOrdering ("lastName");</title>
   <title>query.addAscendingOrdering ("firstName");</title>
   <title>List employees = (List) session.executeQuery(query);</title>
   <title>
      <anchor id=".27Example_105-15"/>A Query with Complex Ordering </title>
   <title>// Retrieves objects ordered by street address, descending case-insensitive </title>
   <title>// order of cities, and manager's last name </title>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title>ExpressionBuilder emp = query.getExpressionBuilder();</title>
   <title>query.addOrdering (emp.getAllowingNull("address").get("street"));</title>
   <title>query.addOrdering(emp.getAllowingNull("address").get("city").toUpperCase().descending());</title>
   <title>query.addOrdering(emp.getAllowingNull("manager").get("lastName"));</title>
   <title>List employees = (List) session.executeQuery(query);</title>
   <title>Note the use of getAllowingNull, which creates an outer join for the address and manager relationships. This ensures that employees without an address or manager still appear in the list. </title>
   <title>For more information about configuring read ordering, see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Read All Query Order</ulink>. </title>
   <title>
      <anchor id="Specifying_a_Collection_Class"/>Specifying a Collection Class</title>
   <title>By default, a ReadAllQuery returns its result objects in a list. You can configure the query to return the results in any collection class that implements the Collection or Map interface, as shown in the following example. </title>
   <title>
      <anchor id="Example_105-16"/>Specifying the Collection Class for a Collection </title>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title>query.useCollectionClass(LinkedList.class);</title>
   <title>LinkedList employees = (LinkedList) getSession().executeQuery(query);</title>
   <title>
      <anchor id="Example_105-17"/>Specifying the Collection Class for a Map </title>
   <title/>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title>query.useMapClass(HashMap.class, "getFirstName");</title>
   <title>HashMap employees = (HashMap) getSession().executeQuery(query);</title>
   <title/>
   <title>
      <anchor id="Specifying_the_Maximum_Rows_Returned"/>Specifying the Maximum Rows Returned</title>
   <title>You can limit a query to a specified maximum number of rows. Use this feature to avoid queries that can return an excessive number of objects. </title>
   <title>To specify a maximum number of rows, use the setMaxRows method, and pass an integer that represents the maximum number of rows for the query, as shown in the following example. </title>
   <title>
      <anchor id="Example_105-18"/>Setting the Maximum Returned Object Size </title>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title>query.setMaxRows(5);</title>
   <title>List employees = (List) session.executeQuery(query);</title>
   <title>The setMaxRows method limits the number of rows the query returns, but does not let you acquire more records after the initial result set. </title>
   <title>If you want to browse the result set in fixed increments, use either cursors or cursored streams. For more information, see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29">Handling Cursor and Stream Query Results</ulink>. </title>
   <title>
      <anchor id="Configuring_Query_Timeout_at_the_Query_Level"/>Configuring Query Timeout at the Query Level</title>
   <title>You can set the maximum amount of time that EclipseLink waits for results from a query. This forces a hung or lengthy query to abort after the specified time has elapsed. EclipseLink throws a DatabaseException after the timeout interval. </title>
   <title>To specify a timeout interval on a per-query basis, use DatabaseQuery method setQueryTimeout and pass the timeout interval as an integer representing the number of seconds before the timeout interval should occur, as the following example shows. </title>
   <title>
      <anchor id="Example_105-19"/>DatabaseQuery Timeout </title>
   <title> // Create the appropriate query and set timeout limits</title>
   <title/>
   <title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title>
   <title>query.setQueryTimeout(2);</title>
   <title>try {</title>
   <title>    List employees = (List) session.executeQuery(query);</title>
   <title>} </title>
   <title>catch (DatabaseException ex) {</title>
   <title>    // timeout occurs</title>
   <title>}</title>
   <title>To specify a timeout interval for all queries on a particular object type, configure a query timeout interval at the descriptor level (see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Query Timeout at the Descriptor Level</ulink>). </title>
   <title>
      <anchor id="Using_Batch_Reading"/>Using Batch Reading</title>
   <title>Batch reading propagates query selection criteria through an object's relationship attribute mappings. You can also nest batch read operations down through complex object graphs. This significantly reduces the number of required SQL select statements and improves database access efficiency. </title>
   <title>Consider the following guidelines when you implement batch reading: </title>
   <orderedlist>
      <listitem>
         <title>Use batch reading for processes that read in objects and all their related objects. </title>
      </listitem>
      <listitem>
         <title>Do not enable batch reading for both sides of a bidirectional relationship. </title>
      </listitem>
      <listitem>
         <title>Avoid nested batch read operations, because they result in multiple joins on the database, slowing query execution. </title>
      </listitem>
   </orderedlist>
   <title>For more information, see <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29">Reading Case 2: Batch Reading Objects</ulink>. </title>
   <title>For example, in reading n employees and their related projects, EclipseLink may require n + 1 select operations. All employees are read at once, but the projects of each are read individually. With batch reading, all related projects can also be read with one select operation by using the original selection criteria, for a total of only two select operations. </title>
   <title>To implement batch reading, add the batch read attribute to a query, use the query.addBatchReadAttribute(Expression anExpression) API, as the following example shows: </title>
   <title>…</title>
   <title>ReadAllQuery raq = new ReadAllQuery(Trade.class);</title>
   <title>ExpressionBuilder tradeBuilder = raq.getBuilder();</title>
   <title>…</title>
   <title>Expression batchReadProduct = tradeBuilder.get("product");</title>
   <title>readAllQuery.addBatchReadAttribute(batchReadProduct); </title>
   <title>Expression batchReadPricingDetails = batchReadProduct.get("pricingDetails");</title>
   <title>readAllQuery.addBatchReadAttribute(batchReadPricingDetails); </title>
   <title>…</title>
   <title>Alternatively, you can add batch reading at the mapping level for a descriptor. For more information, see <ulink url="http://wiki.eclipse.org/Configuring_a_Relational_Mapping_%28ELUG%29">Configuring Batch Reading</ulink>. </title>
   <title>You can combine batch reading and indirection (lazy loading) to provide controlled reading of object attributes. For example, if you have one-to-one back pointer relationship attributes, you can defer back pointer instantiation until the end of the query, when all parent and owning objects are instantiated. This prevents unnecessary database access and optimizes EclipseLink cache use. </title>
   <title>
      <anchor id="Using_Join_Reading_with_ObjectLevelReadQuery"/>Using Join Reading with ObjectLevelReadQuery</title>
   <title>Use join reading with ObjectLevelReadQuery to configure a query for a class to return the data to build an instance of that class and its related objects. For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Join Reading and Object-Level Read Queries</ulink>. </title>
   <title>To use join reading with an ObjectLevelReadQuery, you can use Workbench (see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Named Query Optimization</ulink>))or Java. </title>
   <title/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: You cannot use Workbench to create an ObjectLevelReadQuery with a join expression on a one-to-many mapped attribute: you must use Java. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <title/>
   <title>
      <anchor id="Using_Java"/>Using Java</title>
   <para>You can use ObjectLevelReadQuery API to add joined attributes for mappings. </para>
   <para>You can use any of the following API: </para>
   <orderedlist>
      <listitem>
         <para>Use the ObjectLevelReadQuery method addJoinedAttribute with a join expression or attribute name for one-to-one or one-to-many mapped attributes.Using this method, you can add multiple joined attributes, including nested joins. The source and target can be the same class type.On a one-to-one mapped attribute, use this method to get the class of the ObjectLevelReadQuery and the target of the one-to-one mapped attribute of that class with a single database hit.On a one-to-many mapped attribute, use this method to get the class of the ObjectLevelReadQuery and the target collection of the one-to-many mapped attribute of that class with a single database hit. </para>
      </listitem>
      <listitem>
         <para>Use the ObjectLevelReadQuery method setShouldFilterDuplicates with a join expression on a one-to-many mapped attribute to filter duplicate rows. Default is true, unless using a JPA query. </para>
      </listitem>
      <listitem>
         <para>Use the ObjectLevelReadQuery method setShouldOuterJoinSubclasses to configure an object-level read query to allow inherited subclasses to be outer-joined to avoid the cost of a single query per class. </para>
      </listitem>
   </orderedlist>
   <para>Use a join expression to configure nested batch reads and inner or outer joins (see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Expressions_%28ELUG%29">Expressions for Joining and Complex Relationships</ulink>). You can also specify inner or outer joins using the mapping methods useInnerJoinFetch or useOuterJoinFetch. </para>
   <para>The <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-20">Join Reading Multiple Attributes</ulink> example is based on the EclipseLink ThreeTierEmployee example project. It shows a ReadAllQuery configured to join-read multiple attributes. </para>
   <para>
      <anchor id="Example_105-20"/>Join Reading Multiple Attributes </para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para/>
   <para>Expression managedEmployees = query.getExpressionBuilder().anyOfAllowingNone("managedEmployees");</para>
   <para>query.addJoinedAttribute(managedEmployees);</para>
   <para>query.addJoinedAttribute(managedEmployees.get("address"));</para>
   <para>query.addJoinedAttribute(managedEmployees.anyOf("phoneNumbers"));</para>
   <para/>
   <para>List employees = (List) getSession().executeQuery(query);</para>
   <para>Use the ObjectLevelReadQuery method addJoinedAttribute(java.lang.String attributeName) to configure the query to join-read a single attribute, as the following shows. </para>
   <para>
      <anchor id="Example_105-22"/>Join Reading a Single Attribute </para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.addJoinedAttribute("address");</para>
   <para>List employees = (List)getSession().executeQuery(query);</para>
   <para/>
   <para>
      <anchor id="How_to_Create.2C_Update.2C_and_Delete_Objects_with_a_DatabaseQuery"/>How to Create, Update, and Delete Objects with a DatabaseQuery</para>
   <para>You can create, update or delete object with a DatabaseQuery using a DatabaseSession. For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Session Queries</ulink>. </para>
   <para>This section describes the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Write_Query">Using Write Query</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Performing_Noncascading_Write_Queries">Noncascading Write Queries</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Disabling_the_Identity_Map_Cache_During_a_Write_Query">Disabling the Identity Map Cache During a Write Query</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Using_Write_Query"/>Using Write Query</para>
   <para>To execute a write query, use a WriteObjectQuery instance instead of using the writeObject method of the session. Likewise, substitute DeleteObjectQuery, UpdateObjectQuery, and InsertObjectQuery objects for their respective Session methods. </para>
   <para>
      <anchor id="Example_105-24"/>Using a WriteObjectQuery </para>
   <para>WriteObjectQuery writeQuery = new WriteObjectQuery();</para>
   <para>writeQuery.setObject(domainObject);</para>
   <para>session.executeQuery(writeQuery);</para>
   <para>
      <anchor id="Example_105-25"/>Using InsertObjectQuery, UpdateObjectQuery, and DeleteObjectQuery </para>
   <para>InsertObjectQuery insertQuery= new InsertObjectQuery();</para>
   <para>insertQuery.setObject(domainObject);</para>
   <para>session.executeQuery(insertQuery);</para>
   <para/>
   <para>// When you use UpdateObjectQuery without a unit of work,</para>
   <para>// UpdateObjectQuery writes all direct attributes to the database</para>
   <para>UpdateObjectQuery updateQuery= new UpdateObjectQuery();</para>
   <para>updateQuery.setObject(domainObject2);</para>
   <para>session.executeQuery(updateQuery);</para>
   <para/>
   <para>DeleteObjectQuery deleteQuery = new DeleteObjectQuery();</para>
   <para>deleteQuery.setObject(domainObject2);</para>
   <para>session.executeQuery(deleteQuery);</para>
   <para/>
   <para>
      <anchor id="Performing_Noncascading_Write_Queries"/>Performing Noncascading Write Queries</para>
   <para>When you execute a write query, it writes both the object and its privately owned parts to the database by default. To build write queries that do not update privately owned parts, include the dontCascadeParts method in your query definition. </para>
   <para>Use this method to do the following: </para>
   <orderedlist>
      <listitem>
         <para>Increase performance when you know that only the object's direct attributes have changed. </para>
      </listitem>
      <listitem>
         <para>Resolve referential integrity dependencies when you write large groups of new, independent objects. </para>
      </listitem>
   </orderedlist>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: Because the unit of work resolves referential integrity internally, this method is not required if you use the unit of work to write to the database. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>
      <anchor id="Example_105-27"/>Performing a Noncascading Write Query </para>
   <para>// the Employee is an existing employee read from the database</para>
   <para>Employee.setFirstName("Bob");</para>
   <para>UpdateObjectQuery query = new UpdateObjectQuery();</para>
   <para>query.setObject(Employee);</para>
   <para>query.dontCascadeParts();</para>
   <para>session.executeQuery(query);</para>
   <para/>
   <para>
      <anchor id="Disabling_the_Identity_Map_Cache_During_a_Write_Query"/>Disabling the Identity Map Cache During a Write Query</para>
   <para>When you write objects to the database, EclipseLink copies them to the session cache by default. To disable this within a query, call the dontMaintainCache method within the query. This improves query performance when you insert objects into the database, but must be used only on objects that will not be required later by the application. </para>
   <para>The following example reads all the objects from a flat file and writes new copies of the objects into a table. </para>
   <para>
      <anchor id="Example_105-28"/>Disabling the Identity Map Cache During a Write Query </para>
   <para>// Reads objects from an employee file and writes them to the employee table</para>
   <para>void createEmployeeTable(String filename, Session session) {</para>
   <para>   Iterator iterator;</para>
   <para>   Employee employee;</para>
   <para/>
   <para>   // Read the employee data file</para>
   <para>   List employees = Employee.parseFromFile(filename);</para>
   <para>   Iterator iterator = employees.iterator();</para>
   <para>   while (iterator.hasNext()) {</para>
   <para>      Employee employee = (Employee) iterator.next();</para>
   <para>      InsertObjectQuery query = new InsertObjectQuery();</para>
   <para>      query.setObject(employee);</para>
   <para>      query.dontMaintainCache();</para>
   <para>      session.executeQuery(query);</para>
   <para>   }</para>
   <para>}</para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: Disable the identity map only when object identity is unimportant in subsequent operations. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>
      <anchor id="How_to_Update_and_Delete_Multiple_Objects_with_a_DatabaseQuery"/>How to Update and Delete Multiple Objects with a DatabaseQuery</para>
   <para>Using the unit of work, you can perform update and delete operations on multiple objects. </para>
   <para>This section describes the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_UpdateAll_Queries">Using UpdateAll Queries</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_DeleteAll_Queries">Using DeleteAll Queries</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Using_UpdateAll_Queries"/>Using UpdateAll Queries</para>
   <para>Use an UpdateAllQuery to update a large number of objects at once. With this query, you can update a large number of objects with a single SQL statement instead of reading the objects into memory and updating them individually. The following example shows an UpdateAllQuery to give all full-time employees a raise. </para>
   <para>
      <anchor id="Example_105-26"/>Using UpdateAllQuery </para>
   <para>// Give all full time employees a 10% raise</para>
   <para>UpdateAllQuery updateQuery = new UpdateAllQuery(Employee.class);</para>
   <para>ExpressionBuilder employee = updateQuery.getExpressionBuilder();</para>
   <para>updateQuery.setSelectionCriteria(employee.get("status").equal("FULL_TIME"));</para>
   <para>updateQuery.addUpdateExpression(employee.get("salary"), </para>
   <para>            ExpressionMath.multiply(employee.get("salary"), new Float(1.10)));</para>
   <para>UpdateAllQuery takes the cache into consideration and ensures that the cache is kept up to date. You can configure the UpdateAllQuery to invalidate cache (see <ulink url="http://wiki.eclipse.org/Introduction_to_Cache_%28ELUG%29">Cache Invalidation</ulink>) by setting the cache usage to INVALIDATE_CACHE (default), or to not use the cache by specifying NO_CACHE option. You can manipulate these settings through the setCacheUsage method. You can only update the cache for expressions that can conform. For more information on cache, see <ulink url="http://wiki.eclipse.org/Introduction_to_Cache_%28ELUG%29">Introduction to Cache</ulink>. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: You can set an attribute within an aggregate only, but not an entire aggregate. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>You can use an UpdateAllQuery with optimistic locking (see <ulink url="http://wiki.eclipse.org/Introduction_to_Descriptors_%28ELUG%29">Descriptors and Locking</ulink>) at the level of updating a row in a database–there should be no updates in the cache. You will update the locking field on the database. There is also support for version and timestamp locking, as well as indirect support for field locking. </para>
   <para/>
   <para>
      <anchor id="Using_DeleteAll_Queries"/>Using DeleteAll Queries</para>
   <para>The following example shows a DeleteAllQuery to eliminate all part-time employee positions. </para>
   <para>
      <anchor id="Example_105-271"/>Using DeleteAllQuery </para>
   <para>// Delete all part-time employees</para>
   <para>DeleteAllQuery deleteQuery = new DeleteAllQuery(Employee.class);</para>
   <para>ExpressionBuilder employee = deleteQuery.getExpressionBuilder();</para>
   <para>deleteQuery.setSelectionCriteria(employee.get("status").equal("PART_TIME"));</para>
   <para>deleteQuery.setObjects(domainObjects);</para>
   <para>session.executeQuery(deleteQuery);</para>
   <para>For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">DeleteAllQuery</ulink> 
   </para>
   <para>
      <anchor id="How_to_Read_Data_with_a_DatabaseQuery"/>How to Read Data with a DatabaseQuery</para>
   <para>This section describes the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_DataReadQuery">Using a DataReadQuery</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_DirectReadQuery">Using a DirectReadQuery</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_ValueReadQuery">Using a ValueReadQuery</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Using_a_DataReadQuery"/>Using a DataReadQuery</para>
   <para>You can use a DataReadQuery to execute a selecting SQL string that returns a Collection of the Record objects representing the result set, as the following example shows. </para>
   <para>
      <anchor id="Example_105-29"/>Using a DataReadQuery </para>
   <para>DataReadQuery dataReadQuery = new DataReadQuery();</para>
   <para>dataReadQuery.setSQLString("Select * from EMPLOYEE"); </para>
   <para/>
   <para>// queryResults is a List of DatabaseRow objects</para>
   <para>List queryResults = (List)session.executeQuery(dataReadQuery);</para>
   <para/>
   <para>
      <anchor id="Using_a_DirectReadQuery"/>Using a DirectReadQuery</para>
   <para>You can use a DirectReadQuery to read a single column of data (that is, one field) that returns a Collection of the Record objects representing the result set, as this example shows. </para>
   <para>
      <anchor id="Example_105-30"/>Using a DirectReadQuery </para>
   <para>DirectReadQuery directReadQuery = new DirectReadQuery();</para>
   <para>directReadQuery.setSQLString("Select * from EMPLOYEE"); </para>
   <para/>
   <para>// queryResults is a List of Record objects</para>
   <para>List queryResults = (List)session.executeQuery(directReadQuery);</para>
   <para/>
   <para>
      <anchor id="Using_a_ValueReadQuery"/>Using a ValueReadQuery</para>
   <para>You can use a ValueReadQuery to read a single data value (that is, one field). A single data value is returned, or null if no rows are returned, as this example shows. </para>
   <para>
      <anchor id="Example_105-31"/>Using a ValueReadQuery </para>
   <para>ValueReadQuery valueReadQuery = new ValueReadQuery();</para>
   <para>valueReadQuery.setSQLString("SELECT DISTINCT CURRENT TIMESTAMP FROM SYSTABLES");</para>
   <para/>
   <para>// result is a single Object value</para>
   <para>Object result = session.executeQuery(valueReadQuery);</para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>WARNING: Allowing an unverified SQL string to be passed into methods (for example: setSQLString method) makes your application vulnerable to SQL injection attacks. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>
      <anchor id="How_to_Update_Data_with_a_DatabaseQuery"/>How to Update Data with a DatabaseQuery</para>
   <para>You can use a DataModifyQuery to execute a nonselecting SQL statement (directly or as an SQLCall), as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-32">Using a DataModifyQuery</ulink> example shows. This is equivalent to Session method executeNonSelectingCall (see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_SQLCall">Using a SQLCall</ulink>). </para>
   <para>
      <anchor id="Example_105-32"/>Using a DataModifyQuery </para>
   <para>DataModifyQuery query = new DataModifyQuery(new SQLCall("Delete from Employee"));</para>
   <para>session.executeQuery(query);</para>
   <para/>
   <para>
      <anchor id="How_to_Specify_a_Custom_SQL_String_in_a_DatabaseQuery"/>How to Specify a Custom SQL String in a DatabaseQuery</para>
   <para>All DatabaseQuery objects provide a setSQLString method that you can use to define a custom SQL string. </para>
   <para>For more information about using custom SQL in queries, see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_SQLCall">Using a SQLCall</ulink>. </para>
   <para>The following example uses SQL to read all employee IDs. </para>
   <para>
      <anchor id="Example_105-33"/>A Direct Read Query with SQL </para>
   <para>DirectReadQuery query = new DirectReadQuery();</para>
   <para>query.setSQLString("SELECT EMP_ID FROM EMPLOYEE");</para>
   <para>List ids = (List) session.executeQuery(query);</para>
   <para>The following example uses SQL to switch to a different database. </para>
   <para>
      <anchor id="Example_105-34"/>A Data Modify Query with SQL </para>
   <para>DataModifyQuery query = new DataModifyQuery();</para>
   <para>query.setSQLString("USE SALESDATABASE");</para>
   <para>session.executeQuery(query);</para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>WARNING: Allowing an unverified SQL string to be passed into methods (for example: setSQLString method) makes your application vulnerable to SQL injection attacks. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>
      <anchor id="How_to_Specify_a_Custom_JPQL_String_in_a_DatabaseQuery"/>How to Specify a Custom JPQL String in a DatabaseQuery</para>
   <para>Information pending </para>
   <para/>
   <para>
      <anchor id="How_to_Use_Parameterized_SQL_and_Statement_Caching_in_a_DatabaseQuery"/>How to Use Parameterized SQL and Statement Caching in a DatabaseQuery</para>
   <para>By default, EclipseLink enables parameterized SQL (parameter binding) and statement caching. This causes EclipseLink to use a prepared statement, binding all SQL parameters and caching the prepared statement. When you reexecute this query, you avoid the SQL preparation, which improves performance. </para>
   <para>To disable parameterized SQL and statement caching on individual queries, use DatabaseQuery methods setShouldBindAllParameters and setShouldCacheStatement, passing in an argument of false. To re-enable this feature, pass in an argument of true. </para>
   <para>
      <anchor id="Example_105-35"/>A Simple ReadObjectQuery with Parameterized SQL </para>
   <para>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</para>
   <para>query.setShouldBindAllParameters(true);</para>
   <para>query.setShouldCacheStatement(true);</para>
   <para>Alternatively, you can configure parameterized SQL and binding at any of the following levels: </para>
   <orderedlist>
      <listitem>
         <para>project level–applies to all named queries (see <ulink url="http://wiki.eclipse.org/Configuring_a_Relational_Project_%28ELUG%29">Configuring Named Query Parameterized SQL and Statement Caching at the Project Level</ulink>); </para>
      </listitem>
      <listitem>
         <para>descriptor level–applies on a per-named-query basis (see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Named Query Options</ulink>); </para>
      </listitem>
      <listitem>
         <para>session database login level–applies to all queries (see <ulink url="http://wiki.eclipse.org/Configuring_a_Database_Login_%28ELUG%29">Configuring JDBC Options</ulink>) and provides additional parameter binding API to alleviate the limit imposed by some drivers on SQL statement size; </para>
      </listitem>
   </orderedlist>
   <para>For more information about using parameterized SQL and binding for data access optimization, see <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29">How to Use Parameterized SQL (Parameter Binding) and Prepared Statement Caching for Optimization</ulink>. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: For applications using a Java EE data source or external connection pool, you must configure statement caching in the Java EE server's data source–not in EclipseLink. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>
      <anchor id="Using_Named_Queries"/>Using Named Queries</para>
   <para>Named queries improve application performance because they are prepared once and they (and all their associated supporting objects) can be efficiently reused thereafter making them well suited for frequently executed operations. </para>
   <para>You can configure named queries at the session (see <ulink url="http://wiki.eclipse.org/Configuring_a_Session_%28ELUG%29">Configuring Named Queries at the Session Level</ulink>) or descriptor (see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Named Queries at the Descriptor Level</ulink>) level. </para>
   <para>For a session-level named query, you can execute the query using any of the following Session API methods: </para>
   <orderedlist>
      <listitem>
         <para>executeQuery(String queryName) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, arg1) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, arg1, arg2) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, arg1, arg2, arg3) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, List args) </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-36"/>Executing a Session-Level Named Query </para>
   <para>List args = new ArrayList();</para>
   <para>args.add("Sarah");</para>
   <para>Employee sarah = (Employee)session.executeQuery("employeeReadByFirstName", args);</para>
   <para>For a descriptor-level named query, you can execute the query using any of the following Session API calls, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-37">Executing a Descriptor Level Named Query</ulink> example shows: </para>
   <orderedlist>
      <listitem>
         <para>executeQuery(String queryName, Class domainClass) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, Class domainClass, arg1) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, Class domainClass, arg1, arg2) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, Class domainClass, arg1, arg2, arg3) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, Class domainClass, List args) </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-37"/>Executing a Descriptor Level Named Query </para>
   <para>List args = new ArrayList();</para>
   <para>args.add("Sarah");</para>
   <para>Employee sarah = (Employee)session.executeQuery("ReadByFirstName", Employee.class, args);</para>
   <para>For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Named Queries</ulink> 
   </para>
   <para/>
   <para>
      <anchor id="Using_a_SQLCall"/>Using a SQLCall</para>
   <para>The EclipseLink expression framework enables you to define complex queries at the object level. If your application requires a more complex query or one that accesses data directly, you can specify a custom SQL string in an SQLCall object and execute the SQL string in the context of a DatabaseQuery or using Session API for executing Call objects. </para>
   <para>You can provide an SQLCall object to any query instead of an expression, but the SQL string contained in the SQLCall must return all data required to build an instance of the queried class. </para>
   <para>The SQL string can be a complex SQL query that includes input, output, and input/output arguments using JDBC data types. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>WARNING: Allowing an unverified SQL string to be passed into methods makes your application vulnerable to SQL injection attacks. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>
      <anchor id="How_to_Configure_a_SQLCall_Without_Arguments"/>How to Configure a SQLCall Without Arguments</para>
   <para>You can configure a SQLCall without arguments and execute it directly using Session API. Use this approach when you want to execute a SQL string without arguments (or with hard-coded argument values). </para>
   <para>To configure a SQLCall input without arguments: </para>
   <orderedlist>
      <listitem>
         <para>Instantiate a SQLCall object. </para>
      </listitem>
      <listitem>
         <para>Pass the SQL string into the constructor, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-38">Executing a SQLCall Without Arguments</ulink> example shows. Alternatively, you can use SQLCall method setSQLString. </para>
      </listitem>
      <listitem>
         <para>Execute the SQLCall using the appropriate Session API, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-38">Executing a SQLCall Without Arguments</ulink> example shows. You can use any of the following Session methods, depending on the type of SQL string you define: </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-38"/>Executing a SQLCall Without Arguments </para>
   <para>List result = session.executeSelectingCall(new SQLCall("SELECT * FROM EMPLOYEE WHERE DEPT_ID =44"));</para>
   <para>
      <anchor id="How_to_Configure_a_SQLCall_with_Arguments_Using_JDBC_Data_Types"/>How to Configure a SQLCall with Arguments Using JDBC Data Types</para>
   <para>You can configure a SQLCall that takes any combination of input, output, or input/output arguments. Use this approach when you want to bind argument values to the SQLCall at runtime, receive output values from the SQLCall at execution time, or both. </para>
   <para>To configure a SQLCall with arguments using JDBC data types: </para>
   <orderedlist>
      <listitem>
         <para>Instantiate a SQLCall object. </para>
      </listitem>
      <listitem>
         <para>Create the SQL string and designate arguments as input, output, or input/output.EclipseLink assumes that a token in the custom SQL string of an SQLCall is an argument if it is prefixed with one or more number signs ( # ), as follows: </para>
      </listitem>
      <listitem>
         <para>Pass the SQL string into the constructor, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-39">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> show.Alternatively, you can use SQLCall method setSQLString. </para>
      </listitem>
      <listitem>
         <para>For each output argument, use the appropriate SQLCall method setCustomSQLArgumentType to specify the Java data type EclipseLink uses to return the output value, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink> shows.For an input argument, EclipseLink automatically converts the Java data type to the appropriate JDBC data type.For an input/output argument, the type of the input value determines the type of the output value. As <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> shows, the data type of the argument value passed into in_out is String ("MacDonald") so EclipseLink returns the output value (for EMP_ID) as a String. </para>
      </listitem>
      <listitem>
         <para>Instantiate a DatabaseQuery appropriate for your SQL string. </para>
      </listitem>
      <listitem>
         <para>Configure the DatabaseQuery with your SQLCall using DatabaseQuery method setCall, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-39">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Specify the names for all input and input/output arguments using DatabaseQuery method addArgument, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-39">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Create a Vector of argument values in the same order as you specified argument names in step 7, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-39">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Bind values to the arguments and execute the DatabaseQuery using Session method executeQuery(DatabaseQuery, java.util.Vector), passing in your DatabaseQuery and Vector of argument values, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-39">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> show. </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-39"/>Example 1: Specifying an SQLCall with an Input Argument Using the # Prefix: JDBC Data Types </para>
   <para>SQLCall sqlCall = new SQLCall("INSERT INTO EMPLOYEE (L_NAME) VALUES (#last_name)");</para>
   <para/>
   <para>DataModifyQuery query = new DataModifyQuery();</para>
   <para>query.setCall(sqlCall);</para>
   <para>query.addArgument("last_name");   // input</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald"); </para>
   <para>session.executeQuery(query, args);</para>
   <para>
      <anchor id="Example_105-40"/>Example 2: Specifying a SQLCall with an Output Argument Using the ### Prefix: JDBC Data Types </para>
   <para>SQLCall sqlCall = new SQLCall("BEGIN INSERT INTO EMPLOYEE (L_NAME) VALUES (#last_name) RETURNING EMP_ID INTO ###employee_id; END;");</para>
   <para>sqlCall.setCustomSQLArgumentType("employee_id", Integer.class); // specify output value type</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(sqlCall);</para>
   <para>query.addArgument("last_name");   // input</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald");</para>
   <para/>
   <para>Integer employeeID = (Integer) getSession().executeQuery(query, args);</para>
   <para>
      <anchor id="Example_105-41"/>Example 3: Specifying a SQLCall with an Input/Output Argument Using the #### Prefix: JDBC Data Types </para>
   <para>SQLCall sqlCall = new SQLCall("BEGIN INSERT INTO EMPLOYEE (L_NAME) VALUES (####in_out) RETURNING EMP_ID INTO ####in_out; END;");</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(sqlCall);</para>
   <para>query.addArgument("in_out");   // input and outpu</para>
   <para> </para>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald");         // type of input argument determines type of output value</para>
   <para/>
   <para>String lastName = (String) getSession().executeQuery(query, args);</para>
   <para>
      <anchor id="What_You_May_Need_to_Know_About_Using_a_SQLCall"/>What You May Need to Know About Using a SQLCall</para>
   <para>When using SQL calls, you can use a ReturningPolicy to control whether or not EclipseLink writes a parameter out or retrieves a value generated by the database. </para>
   <para>If you want to invoke a stored procedure or stored function, use a StoredProcedureCall or StoredFunctionCall. </para>
   <para>Alternatively, you can specify a simple SQL string directly on DatabaseQuery. You can use this approach to avoid the overhead of creating a SQLCall object when your SQL string is simple, uses hard-coded arguments (or no arguments), and you do not require the additional API that SQLCall provides. </para>
   <para>For more information, see the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_SQL_String_in_a_DatabaseQuery">How to Specify a Custom SQL String in a DatabaseQuery</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Returning Policy</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_StoredProcedureCall">Using a StoredProcedureCall</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_StoredFunctionCall">Using a StoredFunctionCall</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Using_a_StoredProcedureCall"/>Using a StoredProcedureCall</para>
   <para>The EclipseLink expression framework enables you to define complex queries at the object level. If your application requires a more complex query or one that invokes an existing stored procedure that your database provides, you can define a StoredProcedureCall object using both JDBC and PL/SQL data types and invoke the stored procedure in the context of a DatabaseQuery. </para>
   <para>If you are using an Oracle Database, you can pass in both JDBC and PL/SQL (non-JDBC) data types. </para>
   <para>If you are using a non-Oracle database, you may pass in only JDBC data types. </para>
   <para>
      <ulink url="http://wiki.eclipse.org/EclipseLink/Examples/JPA/nonJDBCArgsToStoredProcedures">This example</ulink> contains additional samples on on using stored procedures. </para>
   <para/>
   <para>
      <anchor id="How_to_Configure_a_StoredProcedureCall_Without_Arguments"/>How to Configure a StoredProcedureCall Without Arguments</para>
   <para>You can configure a StoredProcedureCall without arguments and execute it directly using Session API. Use this approach when you want to execute a stored procedure that does not take arguments or return values. </para>
   <para>To configure a StoredProcedureCall without arguments using JDBC data types: </para>
   <orderedlist>
      <listitem>
         <para>Instantiate a StoredProcedureCall object. </para>
      </listitem>
      <listitem>
         <para>Set the name of the stored procedure to execute using StoredProcedureCall method setProcedureName, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-42">Executing a SQLCall Without Arguments</ulink> example shows. </para>
      </listitem>
      <listitem>
         <para>Execute the StoredProcedureCall using the appropriate Session API, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-42">Executing a SQLCall Without Arguments</ulink> example shows.You can use any of the following Session methods, depending on the type of stored procedure you are executing: </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-42"/>Executing a SQLCall Without Arguments </para>
   <para>StoredProcedureCall spcall = new StoredProcedureCall();</para>
   <para>spcall.setProcedureName("Read_All_Employees");</para>
   <para>spcall.useNamedCursorOutputAsResultSet("RESULT_SET");</para>
   <para/>
   <para>List employees = (List) getSession().executeSelectingCall(spcall);</para>
   <para/>
   <para>
      <anchor id="How_to_Configure_a_StoredProcedureCall_with_Arguments_Using_JDBC_Data_Types"/>How to Configure a StoredProcedureCall with Arguments Using JDBC Data Types</para>
   <para>You can configure a StoredProcedureCall that takes any combination of input, output, or input/output arguments. Use this approach when you want to bind argument values to the StoredProcedureCall at runtime, receive output values from the StoredProcedureCall at execution time, or both. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: Use this procedure when all input, output, and input/output arguments are JDBC data types. If one or more arguments are PL/SQL (non-JDBC) data types, see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Configure_a_PLSQLStoredProcedureCall_with_PL.2FSQL_Data_Type_Arguments">How to Configure a PLSQLStoredProcedureCall with PL/SQL Data Type Arguments</ulink>. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>To configure a StoredProcedureCall with arguments using JDBC data types: </para>
   <orderedlist>
      <listitem>
         <para>Instantiate a StoredProcedureCall object. </para>
      </listitem>
      <listitem>
         <para>Specify the name of the stored procedure to call using StoredProcedureCall method setProcedureName, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-44">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-45">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>For each argument, use the appropriate StoredProcedureCall methods to specify whether arguments are input, output, or input/output arguments: </para>
      </listitem>
      <listitem>
         <para>Instantiate a DatabaseQuery appropriate for your stored procedure. </para>
      </listitem>
      <listitem>
         <para>Configure the DatabaseQuery with your StoredProcedureCall using DatabaseQuery method setCall, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-44">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-45">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Specify the names for all input and input/output arguments using DatabaseQuery method addArgument, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-44">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-45">Example 3</ulink> show. If you associated stored procedure argument names with more meaningful alternate names in step [[#3], use the alternate names in the DatabaseQuery method addArgument, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink> shows. </para>
      </listitem>
      <listitem>
         <para>Create a Vector of argument values in the same order as you specified argument names in step [[#6], as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-44">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-45">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Bind values to the arguments and execute the DatabaseQuery using Session method executeQuery(DatabaseQuery, java.util.Vector), passing in your DatabaseQuery and Vector of argument values, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-44">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-45">Example 3</ulink> show. </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-43"/>Example 1: Specifying a StoredProcedureCall with an Input Argument: JDBC Data Types </para>
   <para>// CREATE PROCEDURE INSERT_EMPLOYEE(L_NAME IN VARCHAR) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with last name.</para>
   <para>// END;</para>
   <para/>
   <para>StoredProcedureCall spcall = new StoredProcedureCall();</para>
   <para>spcall.setProcedureName("INSERT_EMPLOYEE");</para>
   <para>spcall.addNamedArgument("L_NAME", "last_name");</para>
   <para/>
   <para>DataModifyQuery query = new DataModifyQuery();</para>
   <para>query.setCall(spcall);</para>
   <para>query.addArgument("last_name");   // input</para>
   <para/>
   <para>Vector arguments = new Vector();</para>
   <para>arguments.add("MacDonald");</para>
   <para>session.executeQuery(query, arguments);</para>
   <para>
      <anchor id="Example_105-44"/>Example 2: Specifying a StoredProcedureCall with an Output Argument: JDBC Data Types </para>
   <para>// CREATE PROCEDURE GET_EMP_ID(L_NAME IN VARCHAR, EMP_ID OUT INTEGER) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with last name and return the EMP_ID for this record.</para>
   <para>// END;</para>
   <para/>
   <para>StoredProcedureCall spcall = new StoredProcedureCall();</para>
   <para>spcall.setProcedureName("GET_EMP_ID");</para>
   <para>spcall.addNamedArgument("L_NAME");</para>
   <para>spcall.addNamedOutputArgument(</para>
   <para>    "EMP_ID",      // procedure parameter name</para>
   <para>    "EMP_ID",      // out argument field name</para>
   <para>    Integer.class  // Java type corresponding to type returned by procedure</para>
   <para>);</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(spcall);</para>
   <para>query.addArgument("L_NAME");   // input</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald");</para>
   <para/>
   <para>Integer employeeID = (Integer) getSession().executeQuery(query, args);</para>
   <para>
      <anchor id="Example_105-45"/>Example 3: Specifying a StoredProcedureCall with an Input/Output Argument: JDBC Data Types </para>
   <para>// CREATE PROCEDURE INSERT_EMPLOYEE(IN_OUT INOUT VARCHAR) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with last name and return the EMP_CODE_NAME for this record.</para>
   <para>// END;</para>
   <para/>
   <para>StoredProcedureCall spcall = new StoredProcedureCall();</para>
   <para>spcall.setProcedureName("INSERT_EMP"); // returns EMP_CODE_NAME after insert</para>
   <para>spcall.addNamedInOutputArgument(</para>
   <para>    "IN_OUT",       // procedure parameter name</para>
   <para>    "IN_OUT",       // out argument field name</para>
   <para>    String.class    // Java type corresponding to type returned by procedure</para>
   <para>);</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(sqlCall);</para>
   <para>query.addArgument("INOUT");   // input and outpu</para>
   <para> </para>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald");         // type of input argument determines type of output value</para>
   <para> </para>
   <para>String employeeCode = (String)getSession().executeQuery(query, args));</para>
   <para/>
   <para>
      <anchor id="How_to_Configure_a_PLSQLStoredProcedureCall_with_PL.2FSQL_Data_Type_Arguments"/>How to Configure a PLSQLStoredProcedureCall with PL/SQL Data Type Arguments</para>
   <para>You must use the org.eclipse.persistence.platform.database.oracle.PLSQLStoredProcedureCall class if any combination of input, output, or input/output arguments are PL/SQL (non-JDBC) data types. Use this approach when you want to bind argument values to the PLSQLStoredProcedureCall at run time, receive output values from the PLSQLStoredProcedureCall at execution time, or both. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: If all arguments are JDBC (not PL/SQL data types), see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Configure_a_StoredProcedureCall_with_Arguments_Using_JDBC_Data_Types">How to Configure a StoredProcedureCall with Arguments Using JDBC Data Types</ulink>. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>To configure a PLSQLStoredProcedureCall with arguments using JDBC and PL/SQL data types: </para>
   <orderedlist>
      <listitem>
         <para>Instantiate a PLSQLStoredProcedureCall object. </para>
      </listitem>
      <listitem>
         <para>Specify the name of the stored procedure to call using PLSQLStoredProcedureCall method setProcedureName, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-46">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-47">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>For each argument, use the appropriate PLSQLStoredProcedureCall methods to specify whether arguments are input, output, or input/output arguments: </para>
      </listitem>
      <listitem>
         <para>Instantiate a DatabaseQuery appropriate for your stored procedure. </para>
      </listitem>
      <listitem>
         <para>Configure the DatabaseQuery with your PLSQLStoredProcedureCall using DatabaseQuery method setCall, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-46">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-47">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Specify the names for all input and input/output arguments using DatabaseQuery method addArgument, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-46">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-47">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> show.If you associated stored procedure argument names with more meaningful alternate names in step 3, use the alternate names in the DatabaseQuery method addArgument, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> shows. </para>
      </listitem>
      <listitem>
         <para>Create a Vector of argument values in the same order as you specified argument names in step #6, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-46">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-47">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Bind values to the arguments and execute the DatabaseQuery using Session method executeQuery(DatabaseQuery, java.util.Vector), passing in your DatabaseQuery and Vector of argument values, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-46">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-47">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> show. </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-46"/>Example 1: Specifying a PLSQLStoredProcedureCall with an Input Argument: JDBC and PL/SQL Data Types </para>
   <para>// CREATE PROCEDURE INSERT_EMPLOYEE(L_NAME IN VARCHAR, MANAGER IN BOOLEAN) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with last name and whether or not the employee is a manager.</para>
   <para>// END;</para>
   <para/>
   <para>PLSQLStoredProcedureCall plsqlcall = new PLSQLStoredProcedureCall();</para>
   <para>plsqlcall.setProcedureName("INSERT_EMPLOYEE");</para>
   <para>plsqlcall.addNamedArgument("L_NAME", JDBCTypes.VARCHAR_TYPE, 40); // must specify a length</para>
   <para>plsqlcall.addNamedArgument("MANAGER", OraclePLSQLTypes.PLSQLBoolean);</para>
   <para/>
   <para>DataModifyQuery query = new DataModifyQuery();</para>
   <para>query.setCall(plsqlcall);</para>
   <para>query.addArgument("L_NAME");    // input</para>
   <para>query.addArgument("MANAGER");   // input</para>
   <para/>
   <para>Vector arguments = new Vector();</para>
   <para>arguments.add("MacDonald");</para>
   <para>arguments.add(Integer.valueOf(1));</para>
   <para>session.executeQuery(query, arguments);</para>
   <para/>
   <para>
      <anchor id="Example_105-47"/>Example 2: Specifying a PLSQLStoredProcedureCall with an Output Argument: JDBC and PL/SQL Data Types </para>
   <para>// CREATE PROCEDURE GET_EMP_ID(L_NAME IN VARCHAR, EMP_ID OUT PLS_INTEGER) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with last name and return EMP_ID for this row.</para>
   <para>// END;</para>
   <para/>
   <para>PLSQLStoredProcedureCall plsqlcall= new PLSQLStoredProcedureCall();</para>
   <para>plsqlcall.setProcedureName("GET_EMP_ID");</para>
   <para>plsqlcall.addNamedArgument("L_NAME", JDBCTypes.VARCHAR_TYPE, 25);</para>
   <para>plsqlcall.addNamedOutputArgument("EMP_ID", OraclePLSQLTypes.PLSQLInteger);</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(plsqlcall);</para>
   <para>query.addArgument("L_NAME");   // input</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald");</para>
   <para/>
   <para>Number employeeID = (Number) getSession().executeQuery(query, args);</para>
   <para/>
   <para>
      <anchor id="Example_105-48"/>Example 3: Specifying a PLSQLStoredProcedureCall with an Input/Output Argument: JDBC and PL/SQL Data Types </para>
   <para>// CREATE PROCEDURE INSERT_EMP(IN_OUT INOUT PLS_INTEGER) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with department id and return </para>
   <para>//     the EMP_ID for this record.</para>
   <para>// END;</para>
   <para/>
   <para>PLSQLStoredProcedureCall plsqlcall= new PLSQLStoredProcedureCall();</para>
   <para>plsqlcall.setProcedureName("INSERT_EMP");</para>
   <para>plsqlcall.addNamedInOutputArgument("IN_OUT", OraclePLSQLTypes.PLSQLInteger);</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(plsqlcall);</para>
   <para>query.addArgument("IN_OUT");       // input and outpu</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.add(Integer.valueOf(1234));   // department id</para>
   <para/>
   <para>Integer employeeID = new Integer(BigDecimal.intValue(getSession().executeQuery(query, args)));</para>
   <para/>
   <para>
      <anchor id="How_to_Specify_a_Simple_Optimistic_Version_Locking_Value_with_a_StoredProcedureCall_Using_JDBC_Data_Types"/>How to Specify a Simple Optimistic Version Locking Value with a StoredProcedureCall Using JDBC Data Types</para>
   <para>When using optimistic version locking, you typically delegate the responsibility for updating the version field to EclipseLink. </para>
   <para>Alternatively, you may choose to use stored procedures to manually update the version field for all of create, read, update, and delete operations. </para>
   <para>When using optimistic locking and stored procedure calls, you may only use a simple, sequential numeric value that the stored procedure can generate independently of EclipseLink. To use a complex value, such as a timestamp, you must delegate the responsibility for updating the version field to EclipseLink. </para>
   <para>For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_Descriptors_%28ELUG%29">Optimistic Version Locking Policies</ulink>. </para>
   <para>To specify a simple optimistic version locking value with a StoredProcedureCall using JDBC data types: </para>
   <orderedlist>
      <listitem>
         <para>Create stored procedures for create, read, update, and delete operations.Each stored procedure is responsible for checking and updating the optimistic lock field: a simple sequential numeric value in your database. The following example shows a typical stored procedure for the update operation. <anchor id="Example_105-49"/>Stored Procedure for Update Operation Using Simple Optimistic Version Locking </para>
         <para>PROCEDURE Update_Employee (</para>
         <para>    P_EMP_ID NUMBER,</para>
         <para>    P_SALARY NUMBER,</para>
         <para>    P_END_DATE DATE,</para>
         <para>    P_MANAGER_ID NUMBER,</para>
         <para>    P_START_DATE DATE,</para>
         <para>    P_F_NAME VARCHAR2,</para>
         <para>    P_L_NAME VARCHAR2,</para>
         <para>    P_GENDER VARCHAR2,</para>
         <para>    P_ADDR_ID NUMBER,</para>
         <para>    P_VERSION NUMBER,</para>
         <para>    P_START_TIME DATE,</para>
         <para>    P_END_TIME DATE,</para>
         <para>    O_ERROR_CODE OUT NUMBER) AS</para>
         <para>BEGIN </para>
         <para>Update SALARY set SALARY = P_SALARY WHERE (EMP_ID = P_EMP_ID); </para>
         <para>Update EMPLOYEE set END_DATE = P_END_DATE, MANAGER_ID = P_MANAGER_ID, VERSION = P_VERSION + 1, START_DATE = P_START_DATE, F_NAME = P_F_NAME, L_NAME = P_L_NAME, GENDER = P_GENDER, ADDR_ID = P_ADDR_ID where ((EMP_ID = P_EMP_ID) and (VERSION = P_VERSION)); </para>
         <para>O_ERROR_CODE := SQL%ROWCOUNT; </para>
         <para>END;</para>
      </listitem>
      <listitem>
         <para>Create a StoredProcedureCall for each of your custom create, read, update, and delete stored procedures. The following example shows the StoredProcedureCall for the update stored procedure in the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-49">Stored Procedure for Update Operation Using Simple Optimistic Version Locking</ulink>. <anchor id="Example_105-50"/>example. StoredProcedureCall for Update Stored Procedure </para>
         <para>UpdateObjectQuery updateQuery = new UpdateObjectQuery();</para>
         <para>call = new StoredProcedureCall();</para>
         <para>call.setUsesBinding(true);</para>
         <para>call.setProcedureName("Update_Employee");</para>
         <para>call.addNamedArgument("P_EMP_ID", "EMP_ID");</para>
         <para>call.addNamedArgument("P_SALARY", "SALARY");</para>
         <para>call.addNamedArgument("P_END_DATE", "END_DATE");</para>
         <para>call.addNamedArgument("P_MANAGER_ID", "MANAGER_ID");</para>
         <para>call.addNamedArgument("P_START_DATE", "START_DATE");</para>
         <para>call.addNamedArgument("P_F_NAME", "F_NAME");</para>
         <para>call.addNamedArgument("P_L_NAME", "L_NAME");</para>
         <para>call.addNamedArgument("P_GENDER", "GENDER");</para>
         <para>call.addNamedArgument("P_ADDR_ID", "ADDR_ID");</para>
         <para>call.addNamedArgument("P_VERSION", "VERSION");</para>
         <para>call.addNamedArgument("P_START_TIME", "START_TIME");</para>
         <para>call.addNamedArgument("P_END_TIME", "END_TIME");</para>
         <para>call.addNamedOutputArgument("O_ERROR_CODE", "O_ERROR_CODE", Long.class);</para>
         <para>updateQuery.setCall(call);</para>
         <para>For more information, see the following: </para>
      </listitem>
      <listitem>
         <para>Configure the EclipseLink descriptor query manager to use your StoredProcedureCall objects for create, read, update, and delete operations. The following example shows how to use a descriptor customizer class to update the EclipseLink descriptor query manager with the update StoredProcedureCall from the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-50">StoredProcedureCall for Update Stored Procedure</ulink> example. <anchor id="Example_105-51"/>Configuring the EclipseLink Descriptor Query Manager with a StoredProcedureCall </para>
         <para>import org.eclipse.persistence.sessions.factories.DescriptorCustomizer;</para>
         <para>import org.eclipse.persistence.descriptors.ClassDescriptor;</para>
         <para/>
         <para>public class EmployeeDescriptorCustomizer implements DescriptorCustomizer {</para>
         <para/>
         <para>    public void customize(ClassDescriptor descriptor) {</para>
         <para>        descriptor.getQueryManager().setUpdateQuery(updateQuery);</para>
         <para>    }</para>
         <para>}</para>
         <para>For more information, see the following: </para>
      </listitem>
      <listitem>
         <para>Define a StoredProcedureCall output parameter event to handle any errors.In the Oracle database, the rowcount is not maintained when calling a stored procedure. You must ensure that the rowcount is returned using an output parameter. Use the Session event outputParametersDetected to check the rowcount and raise an error. Alternatively, the stored procedure could check the rowcount and throw an exception.For more information, see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Configure_a_StoredProcedureCall_Output_Parameter_Event_Using_JDBC_or_PL.2FSQL_Data_Types">How to Configure a StoredProcedureCall Output Parameter Event Using JDBC or PL/SQL Data Types</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="How_to_Configure_a_StoredProcedureCall_Output_Parameter_Event_Using_JDBC_or_PL.2FSQL_Data_Types"/>How to Configure a StoredProcedureCall Output Parameter Event Using JDBC or PL/SQL Data Types</para>
   <para>EclipseLink manages output parameter events for databases that support them. For example, if a stored procedure returns an error code that indicates that the application wants to check for an error condition, EclipseLink raises the session event outputParametersDetected to allow the application to process the output parameters. </para>
   <para>To configure a StoredProcedureCall output parameter event using JDBC or PL/SQL data types: </para>
   <orderedlist>
      <listitem>
         <para>Create a StoredProcedureCall using JDBC arguments, PL/SQL arguments, or both. The <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-55">Stored Procedure</ulink> example shows a StoredProcedureCall using JDBC arguments.For more information, see the following: </para>
         <para>
            <anchor id="Example_105-52"/>Stored Procedure </para>
         <para>PROCEDURE Update_Employee (</para>
         <para>    P_EMP_ID NUMBER,</para>
         <para>    P_SALARY NUMBER,</para>
         <para>    P_END_DATE DATE,</para>
         <para>    P_MANAGER_ID NUMBER,</para>
         <para>    P_START_DATE DATE,</para>
         <para>    P_F_NAME VARCHAR2,</para>
         <para>    P_L_NAME VARCHAR2,</para>
         <para>    P_GENDER VARCHAR2,</para>
         <para>    P_ADDR_ID NUMBER,</para>
         <para>    P_VERSION NUMBER,</para>
         <para>    P_START_TIME DATE,</para>
         <para>    P_END_TIME DATE,</para>
         <para>    O_ERROR_CODE OUT NUMBER) AS</para>
         <para>BEGIN </para>
         <para>Update SALARY set SALARY = P_SALARY WHERE (EMP_ID = P_EMP_ID); </para>
         <para>Update EMPLOYEE set END_DATE = P_END_DATE, MANAGER_ID = P_MANAGER_ID, VERSION = P_VERSION + 1, START_DATE = P_START_DATE, F_NAME = P_F_NAME, L_NAME = P_L_NAME, GENDER = P_GENDER, ADDR_ID = P_ADDR_ID where ((EMP_ID = P_EMP_ID) and (VERSION = P_VERSION)); </para>
         <para>O_ERROR_CODE := SQL%ROWCOUNT; </para>
         <para>END;</para>
      </listitem>
      <listitem>
         <para>Create a SessionEventListener that handles the outputParametersDetected event, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-53">SessionEventListener for outputParametersDetected Event</ulink> example shows. Subclassing the org.eclipse.persistence.sessions.SessionEventAdapter is an easy way to create a SessionEventListener: you only need to override the specific SessionEventListener methods you are interested in. In the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-53">SessionEventListener for outputParametersDetected Event</ulink> example, SessionEvent method getProperty uses an argument value of ERROR_CODE. This property name and its data type is defined in the StoredProcedureCall method addNamedOutputArgument. <anchor id="Example_105-53"/>SessionEventListener for outputParametersDetected Event </para>
         <para>import org.eclipse.persistence.sessions.SessionEventAdapter;</para>
         <para>importorg.eclipse.persistence.sessions.SessionEvent;</para>
         <para/>
         <para>public class OptimisticLockListener extends SessionEventAdapter {</para>
         <para/>
         <para>    public OptimisticLockListener() {}</para>
         <para> </para>
         <para>    public void outputParametersDetected(SessionEvent event) {</para>
         <para>        DatabaseQuery query = event.getQuery();</para>
         <para>        if ((query != null) &amp;&amp; query.isObjectLevelModifyQuery()) {</para>
         <para>            Number rowcount = new Integer(1);</para>
         <para>            if (event.getResult() instanceof Map) {</para>
         <para>                rowcount = (Number)((Map)event.getResult()).get("O_ERROR_CODE");</para>
         <para>            }</para>
         <para>            if (rowcount.longValue() &lt;= 0) {</para>
         <para>                if (query.isDeleteObjectQuery()) {</para>
         <para>                    DeleteObjectQuery deleteQuery = (DeleteObjectQuery)query;</para>
         <para>                    throw OptimisticLockException.objectChangedSinceLastReadWhenDeleting</para>
         <para>                                                  (deleteQuery.getObject(), deleteQuery);</para>
         <para>                } </para>
         <para>                else if (query.isWriteObjectQuery()) {</para>
         <para>                    WriteObjectQuery updateQuery = (WriteObjectQuery)query;</para>
         <para>                    throw OptimisticLockException.objectChangedSinceLastReadWhenUpdating</para>
         <para>                                                  (updateQuery.getObject(), updateQuery);</para>
         <para>                }</para>
         <para>            }</para>
         <para>        }</para>
         <para>    }</para>
         <para>}</para>
      </listitem>
      <listitem>
         <para>Add your SessionEventListener instance to the session event manager, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-54">Adding SessionEventListener to the Session Event Manager</ulink> example shows. You must do this step before executing your stored procedure. For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Sessions_%28ELUG%29">Managing Session Events with the Session Event Manager</ulink> 
            <anchor id="Example_105-54"/>Adding SessionEventListener to the Session Event Manager </para>
         <para>getSession().getEventManager().addListener(new OptimisticLockListener());</para>
      </listitem>
      <listitem>
         <para>Execute the query.If there is an error and a SessionEvent of type outputParametersDetected is raised, EclipseLink will notify your SessionEventListener. &lt;/div&gt; </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="What_You_May_Need_to_Know_About_Using_a_StoredProcedureCall"/>What You May Need to Know About Using a StoredProcedureCall</para>
   <para>EclipseLink automatically converts PL/SQL data types into the Java data types that the following table lists for out arguments (and the out value of input/output arguments). </para>
   <para>
      <anchor id="Table_105-1"/>EclipseLink PL/SQL to Java Data Type Conversion: Out Arguments and Out Value of Input/Output Arguments </para>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>
                  <anchor id="r1c1-t14"/>PL/SQL Data Type <anchor id="r1c2-t14"/>
               </para>
            </entry>
            <entry>
               <para>OraclePLSQLTypes Enum <anchor id="r1c3-t14"/>
               </para>
            </entry>
            <entry>
               <para>Java Type <anchor id="r2c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>BINARY_INTEGER </para>
            </entry>
            <entry>
               <para>BinaryInteger </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r3c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>BOOLEAN </para>
            </entry>
            <entry>
               <para>PLSQLBoolean </para>
            </entry>
            <entry>
               <para>java.lang.Integer <anchor id="r4c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>DEC </para>
            </entry>
            <entry>
               <para>Dec </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r5c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>INT </para>
            </entry>
            <entry>
               <para>Int </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r6c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>NATURAL </para>
            </entry>
            <entry>
               <para>Natural </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r7c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>NATURALN </para>
            </entry>
            <entry>
               <para>NaturalN </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r8c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>PLS_INTEGER </para>
            </entry>
            <entry>
               <para>PLSQLInteger </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r9c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>POSITIVE </para>
            </entry>
            <entry>
               <para>Positive </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r10c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>POSITIVEN </para>
            </entry>
            <entry>
               <para>PositiveN </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r11c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>SIGNTYPE </para>
            </entry>
            <entry>
               <para>SignType </para>
            </entry>
            <entry>
               <para>java.lang.Integer </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>You may use the value from any Java type for a PL/SQL in argument (or in value of an input/output argument) as long as the size and precision of the Java type is appropriate for the PL/SQL type. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: You no longer need to use DatabaseQuery method bindAllParameters when using a StoredProcedureCall with OUT or INOUT parameters. However, you should always specify the Java type for all OUT and INOUT parameters. If you do not, be aware of the fact that they default to type String. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>
      <anchor id="Using_a_StoredFunctionCall"/>Using a StoredFunctionCall</para>
   <para>The EclipseLink expression framework enables you to define complex queries at the object level. If your application requires a more complex query or one that invokes an existing stored function that your database provides, you can define a StoredFunctionCall object using both JDBC and PL/SQL data types and invoke the stored function in the context of a DatabaseQuery. </para>
   <para>Note that not all databases provide stored functions. </para>
   <para>In the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-56">Creating a StoredFunctionCall</ulink> example, note that the name of the stored function is set using StoredFunctionCall method setProcedureName. </para>
   <para>
      <anchor id="Example_105-56"/>Creating a StoredFunctionCall </para>
   <para>StoredFunctionCall functionCall = new StoredFunctionCall();</para>
   <para>functionCall.setProcedureName("CHECK_VALID_EMPLOYEE");</para>
   <para>functionCall.addNamedArgument("EMP_ID");</para>
   <para>functionCall.setResult("FUNCTION_RESULT", String.class);</para>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(functionCall);</para>
   <para>query.addArgument("EMP_ID");</para>
   <para>List args = new ArrayList();</para>
   <para>args.addElement(new Integer(44));</para>
   <para>String valid = (String) session.executeQuery(query, args);</para>
   <para/>
   <para>
      <anchor id="What_You_May_Need_to_Know_About_Using_a_StoredFunctionCall"/>What You May Need to Know About Using a StoredFunctionCall</para>
   <para>In general, both stored procedures and stored functions let you specify input parameters, output parameters, and input and output parameters. For more information, see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_StoredProcedureCall">Using a StoredProcedureCall</ulink>. However, stored procedures need not return values, while stored functions always return a single value. </para>
   <para>The StoredFunctionCall class extends StoredProcedureCall to add one new method - setResult. Use this method to specify the name (and alternatively both the name and type) under which EclipseLink stores the return value of the stored function. </para>
   <para>When EclipseLink prepares a StoredFunctionCall, it validates its SQL and throws a ValidationException under the following circumstances: </para>
   <orderedlist>
      <listitem>
         <para>If your current platform does not support stored functions. Stored functions are supported only for Oracle. </para>
      </listitem>
      <listitem>
         <para>If you fail to specify the return type. </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Using_Java_Persistence_Query_Language_.28JPQL.29_Calls"/>Using Java Persistence Query Language (JPQL) Calls</para>
   <para>Information pending </para>
   <para/>
   <para/>
   <para>
      <anchor id="Using_EIS_Interactions"/>Using EIS Interactions</para>
   <para>For an EIS root descriptor, you can define EIS interactions to invoke methods on an EIS. </para>
   <para>EclipseLink represents EIS interactions using instances of org.eclipse.persistence.eis.interactions.EISInteraction. These classes implement the Call interface and can be used wherever a Call can be used. </para>
   <para>This table lists the type of EIS interactions that EclipseLink supports. </para>
   <para>
      <anchor id="Table_105-2"/>
   </para>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>
                  <anchor id="r1c1-t16"/>EIS Interaction Type <anchor id="r1c2-t16"/>
               </para>
            </entry>
            <entry>
               <para>Description <anchor id="r2c1-t16"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>IndexedInteraction </para>
            </entry>
            <entry>
               <para>Defines the specification for a call to a JCA interaction that uses indexed records. Builds the input and output records from the arguments by position. <anchor id="r3c1-t16"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>MappedInteraction </para>
            </entry>
            <entry>
               <para>Defines the specification for a call to a JCA interaction that uses mapped records. Builds the input and output records from the arguments by name. <anchor id="r4c1-t16"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>XMLInteraction </para>
            </entry>
            <entry>
               <para>Specifies an instance of MappedInteraction that defines the specification for a call to a JCA interaction that uses XML records defined by the XML schema document (XSD) associated with the EIS project (for more information, see <ulink url="http://wiki.eclipse.org/Using_Workbench_%28ELUG%29">How to Import an XML Schema</ulink>). <anchor id="r5c1-t16"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>QueryStringInteraction </para>
            </entry>
            <entry>
               <para>Specifies an instance of MappedInteraction that defines the specification for a call to a JCA interaction that uses a query string. Prefix arguments in the query string with a number sign ( # ) character. <anchor id="r6c1-t16"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>XQueryInteraction </para>
            </entry>
            <entry>
               <para>Specifies an instance of XMLInteraction that defines the specification for a call to a JCA interaction that uses XQuery. Translates the XQuery from the query arguments. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>You can use EclipseLink to define an interaction for each basic persistence operation (insert, update, delete, read object, read all, or does exist) so that when you query and modify your EIS-mapped objects, the EclipseLink runtime will use the appropriate EIS interaction. For more information, see <ulink url="http://wiki.eclipse.org/Configuring_an_EIS_Descriptor_%28ELUG%29">Configuring Custom EIS Interactions for Basic Persistence Operations</ulink>. </para>
   <para>You can also use EclipseLink to define an interaction as a named query for read object and read-all object queries. These queries are not called for basic persistence operations; you can call these additional queries by name in your application for special purposes. For more information, see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Creating an EIS Interaction for a Named Query</ulink>. </para>
   <para/>
   <para>
      <anchor id="Handling_Exceptions"/>Handling Exceptions</para>
   <para>Most exceptions in queries are database exceptions, resulting from a failure in the database operation. Write operations can also throw an OptimisticLockException on a write, update, or delete operation in applications that use optimistic locking. To catch these exceptions, execute all database operations within a try-catch block: </para>
   <para>    try {</para>
   <para>        List employees = session.readAllObjects(Employee.class); </para>
   <para>    } </para>
   <para>    catch (DatabaseException exception) {</para>
   <para>        // handle exception </para>
   <para>    }</para>
   <para>See <ulink url="http://wiki.eclipse.org/EclipseLink_Exception_Error_Reference_%28ELUG%29">EclipseLink Exception Error Reference</ulink> for more information about exceptions in an EclipseLink application. </para>
   <para/>
   <para>
      <anchor id="Handling_Collection_Query_Results"/>Handling Collection Query Results</para>
   <para>EclipseLink provides a useCollectionClass method to all subclasses of DataReadQuery and ReadAllQuery, that you can use to configure a query to return results as any concrete instance of Collection or Map. </para>
   <para>Do not confuse collection query result configuration with a mapping container policy (see <ulink url="http://wiki.eclipse.org/Configuring_a_Mapping_%28ELUG%29">Configuring Container Policy</ulink>): there is no relationship between the two. Collection query result configuration determines how EclipseLink returns multiobject results from a particular query. A mapping container policy tells EclipseLink how your domain object implements a data member that contains a collection. </para>
   <para>For example, consider a class Employee with a data member phoneNumbers. In your implementation of Employee, the getPhoneNumbers method returns a Vector. Using Workbench, you map the phoneNumbers data member as a one-to-many mapping. You configure the mapping container policy so that the mapping contains its value (many PhoneNumber objects) in a Vector. This corresponds to your implementation of Employee. </para>
   <para>You define a ReadAllQuery named localPhoneNumbers on the DescriptorQueryManager of the PhoneNumber. The localPhoneNumbers query takes one argument, the ID of an Employee object, and returns all the phone numbers from its phoneNumbers data member whose area code is 613. </para>
   <para>You get this query by name from the DescriptorQueryManager for PhoneNumber. You call the useCollectionClass method on this ReadAllQuery, passing in the ArrayList class. You execute the query, passing in the ID of an Employee. The query returns all the PhoneNumber objects from the Employee object's phoneNumbers data member whose area code is 613. The query returns these results as an ArrayList. </para>
   <para/>
   <para>
      <anchor id="Handling_Report_Query_Results"/>Handling Report Query Results</para>
   <para>The following table lists the ReportQuery methods you can use to configure how a ReportQuery returns its results. </para>
   <para>By default, the ReportQuery returns a Collection of ReportQueryResult objects. </para>
   <para>
      <anchor id="Table_105-3"/>Report Query Result Options </para>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>
                  <anchor id="r1c1-t17"/>Method <anchor id="r1c2-t17"/>
               </para>
            </entry>
            <entry>
               <para>Query Returns <anchor id="r1c3-t17"/>
               </para>
            </entry>
            <entry>
               <para>Description <anchor id="r2c1-t17"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>setShouldReturnSingleAttribute </para>
            </entry>
            <entry>
               <para>Collection </para>
            </entry>
            <entry>
               <para>Returns a single attribute (not wrapped in a ReportQueryResult). </para>
               <para>Use this option if you know that the ReportQuery returns only one attribute. <anchor id="r3c1-t17"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>setShouldReturnSingleResult </para>
            </entry>
            <entry>
               <para>ReportQueryResult </para>
            </entry>
            <entry>
               <para>Returns only the first ReportQueryResult object (not wrapped in a Collection or Map). </para>
               <para>Use this option if you know that the ReportQuery returns only one row. <anchor id="r4c1-t17"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>setShouldReturnSingleValue </para>
            </entry>
            <entry>
               <para>Object </para>
            </entry>
            <entry>
               <para>Returns only a single value. </para>
               <para>Use this option if you know that the ReportQuery returns only one row that contains only one attribute. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>Advanced Queries</para>
   <para/>
   <para>Using Redirect Queries</para>
   <para>A redirect query is a named query that delegates query execution control to your application. redirect queried allow you to define the query implementation in code as a static method. </para>
   <para>To perform complex operations, you can combine query redirectors with the EclipseLink query framework. </para>
   <para/>
   <para>
      <anchor id="How_to_Create_a_Redirect_Query"/>How to Create a Redirect Query</para>
   <para>To perform complex operations, you can combine query redirectors with the EclipseLink query framework. To create a redirector, implement the org.eclipse.persistence.queries.QueryRedirector interface. The query mechanism executes the Object invokeQuery(DatabaseQuery query, Record arguments, Session session) method and waits for the results. </para>
   <para>EclipseLink provides one preimplemented redirector, the MethodBasedQueryRedirector method. To use this redirector, create a static invoke method on a class, and use the setMethodName(String) call to specify the method to invoke. </para>
   <para>
      <anchor id="Example_107-1"/>Redirect Query </para>
   <para>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</para>
   <para>query.setName("findEmployeeByAnEmployee");</para>
   <para>query.addArgument("employee");</para>
   <para/>
   <para>MethodBaseQueryRedirector redirector = new</para>
   <para>     MethodBaseQueryRedirector(QueryRedirectorTest.class, "findEmployeeByAnEmployee");</para>
   <para>query.setRedirector(redirector);</para>
   <para>Descriptor descriptor = getSession().getDescriptor(query.getReferenceClass());</para>
   <para>descriptor.getQueryManager().addQuery(query.getName(), query);</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.addElement(employee);</para>
   <para>objectFromDatabase = </para>
   <para>    getSession().executeQuery("findEmployeeByAnEmployee", Employee.class, args);</para>
   <para/>
   <para>public class QueryRedirectorTest {</para>
   <para/>
   <para>    public static Object findEmployeeByAnEmployee(</para>
   <para>                                 DatabaseQuery query,</para>
   <para>                                 org.eclipse.peristence.sessions.Record arguments,</para>
   <para>                                 org.eclipse.peristence.sessions.Session</para>
   <para>                                 session) {</para>
   <para>        ((ReadObjectQuery) query).setSelectionObject(arguments.get("employee"));</para>
   <para>        return session.executeQuery(query);</para>
   <para>    }</para>
   <para>}</para>
   <para/>
   <para>
      <anchor id="Using_Historical_Queries"/>Using Historical Queries</para>
   <para>To make a query time-aware, you specify an AsOfClause that EclipseLink appends to the query. Use the AsOfClause class if your historical schema is based on time stamps or the AsOfSCNClause class if your historical schema is based on database system change numbers. You can specify an AsOfClause at the time you acquire a historical session so that EclipseLink appends the same clause to all queries, or you can specify an AsOfClause on a query-by-query basis. </para>
   <para>The following example shows how to create a query that uses a particular AsOfClause. This query will read all Employee objects as of the time specified by timestamp using the appropriate history tables described by the HistoryPolicy set on the Employee descriptor. </para>
   <para>
      <anchor id="Example_107-2"/>Using a Historical Session </para>
   <para>ReadAllQuery historicalQuery = new ReadAllQuery(Employee.class);</para>
   <para>AsOfClause asOfClause = new AsOfClause(timestamp);</para>
   <para>historicalQuery.setAsOfClause(asOfClause);</para>
   <para>historicalQuery.dontMaintainCache();</para>
   <para>List pastEmployees = (List)historicalSession.executeQuery(historicalQuery);</para>
   <para/>
   <para>
      <anchor id="Using_Queries_with_Fetch_Groups"/>Using Queries with Fetch Groups</para>
   <para>You can use a fetch group with a ReadObjectQuery or ReadAllQuery. When you execute the query, EclipseLink retrieves only the attributes in the fetch group. EclipseLink automatically executes a query to fetch all the attributes excluded from this subset when and if you call a getter method on any one of the excluded attributes. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: When you use fetch groups outside of CMP, use weaving (see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Application_Development_%28ELUG%29">Using Weaving</ulink>). </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>This section describes the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Configure_Default_Fetch_Group_Behavior">How to Configure Default Fetch Group Behavior</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Query_with_a_Static_Fetch_Group">How to Query with a Static Fetch Group</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Query_with_a_Dynamic_Fetch_Group">How to Query with a Dynamic Fetch Group</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para>For more information about fetch groups, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29#Fetch_Groups_and_Object-Level_Read_Queries">Fetch Groups and Object-Level Read Queries</ulink>. </para>
   <para/>
   <para>
      <anchor id="How_to_Configure_Default_Fetch_Group_Behavior"/>How to Configure Default Fetch Group Behavior</para>
   <para>You can optionally designate at most one fetch group as the default fetch group for a descriptor's reference class. </para>
   <para>If you execute a ReadObjectQuery or ReadAllQuery without specifying a fetch group, EclipseLink will use the default fetch group unless you configure the query otherwise, as this example shows. </para>
   <para>
      <anchor id="Example_107-3"/>Configuring Default Fetch Group Behavior </para>
   <para>// at the descriptor level</para>
   <para>FetchGroup group = new FetchGroup("nameOnly");</para>
   <para>group.addAttribute("firstName");</para>
   <para>group.addAttribute("lastName");</para>
   <para>employeeDescriptor.getFetchGroupManager().addFetchGroup(group);</para>
   <para>// set the default fetch group</para>
   <para>employeeDescriptor.getFetchGroupManager().setDefaultFetchGroup(group);</para>
   <para/>
   <para>// when query1 is executed, the default fetch group applies</para>
   <para>ReadAllQuery query1 = new ReadAllQuery(Employee.class);</para>
   <para/>
   <para>// when query2 is executed, the default fetch group does not apply</para>
   <para>ReadAllQuery query2 = new ReadAllQuery(Employee.class);</para>
   <para>query2.setShouldUsedefaultFetchGroup(false);</para>
   <para/>
   <para>
      <anchor id="How_to_Query_with_a_Static_Fetch_Group"/>How to Query with a Static Fetch Group</para>
   <para>
      <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#Example_107-4">Configuring a Query with a FetchGroup Using the FetchGroupManager</ulink> shows how to configure a ReadObjectQuery for the Employee class with a FetchGroup named nameOnly previously stored in the FetchGroupManager owned by the Employee class's descriptor. </para>
   <para>
      <anchor id=".27Example_107-4"/>' Configuring a Query with a FetchGroup Using the FetchGroupManager </para>
   <para>In this example, only the Employee attributes firstName and lastName are fetched. If you call the Employee method get for any other attribute, EclipseLink executes another query to retrieve all unfetched attribute values. Thereafter, calling that get method will return the value directly from the object. </para>
   <para/>
   <para>// create static fetch group at the descriptor level</para>
   <para>FetchGroup group = new FetchGroup("nameOnly");</para>
   <para>group.addAttribute("firstName");</para>
   <para>group.addAttribute("lastName");</para>
   <para>descriptor.getFetchGroupManager().addFetchGroup(group);</para>
   <para/>
   <para>// use static fetch group at query level</para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.setFetchGroupName("nameOnly");</para>
   <para/>
   <para>
      <anchor id="How_to_Query_with_a_Dynamic_Fetch_Group"/>How to Query with a Dynamic Fetch Group</para>
   <para>
      <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#Example_107-5">Configuring a Query with a FetchGroup Dynamically</ulink> shows how to create a FetchGroup instance dynamically, at the time you create and execute a query, and configure the query with that FetchGroup directly. </para>
   <para>In this example, only the firstName, lastName, and salary attributes are fetched. If you call the Employee method get for any other attribute, EclipseLink executes another query to retrieve all unfetched attribute values. Thereafter, calling that get method will return the value directly from the object. </para>
   <para>
      <anchor id="Example_107-5"/>Configuring a Query with a FetchGroup Dynamically </para>
   <para/>
   <para>// dynamic fetch group query</para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>FetchGroup group = new FetchGroup("nameAndSalary");</para>
   <para>group.addAttribute("firstName");</para>
   <para>group.addAttribute("lastName");</para>
   <para>group.addAttribute("salary");</para>
   <para>query. setFetchGroup(group);</para>
   <para>
      <anchor id="Using_Read-Only_Queries"/>Using Read-Only Queries</para>
   <para>This example shows how to create an object-level read query to return data that you know is read-only. Using such a query for read-only data can improve performance. </para>
   <para>
      <anchor id="Example_107-6"/>Configuring an ObjectLevelReadQuery as Read-Only </para>
   <para/>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.setIsReadOnly(true);</para>
   <para>For more information, see the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Read-Only Query</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29">How to Use Read-Only Queries for Optimization</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Querying_on_Interfaces"/>Querying on Interfaces</para>
   <para>When you define descriptors for an interface to enable querying, EclipseLink supports querying on an interface, as follows: </para>
   <orderedlist>
      <listitem>
         <para>If there is only a single implementor of the interface, the query returns an instance of the concrete class. </para>
      </listitem>
      <listitem>
         <para>If there are multiple implementors of the interfaces, the query returns instances of all implementing classes. </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Querying_on_an_Inheritance_Hierarchy"/>Querying on an Inheritance Hierarchy</para>
   <para>When you query on a class that is part of an inheritance hierarchy, the session checks the descriptor to determine the type of the class, as follows: </para>
   <orderedlist>
      <listitem>
         <para>If you configure the descriptor to read subclasses (the default configuration), the query returns instances of the class and its subclasses. </para>
      </listitem>
      <listitem>
         <para>If you configure the descriptor not to read subclasses, the query returns only instances of the queried class, but no instances of the subclasses. </para>
      </listitem>
      <listitem>
         <para>If you configure the descriptor to outer-join subclasses, the query returns instances of the class and its subclasses. </para>
      </listitem>
      <listitem>
         <para>If neither of these conditions applies, the class is a leaf class and does not have any subclasses. The query returns instances of the queried class. </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Appending_Additional_Join_Expressions"/>Appending Additional Join Expressions</para>
   <para>You can set the query manager to automatically append an expression to every query it performs on a class. For example, you can add an expression that filters the database for the valid instances of a given class. </para>
   <para>Use this to do the following: </para>
   <orderedlist>
      <listitem>
         <para>Filter logically deleted objects </para>
      </listitem>
      <listitem>
         <para>Enable two independent classes to share a single table without inheritance </para>
      </listitem>
      <listitem>
         <para>Filter historical versions of objects </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="How_to_Append_Additional_Join_Expressions_Using_Java"/>How to Append Additional Join Expressions Using Java</para>
   <para>Using Java, configure a descriptor with additional join expressions by creating an amendment method (see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Amendment Methods</ulink>), and then using the DescriptorQueryManager methods setAdditionalJoinExpression or setMultipleTableJoinExpression, as this example shows. </para>
   <para>
      <anchor id="Example_107-7"/>Registering a Query That Includes a Join Expression </para>
   <para>In this exmaple, the join expression filters invalid instances of employee from the query. </para>
   <para/>
   <para>public static void addToDescriptor(Descriptor descriptor) {</para>
   <para>    ExpressionBuilder builder = new ExpressionBuilder();</para>
   <para>    descriptor.getQueryManager().setAdditionalJoinExpression(</para>
   <para>        (builder.getField("EMP.STATUS").notEqual("DELETED")).and(</para>
   <para>             builder.getField("EMP.STATUS").notEqual("HISTORICAL"))</para>
   <para>    );</para>
   <para>}</para>
   <para/>
   <para>
      <anchor id="Using_Queries_on_Variable_One-to-One_Mappings"/>Using Queries on Variable One-to-One Mappings</para>
   <para>EclipseLink does not provide a method to directly query against variable one-to-one mappings. To query against this type of mapping, combine EclipseLink DirectQueryKeys and EclipseLink ReportQueries to create query selection criteria for classes that implement the interface, as follows: </para>
   <orderedlist>
      <listitem>
         <para>Create two DirectQueryKeys to query for the possible implementors of the interface: </para>
      </listitem>
      <listitem>
         <para>Create a subSelect statement for each concrete class that implements the interface included in the query selection criteria. </para>
      </listitem>
      <listitem>
         <para>Implement a ReportQuery. </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_107-8"/>Creating DirectQueryKeys </para>
   <para>// The DirectQueryKeys as generated in the EclipseLink project Java </para>
   <para>// source code from Workbench </para>
   <para>…</para>
   <para>descriptor.addDirectQueryKey("locationTypeCode","DEALLOCATION.DEALLOCATIONOBJECTTYPE");</para>
   <para>descriptor.addDirectQueryKey("locationTypeId","DEALLOCATION.DEALLOCATIONOBJECTID");     </para>
   <para/>
   <para>
      <anchor id="Using_Oracle_Database_Features"/>Using Oracle Database Features</para>
   <para>If you are using Oracle Database, you can take advantage of EclipseLink support for the following Oracle Database features: </para>
   <orderedlist>
      <listitem>
         <para>Oracle Hints (see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Use_Oracle_Hints">How to Use Oracle Hints</ulink>) </para>
      </listitem>
      <listitem>
         <para>Hierarchical Queries (see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Use_Hierarchical_Queries">How to Use Hierarchical Queries</ulink>) </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="How_to_Use_Oracle_Hints"/>How to Use Oracle Hints</para>
   <para>Oracle Hints is an Oracle Database feature through which you can make decisions usually reserved for the optimizer. You use hints to specify things such as join order for a join statement, or the optimization approach of an SQL call. </para>
   <para>The EclipseLink query framework supports Oracle Hints with the following API: </para>
   <para>setHintString("/*[hints or comments]*/");</para>
   <para> </para>
   <para>EclipseLink adds the hint to the SQL string as a comment immediately following a SELECT, UPDATE, INSERT, or DELETE statement. </para>
   <para>Add hints to a read query as follows: </para>
   <orderedlist>
      <listitem>
         <para>Create a ReadObjectQuery or a ReadAllQuery </para>
      </listitem>
      <listitem>
         <para>Set the selection criteria. </para>
      </listitem>
      <listitem>
         <para>Add hints as needed. </para>
      </listitem>
   </orderedlist>
   <para>For example, the following code uses the FULL hint (which explicitly chooses a full table scan for the specified table): </para>
   <para/>
   <para>// Create the query and set Employee as its reference class</para>
   <para>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</para>
   <para>// Retrieve ExpressionBuilder from the query</para>
   <para>ExpressionBuilder builder = query.getExpressionBuilder();</para>
   <para>query.setSelectionCritera(builder.get("id").equal(new Integer(1));</para>
   <para>// Add the hint</para>
   <para>query.setHintString("/*+ FULL */" ); </para>
   <para/>
   <para>This code generates the following SQL: </para>
   <para>SELECT /*+ FULL */ FROM EMPLOYEE WHERE ID=1</para>
   <para>To add hints to WRITE, INSERT, UPDATE, and DELETE, create custom queries for these operations in the EclipseLink query framework, then specify hints as required. For more information, see the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Configuring_a_Relational_Descriptor_%28ELUG%29">Configuring Custom SQL Queries for Basic Persistence Operations</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Configuring_an_EIS_Descriptor_%28ELUG%29">Configuring Custom EIS Interactions for Basic Persistence Operations</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para>For more information about the available hints, see the Oracle Database documentation. </para>
   <para/>
   <para>
      <anchor id="How_to_Use_Hierarchical_Queries"/>How to Use Hierarchical Queries</para>
   <para>Hierarchical Queries is an Oracle Database mechanism that lets you select database rows based on hierarchical order. For example, you can design a query that reads the row of a given employee, followed by the rows of people this employee manages, followed by their managed employees, and so on. </para>
   <para>To create a hierarchical query, use the setHierarchicalQueryClause method. This method takes three parameters, as follows: </para>
   <para/>
   <para>setHierarchicalQueryClause(startWith, connectBy, orderSibling)</para>
   <para>This expression requires all three parameters, as described in the subsequent text. </para>
   <para/>
   <para>
      <anchor id="Using_startWith_Parameter"/>Using startWith Parameter</para>
   <para>The startWith parameter in the expression specifies the first object in the hierarchy. This parameter mirrors the Oracle Database START WITH clause. </para>
   <para>To include a startWith parameter, build an expression to specify the appropriate object, and pass it as a parameter in the setHierarchicalQueryClause method. If you do not specify the root object for the hierarchy, set this value to null. </para>
   <para/>
   <para>
      <anchor id="Using_connectBy_Parameter"/>Using connectBy Parameter</para>
   <para>The connectBy parameter specifies the relationship that creates the hierarchy. This parameter mirrors the Oracle Database CONNECT BY clause. </para>
   <para>Build an expression to specify the connectBy parameter, and pass it as a parameter in the setHierarchicalQueryClause method. Because this parameter defines the nature of the hierarchy, it is required for the setHierarchicalQueryClause implementation. </para>
   <para/>
   <para>
      <anchor id="Using_orderSibling_Parameter"/>Using orderSibling Parameter</para>
   <para>The orderSibling parameter in the expression specifies the order in which the query returns sibling objects in the hierarchy. This parameter mirrors the Oracle Database ORDER SIBLINGS clause. </para>
   <para>To include an orderSibling parameter, define a vector, and to include the order criteria, use the addElement method. Pass the vector as the third parameter in the setHierarchicalQueryClause method. If you do not specify an order, set this value to null. </para>
   <para>
      <anchor id="Example_107-9"/>Hierarchical Query </para>
   <para>ReadAllQuery raq = new ReadAllQuery(Employee.class);</para>
   <para>// Specifies a START WITH expression</para>
   <para>Expression startExpr = expressionBuilder.get("id").equal(new Integer(1));</para>
   <para>// Specifies a CONNECT BY expression</para>
   <para>Expression connectBy = expressionBuilder.get("managedEmployees");</para>
   <para>// Specifies an ORDER SIBLINGS BY vector</para>
   <para>Vector order = new Vector();</para>
   <para>order.addElement(expressionBuilder.get("lastName"));</para>
   <para>order.addElement(expressionBuilder.get("firstName"));</para>
   <para>raq.setHierarchicalQueryClause(startExpr, connectBy, order);</para>
   <para>Vector employees = uow.executeQuery(raq);</para>
   <para>This code generates the following SQL: </para>
   <para>SELECT * FROM EMPLOYEE START WITH ID=1 CONNECT BY PRIOR ID=MANAGER_ID ORDER SIBLINGS BY LAST_NAME, FIRST_NAME</para>
   <para/>
   <para>
      <anchor id="Handling_Cursor_and_Stream_Query_Results"/>Handling Cursor and Stream Query Results</para>
   <para>Cursors and streams are related mechanisms that let you work with large result sets efficiently. See <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29#Stream_and_Cursor_Query_Results">Stream and Cursor Query Results</ulink> for more information. </para>
   <para>
      <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#Table_107-1">Stream and Cursor Query Result Options</ulink> table lists the methods that EclipseLink provides for all subclasses of DataReadQuery and ReadAllQuery that you can use to make your query return its results as a cursor or stream. </para>
   <para>
      <anchor id="Table_107-1"/>Stream and Cursor Query Result Options </para>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>
                  <anchor id="r1c1-t3"/>Method <anchor id="r1c2-t3"/>
               </para>
            </entry>
            <entry>
               <para>Query Returns <anchor id="r1c3-t3"/>
               </para>
            </entry>
            <entry>
               <para>Description <anchor id="r2c1-t3"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>useScrollableCursor </para>
            </entry>
            <entry>
               <para>ScrollableCursor </para>
            </entry>
            <entry>
               <para>Allows you access a database result set cursor, allowing you to move forward and backward through the result set. <anchor id="r3c1-t3"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>useCursoredStream </para>
            </entry>
            <entry>
               <para>CursoredStream </para>
            </entry>
            <entry>
               <para>Allows you to access results one at a time in sequence, as results become available to the underlying database result set cursor. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Using a ScrollableCursor or CursoredStream combines the features of an EclipseLink with the ability of the database to cursor data, and breaks up the result set into smaller, more manageable pieces. </para>
   <para>The behavior of a query that uses a ScrollableCursor or CursoredStream differs from other queries in that the elements requested by the client are sent to the client. </para>
   <para>This section describes the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Handle_Cursors_and_Java_Iterators">How to Handle Cursors and Java Iterators</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Handle_Java_Streams">How to Handle Java Streams</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Optimize_Streams">How to Optimize Streams</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="How_to_Handle_Cursors_and_Java_Iterators"/>How to Handle Cursors and Java Iterators</para>
   <para>The EclipseLink scrollable cursor lets you scroll through a result set from the database without reading the whole result set in a single database read operation. The ScrollableCursor class implements the Java ListIterator interface to allow for direct and relative access within the stream. Scrollable cursors also let you scroll forward and backward through the stream. </para>
   <para/>
   <para>
      <anchor id="Traversing_Data_with_Scrollable_Cursors"/>Traversing Data with Scrollable Cursors</para>
   <para>The following methods let you navigate data with a scrollable cursor: </para>
   <orderedlist>
      <listitem>
         <para>relative(int i): advances the row number in relation to the current row by one row </para>
      </listitem>
      <listitem>
         <para>absolute(int i): places the cursor at an absolute row position, 1 being the first row </para>
      </listitem>
   </orderedlist>
   <para>Several strategies are available for traversing data with cursors. For example, to start at the end of the data set and work toward the first record, do the following: </para>
   <orderedlist>
      <listitem>
         <para>Call the afterLast method to place the cursor after the last row in the result set. </para>
      </listitem>
      <listitem>
         <para>Use the hasPrevious method to determine whether there is a record above the current record. This method returns false when you reach the final record in the data set. </para>
      </listitem>
      <listitem>
         <para>If the hasPrevious method returns true, call the previous method to move the cursor to the row prior to the current row and read that object. </para>
      </listitem>
   </orderedlist>
   <para>These are common methods for data traversal, but they are not the only available methods. For more information about the available methods, see EclipseLink API Reference. </para>
   <para>To use the ScrollableCursor object, the JDBC driver must be compatible with the JDBC 2.0 specifications. </para>
   <para>
      <anchor id="_107-10"/>Example Traversing with a Scrollable Cursor </para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.useScrollableCursor();</para>
   <para>ScrollableCursor cursor = (ScrollableCursor) session.executeQuery(query);</para>
   <para/>
   <para>while (cursor.hasNext()) {</para>
   <para>    System.out.println(cursor.next().toString());</para>
   <para>}</para>
   <para>cursor.close();</para>
   <para/>
   <para>
      <anchor id="How_to_Handle_Java_Streams"/>How to Handle Java Streams</para>
   <para>Java streams let you retrieve query results as individual records or groups of records, which can result in a performance increase. You can use streams to build efficient EclipseLink queries, especially when the queries are likely to generate large result sets. </para>
   <para/>
   <para>
      <anchor id="Using_Cursored_Stream_Support"/>Using Cursored Stream Support</para>
   <para>Cursored streams provide the ability to read back a query result set from the database in manageable subsets, and to scroll through the result set stream. </para>
   <para>The useCursoredStream method of the ReadAllQuery class provides cursored stream support. </para>
   <para>
      <anchor id="Example_107-11"/>Cursored Streams </para>
   <para>CursoredStream stream;</para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.useCursoredStream();</para>
   <para>stream = (CursoredStream) session.executeQuery(query);</para>
   <para>The query returns an instance of CursoredStream rather than a List, which can be a more efficient approach. For example, consider the following two code examples. The <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#Example_107-12">Using a List</ulink> example returns a List that contains all employee objects. If ACME has 10,000 employees, the List contains references to 10,000 Employee objects. </para>
   <para>
      <anchor id="Example_107-12"/>Using a List </para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>Enumeration employeeEnumeration;</para>
   <para/>
   <para>List employees = (List) session.executeQuery(query);</para>
   <para>employeeEnumeration = employee.elements();</para>
   <para/>
   <para>while (employeeEnumeration.hasMoreElements()) {</para>
   <para>    Employee employee = (Employee) employeeEnumeration.nextElement();</para>
   <para>    employee.doSomeWork();</para>
   <para>}</para>
   <para>The following example returns a CursoredStream instance rather than a List. The CursoredStream collection appears to contain all 10,000 objects, but initially contains a reference to only the first 10 Employee objects. It retrieves the remaining objects in the collection as they are needed. In many cases, the application never needs to read all the objects: </para>
   <para/>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.useCursoredStream();</para>
   <para/>
   <para>CursoredStream stream = (CursoredStream) session.executeQuery(query);</para>
   <para>while (! stream.atEnd()) {</para>
   <para>    Employee employee = (Employee) stream.read();</para>
   <para>    employee.doSomeWork();</para>
   <para>    stream.releasePrevious();</para>
   <para>}</para>
   <para>stream.close();</para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: The releasePrevious message is optional. This releases any previously read objects and frees system memory. Even though released objects are removed from the cursored stream storage, they may remain in the identity map. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>
      <anchor id="How_to_Optimize_Streams"/>How to Optimize Streams</para>
   <para>To optimize CursoredStream performance, provide a threshold and page size to the useCursoredStream(Threshold, PageSize) method, as follows: </para>
   <orderedlist>
      <listitem>
         <para>The threshold specifies the number of objects to read into the stream initially. The default threshold is 10. </para>
      </listitem>
      <listitem>
         <para>The page size specifies the number of objects to read into the stream after the initial group of objects. This occurs after the threshold number of objects is read. Although larger page sizes result in faster overall performance, they introduce delays into the application when EclipseLink loads each page. The default page size is 5. </para>
      </listitem>
   </orderedlist>
   <para>When you execute a batch-type operation, use the dontMaintainCache method with a cursored stream. A batch operation performs simple operations on large numbers of objects and then discards the objects. Cursored streams create the required objects only as needed, and the dontMaintainCache ensures that these transient objects are not cached. </para>
   <para/>
   <para>
      <anchor id="Handling_Query_Results_Using_Pagination"/>Handling Query Results Using Pagination</para>
   <para>You can configure a query to retrieve a result set in pages, that is, a partial result as a List of pageSize (or less) results. The following example demonstrates paging through the result set of a query using ReadQuery methods setMaxRows and setFirstResult. </para>
   <para>For more information, see the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29#How_to_Use_Result_Set_Pagination_for_Optimization">How to Use Result Set Pagination for Optimization</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29#How_to_Use_JDBC_Fetch_Size_for_Optimization">How to Use JDBC Fetch Size for Optimization</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_107-13"/>Using setMaxRows and setFirstResult to Page Through a Result Set </para>
   <para>...</para>
   <para>int pageSize = 100;</para>
   <para>int firstResult = 0;</para>
   <para>int maxRows = pageSize;</para>
   <para>boolean hasNext = true;</para>
   <para>List page = null;</para>
   <para/>
   <para>while (hasNext) {</para>
   <para>    query.setFirstResult(firstResult);</para>
   <para>    query.setMaxRows(maxRows);</para>
   <para>    page = (List)sesssion.executeQuery(query);</para>
   <para>    // process this page of results</para>
   <para>    if (page.size() == 0) {</para>
   <para>        hasNext = false;</para>
   <para>    } else {</para>
   <para>        firstResult = firstResult + pageSize;</para>
   <para>        maxRows = maxRows + pageSize;</para>
   <para>    }</para>
   <para>}</para>
   <para>...</para>
   <para>
      <anchor id="Using_Queries_and_the_Cache"/>Using Queries and the Cache</para>
   <para>This section describes how to use caching options in EclipseLink queries, including the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Cache_Results_in_a_ReadQuery">How to Cache Results in a ReadQuery</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Configure_Cache_Expiration_at_the_Query_Level">How to Configure Cache Expiration at the Query Level</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="How_to_Cache_Results_in_a_ReadQuery"/>How to Cache Results in a ReadQuery</para>
   <para>By default, each time you execute a ReadQuery, EclipseLink applies the current query configuration to the read operation. In doing so, EclipseLink will access the session cache, the data source, or both. </para>
   <para>Some queries are known to return the same result set (for example, the number of units sold last year by the current sales person). After the first query execution, there is no need to actually execute the query if it is invoked again. </para>
   <para>For these types of queries, you can use any EclipseLink ReadQuery and configure it to store its query results in an internal query cache. </para>
   <para>After its first execution for a set of query parameters, the query will return its cached result set each time it is invoked with the same query parameters. This improves query performance for frequently executed queries. By default a query will cache the results sets for the last 100 queries of specific parameters. You can configure this query cache as part of the QueryResultsCachePolicy. </para>
   <para>Enable this feature using ReadQuery method cacheQueryResults or by calling the ReadQuery method setQueryResultsCachePolicy with an instance of QueryResultsCachePolicy, and disable it using ReadQuery method doNotCacheQueryResults. </para>
   <para>Before using this feature, consider the restrictions in <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Internal Query Cache Restrictions</ulink>. For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">How to Cache Query Results in the Query Cache</ulink>. </para>
   <para>You can apply a cache invalidation policy to the query's internal cache (see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Configure_Cache_Expiration_at_the_Query_Level">How to Configure Cache Expiration at the Query Level</ulink>). For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_Cache_%28ELUG%29#Cache_Invalidation">Cache Invalidation</ulink>. </para>
   <para>This example shows how to configure a ReadQuery to cache its results. </para>
   <para>
      <anchor id="Example_107-14"/>Configuring a ReadQuery to Cache Its Query Results </para>
   <para>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</para>
   <para/>
   <para>// Instruct the ReadQuery to cache its query results</para>
   <para>query.cacheQueryResults();</para>
   <para/>
   <para>// The first time you invoke it, the ReadQuery reads from the database, session </para>
   <para>// cache, or both and stores the result set in its internal query cache</para>
   <para>Employee employeeFirst = (Employee) session.executeQuery(query);</para>
   <para>The following example shows how to configure the ReadQuery to stop caching its results. The next time the query is executed, EclipseLink does not use the query cache. Instead, the query accesses the data source. </para>
   <para>
      <anchor id="Example_107-15"/>Configuring a ReadQuery to Stop Caching Its Query Results </para>
   <para>// Disable query caching</para>
   <para>query.doNotCacheQueryResults();</para>
   <para/>
   <para>// The ReadQuery does not use the query cahce and instead accesses the database</para>
   <para>Employee employee = (Employee) session.executeQuery(query);</para>
   <para>Alternatively, you can clear the query's internal cache using ReadQuery method clearQueryResults passing in your session. This clears the currently cached results and ensures that the next query execution reads from the database. </para>
   <para/>
   <para>
      <anchor id="How_to_Configure_Cache_Expiration_at_the_Query_Level"/>How to Configure Cache Expiration at the Query Level</para>
   <para>You can configure a ReadQuery with a CacheInvalidationPolicy. </para>
   <para>If you configure a query to cache results in its own internal cache (see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Cache_Results_in_a_ReadQuery">How to Cache Results in a ReadQuery</ulink>), the cache invalidation policy allows the cached query result set to expire, based on a time-to-live or daily-expiry. This invalidation time is calculated from the time of the query execution that cached the query result set for the specific set of query parameters. </para>
   <para>The following example shows how to configure a ReadQuery so that a TimeToLiveCacheInvalidationPolicy is applied to all the objects returned by the query and cached in the query's internal cache. </para>
   <para>
      <anchor id="Example_107-16"/>Configuring a CacheInvalidationPolicy on a ReadQuery for the Query's Internal Cache </para>
   <para>// The TimeToLiveCacheInvalidationPolicy applies to all objects returned by the query and</para>
   <para>// cached in the query's internal cache </para>
   <para/>
   <para>readQuery.setQueryResultsCachePolicy(</para>
   <para>    new QueryResultsCachePolicy(new TimeToLiveCacheInvalidationPolicy(1000))</para>
   <para>);</para>
   <para/></sect1></sect1><sect1><title>For more information, see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29">Using Advanced Query API</ulink>. </title>
   <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29">Using Advanced Query API</ulink></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Using_Session_Queries"/>Using Session Queries</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note We recommend that you perform all data source operations using a unit of work: doing so is the most efficient way to manage transactions, concurrency, and referential constraints. For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Transactions_%28ELUG%29">Introduction to EclipseLink Transactions</ulink>. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></sect1><sect1><title>For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29#Session_Queries">Session Queries</ulink>. </title>
   <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29#Session_Queries">Session Queries</ulink></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="How_to_Read_Objects_with_a_Session_Query"/>How to Read Objects with a Session Query</title></sect1><sect1><title>Using the session query API, you can perform the following read operations: </title>
   <orderedlist>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_an_Object_with_a_Session_Query">Reading an Object with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_All_Objects_with_a_Session_Query">Reading All Objects with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Refreshing_an_Object_with_a_Session_Query">Refreshing an Object with a Session Query</ulink> 
         </title>
      </listitem>
   </orderedlist></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_an_Object_with_a_Session_Query">Reading an Object with a Session Query</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_an_Object_with_a_Session_Query">Reading an Object with a Session Query</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_All_Objects_with_a_Session_Query">Reading All Objects with a Session Query</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_All_Objects_with_a_Session_Query">Reading All Objects with a Session Query</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_All_Objects_with_a_Session_Query">Reading All Objects with a Session Query</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Refreshing_an_Object_with_a_Session_Query">Refreshing an Object with a Session Query</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Refreshing_an_Object_with_a_Session_Query">Refreshing an Object with a Session Query</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Refreshing_an_Object_with_a_Session_Query">Refreshing an Object with a Session Query</ulink></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Reading_an_Object_with_a_Session_Query"/>Reading an Object with a Session Query</title></sect1><sect1><title>The readObject method retrieves a single object from the database. The application must specify the class of object to read. If no object matches the criteria, a null value is returned. </title>readObject</sect1><sect1><title>For example, the basic read operation is: </title></sect1><sect1><title>session.readObject(MyDomainObject.class);</title></sect1><sect1><title>The following example returns the first instance of MyDomainObject found in the table used for MyDomainObject. EclipseLink provides the Expression class to specify querying parameters for a specific object. </title>MyDomainObjectMyDomainObjectExpression</sect1><sect1><title>When you search for a single, specific object using a primary key, the readObject method is more efficient than the readAllObjects method, because readObject can find an instance in the cache without accessing database. Because a readAllObjects method does not know how many objects match the criteria, it always searches the database to find matching objects, even if it finds matching objects in the cache. </title>readObjectreadAllObjectsreadObjectreadAllObjects</sect1><sect1><title>
      <anchor id="Example_105-1"/>readObject Using an Expression </title>readObject Using an Expression</sect1><sect1><title>import org.eclipse.persistence.sessions.*;</title></sect1><sect1><title>import org.eclipse.persistence.expressions.*;</title></sect1><sect1><title>...</title></sect1><sect1><title/></sect1><sect1><title>// Use an expression to read in the employee whose last name is Smith.</title></sect1><sect1><title>// Create an expression using the Expression Builder and use it as the selection criterion of the search </title></sect1><sect1><title>Employee employee = (Employee) session.readObject(Employee.class, new ExpressionBuilder().get("lastName").equal("Smith"));</title></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Reading_All_Objects_with_a_Session_Query"/>Reading All Objects with a Session Query</title></sect1><sect1><title>The readAllObjects method retrieves a List of objects from the database and does not put the returned objects in order. If the query does not find any matching objects, it returns an empty List. </title>readAllObjectsListList</sect1><sect1><title>Specify the class for the query. You can also include an expression to define more complex search criteria, as illustrated in the following example. </title></sect1><sect1><title>
      <anchor id="Example_105-2"/>readAllObjects Using an Expression </title>readAllObjects Using an Expression</sect1><sect1><title>// Returns a List of employees whose employee salary is greater than 10000</title></sect1><sect1><title>List employees = session.readAllObjects(Employee.class,new ExpressionBuilder.get("salary").greaterThan(10000));</title></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Refreshing_an_Object_with_a_Session_Query"/>Refreshing an Object with a Session Query</title></sect1><sect1><title>The refreshObject method causes EclipseLink to update the object in memory using data from the database. This operation refreshes any privately owned objects as well. </title>refreshObject<informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: A privately owned object is one that cannot exist without its parent, or source object. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="How_to_Create.2C_Update.2C_and_Delete_Objects_with_a_Session_Query"/>How to Create, Update, and Delete Objects with a Session Query</title></sect1><sect1><title>Using the session query API, you can perform the following create, update, and delete operations: </title>
   <orderedlist>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Writing_a_Single_Object_to_the_Database_with_a_Session_Query">Writing a Single Object to the Database with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Writing_All_Objects_to_the_Database_with_a_Session_Query">Writing All Objects to the Database with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Adding_New_Objects_to_the_Database_with_a_Session_Query">Adding New Objects to the Database with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Modifying_Existing_Objects_in_the_Database_with_a_Session_Query">Modifying Existing Objects in the Database with a Session Query</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Deleting_Objects_in_the_Database_with_a_Session_Query">Deleting Objects in the Database with a Session Query</ulink> 
         </title>
      </listitem>
   </orderedlist></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Writing_a_Single_Object_to_the_Database_with_a_Session_Query">Writing a Single Object to the Database with a Session Query</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Writing_a_Single_Object_to_the_Database_with_a_Session_Query">Writing a Single Object to the Database with a Session Query</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Writing_All_Objects_to_the_Database_with_a_Session_Query">Writing All Objects to the Database with a Session Query</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Writing_All_Objects_to_the_Database_with_a_Session_Query">Writing All Objects to the Database with a Session Query</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Writing_All_Objects_to_the_Database_with_a_Session_Query">Writing All Objects to the Database with a Session Query</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Adding_New_Objects_to_the_Database_with_a_Session_Query">Adding New Objects to the Database with a Session Query</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Adding_New_Objects_to_the_Database_with_a_Session_Query">Adding New Objects to the Database with a Session Query</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Adding_New_Objects_to_the_Database_with_a_Session_Query">Adding New Objects to the Database with a Session Query</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Modifying_Existing_Objects_in_the_Database_with_a_Session_Query">Modifying Existing Objects in the Database with a Session Query</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Modifying_Existing_Objects_in_the_Database_with_a_Session_Query">Modifying Existing Objects in the Database with a Session Query</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Modifying_Existing_Objects_in_the_Database_with_a_Session_Query">Modifying Existing Objects in the Database with a Session Query</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Deleting_Objects_in_the_Database_with_a_Session_Query">Deleting Objects in the Database with a Session Query</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Deleting_Objects_in_the_Database_with_a_Session_Query">Deleting Objects in the Database with a Session Query</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Deleting_Objects_in_the_Database_with_a_Session_Query">Deleting Objects in the Database with a Session Query</ulink></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Writing_a_Single_Object_to_the_Database_with_a_Session_Query"/>Writing a Single Object to the Database with a Session Query</title></sect1><sect1><title>When you invoke the writeObject method, the method performs a does-exist check to determine whether or not an object exists. If the object exists, writeObject updates the object; if it does not exist, writeObject inserts a new object. </title>writeObjectdoes-existwriteObjectwriteObject</sect1><sect1><title>The writeObject method writes privately owned objects in the correct order to maintain referential integrity. </title>writeObject</sect1><sect1><title>Call the writeObject method when you cannot verify that an object exists in the database. </title>writeObject</sect1><sect1><title>
      <anchor id="Example_105-3"/>Writing a Single Object Using writeObject </title>Writing a Single Object Using writeObject</sect1><sect1><title>// Create an instance of the employee and write it to the database</title></sect1><sect1><title>Employee susan = new Employee();</title></sect1><sect1><title>susan.setName("Susan");</title></sect1><sect1><title>...</title></sect1><sect1><title>// Initialize the susan object with all other instance variables</title></sect1><sect1><title>session.writeObject(susan); </title></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Writing_All_Objects_to_the_Database_with_a_Session_Query"/>Writing All Objects to the Database with a Session Query</title></sect1><sect1><title>You can call the writeAllObjects method to write multiple objects to the database. The writeAllObjects method performs the same does-exist check as the writeObject method and then performs the appropriate insert or update operations. </title>writeAllObjectswriteAllObjectsdoes-existwriteObject</sect1><sect1><title>'Writing Several Objects Using writeAllObjects </title>Writing Several Objects Using writeAllObjects</sect1><sect1><title>// Read a List of all the current employees in the database.</title></sect1><sect1><title>List employees = session.readAllObjects(Employee.class);</title></sect1><sect1><title/></sect1><sect1><title>// Modify any employee data as necessary</title></sect1><sect1><title>...</title></sect1><sect1><title/></sect1><sect1><title>// Create a new employee and add it to the list of employees</title></sect1><sect1><title>Employee susan = new Employee();</title></sect1><sect1><title>...</title></sect1><sect1><title>// Initialize the new instance of employee</title></sect1><sect1><title>employees.add(susan);</title></sect1><sect1><title>// Write all employees to the database. </title>// Write all employees to the database.</sect1><sect1><title>// The new instance of susan not currently in the database will be inserted. </title>// The new instance of susan not currently in the database will be inserted.</sect1><sect1><title>// All the other employees currently stored in the database will be updated</title></sect1><sect1><title>session.writeAllObjects(employees);</title></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Adding_New_Objects_to_the_Database_with_a_Session_Query"/>Adding New Objects to the Database with a Session Query</title></sect1><sect1><title>The insertObject method creates a new object in the database, but does not perform the does-exist check before it attempts the insert operation. The insertObject method is more efficient than the writeObject method if you are certain that the object does not yet exist in the database. If the object does exist, the database throws an exception when you execute the insertObject method. </title>insertObjectdoes-existinsertObjectwriteObjectinsertObject</sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Modifying_Existing_Objects_in_the_Database_with_a_Session_Query"/>Modifying Existing Objects in the Database with a Session Query</title></sect1><sect1><title>The updateObject method updates existing objects in the database, but does not perform the does-exist check before it attempts the update operation. The updateObject is more efficient than the writeObject method if you are certain that the object does exist in the database. If the object does not exist, the database throws an exception when you execute the updateObject method. </title>updateObjectdoes-existupdateObjectwriteObjectupdateObject</sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Deleting_Objects_in_the_Database_with_a_Session_Query"/>Deleting Objects in the Database with a Session Query</title></sect1><sect1><title>To delete an EclipseLink object from the database, read the object from the database and then call the deleteObject method. This method deletes both the specified object and any privately owned data. </title>deleteObject</sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Using_DatabaseQuery_Queries"/>Using DatabaseQuery Queries</title></sect1><sect1><title>This section describes creating and executing DatabaseQuery queries to perform a variety of basic persistence operations, showing how to do the following: </title>DatabaseQuery<orderedlist>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Read_Objects_Using_a_DatabaseQuery">How to Read Objects Using a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Create.2C_Update.2C_and_Delete_Objects_with_a_DatabaseQuery">How to Create, Update, and Delete Objects with a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Update_and_Delete_Multiple_Objects_with_a_DatabaseQuery">How to Update and Delete Multiple Objects with a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Read_Data_with_a_DatabaseQuery">How to Read Data with a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Update_Data_with_a_DatabaseQuery">How to Update Data with a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_SQL_String_in_a_DatabaseQuery">How to Specify a Custom SQL String in a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_JPQL_String_in_a_DatabaseQuery">How to Specify a Custom JPQL String in a DatabaseQuery</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Use_Parameterized_SQL_and_Statement_Caching_in_a_DatabaseQuery">How to Use Parameterized SQL and Statement Caching in a DatabaseQuery</ulink> 
         </title>
      </listitem>
   </orderedlist></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Read_Objects_Using_a_DatabaseQuery">How to Read Objects Using a DatabaseQuery</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Read_Objects_Using_a_DatabaseQuery">How to Read Objects Using a DatabaseQuery</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Create.2C_Update.2C_and_Delete_Objects_with_a_DatabaseQuery">How to Create, Update, and Delete Objects with a DatabaseQuery</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Create.2C_Update.2C_and_Delete_Objects_with_a_DatabaseQuery">How to Create, Update, and Delete Objects with a DatabaseQuery</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Create.2C_Update.2C_and_Delete_Objects_with_a_DatabaseQuery">How to Create, Update, and Delete Objects with a DatabaseQuery</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Update_and_Delete_Multiple_Objects_with_a_DatabaseQuery">How to Update and Delete Multiple Objects with a DatabaseQuery</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Update_and_Delete_Multiple_Objects_with_a_DatabaseQuery">How to Update and Delete Multiple Objects with a DatabaseQuery</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Update_and_Delete_Multiple_Objects_with_a_DatabaseQuery">How to Update and Delete Multiple Objects with a DatabaseQuery</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Read_Data_with_a_DatabaseQuery">How to Read Data with a DatabaseQuery</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Read_Data_with_a_DatabaseQuery">How to Read Data with a DatabaseQuery</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Read_Data_with_a_DatabaseQuery">How to Read Data with a DatabaseQuery</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Update_Data_with_a_DatabaseQuery">How to Update Data with a DatabaseQuery</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Update_Data_with_a_DatabaseQuery">How to Update Data with a DatabaseQuery</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Update_Data_with_a_DatabaseQuery">How to Update Data with a DatabaseQuery</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_SQL_String_in_a_DatabaseQuery">How to Specify a Custom SQL String in a DatabaseQuery</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_SQL_String_in_a_DatabaseQuery">How to Specify a Custom SQL String in a DatabaseQuery</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_SQL_String_in_a_DatabaseQuery">How to Specify a Custom SQL String in a DatabaseQuery</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_JPQL_String_in_a_DatabaseQuery">How to Specify a Custom JPQL String in a DatabaseQuery</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_JPQL_String_in_a_DatabaseQuery">How to Specify a Custom JPQL String in a DatabaseQuery</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_JPQL_String_in_a_DatabaseQuery">How to Specify a Custom JPQL String in a DatabaseQuery</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Use_Parameterized_SQL_and_Statement_Caching_in_a_DatabaseQuery">How to Use Parameterized SQL and Statement Caching in a DatabaseQuery</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Use_Parameterized_SQL_and_Statement_Caching_in_a_DatabaseQuery">How to Use Parameterized SQL and Statement Caching in a DatabaseQuery</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Use_Parameterized_SQL_and_Statement_Caching_in_a_DatabaseQuery">How to Use Parameterized SQL and Statement Caching in a DatabaseQuery</ulink></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="How_to_Read_Objects_Using_a_DatabaseQuery"/>How to Read Objects Using a DatabaseQuery</title></sect1><sect1><title>This section provides examples of how to read objects using a DatabaseQuery, including the following: </title>DatabaseQuery<orderedlist>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Performing_Basic_DatabaseQuery_Read_Operations">Performing Basic DatabaseQuery Read Operations</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Partial_Object_Queries">Reading Objects Using Partial Object Queries</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Report_Queries">Reading Objects Using Report Queries</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Query-By-Example">Reading Objects Using Query-By-Example</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_Read_Ordering">Specifying Read Ordering</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_a_Collection_Class">Specifying a Collection Class</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_the_Maximum_Rows_Returned">Specifying the Maximum Rows Returned</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Configuring_Query_Timeout_at_the_Query_Level">Configuring Query Timeout at the Query Level</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Batch_Reading">Using Batch Reading</ulink> 
         </title>
      </listitem>
      <listitem>
         <title>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Join_Reading_with_ObjectLevelReadQuery">Using Join Reading with ObjectLevelReadQuery</ulink> 
         </title>
      </listitem>
   </orderedlist></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Performing_Basic_DatabaseQuery_Read_Operations">Performing Basic DatabaseQuery Read Operations</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Performing_Basic_DatabaseQuery_Read_Operations">Performing Basic DatabaseQuery Read Operations</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Partial_Object_Queries">Reading Objects Using Partial Object Queries</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Partial_Object_Queries">Reading Objects Using Partial Object Queries</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Partial_Object_Queries">Reading Objects Using Partial Object Queries</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Report_Queries">Reading Objects Using Report Queries</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Report_Queries">Reading Objects Using Report Queries</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Report_Queries">Reading Objects Using Report Queries</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Query-By-Example">Reading Objects Using Query-By-Example</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Query-By-Example">Reading Objects Using Query-By-Example</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Reading_Objects_Using_Query-By-Example">Reading Objects Using Query-By-Example</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_Read_Ordering">Specifying Read Ordering</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_Read_Ordering">Specifying Read Ordering</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_Read_Ordering">Specifying Read Ordering</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_a_Collection_Class">Specifying a Collection Class</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_a_Collection_Class">Specifying a Collection Class</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_a_Collection_Class">Specifying a Collection Class</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_the_Maximum_Rows_Returned">Specifying the Maximum Rows Returned</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_the_Maximum_Rows_Returned">Specifying the Maximum Rows Returned</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Specifying_the_Maximum_Rows_Returned">Specifying the Maximum Rows Returned</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Configuring_Query_Timeout_at_the_Query_Level">Configuring Query Timeout at the Query Level</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Configuring_Query_Timeout_at_the_Query_Level">Configuring Query Timeout at the Query Level</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Configuring_Query_Timeout_at_the_Query_Level">Configuring Query Timeout at the Query Level</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Batch_Reading">Using Batch Reading</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Batch_Reading">Using Batch Reading</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Batch_Reading">Using Batch Reading</ulink>
   <listitem>
      <title>
         <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Join_Reading_with_ObjectLevelReadQuery">Using Join Reading with ObjectLevelReadQuery</ulink> 
      </title>
   </listitem></sect1><sect1><title>
      <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Join_Reading_with_ObjectLevelReadQuery">Using Join Reading with ObjectLevelReadQuery</ulink> 
   </title>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Join_Reading_with_ObjectLevelReadQuery">Using Join Reading with ObjectLevelReadQuery</ulink></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Performing_Basic_DatabaseQuery_Read_Operations"/>Performing Basic DatabaseQuery Read Operations</title></sect1><sect1><title>The following example illustrates a simple read query. It uses an EclipseLink expression, but does not use its own arguments for the query. Instead, it relies on the search parameters the expression provides. This example builds the expression within its code, but does not register the query with the session. </title></sect1><sect1><title>
      <anchor id="Example_105-5"/>Simple ReadAllQuery </title>Simple ReadAllQuery</sect1><sect1><title>// This example returns a List of employees whose employee ID is &gt; 100</title></sect1><sect1><title/></sect1><sect1><title>// Initialize the DatabaseQuery by specifying the query type</title></sect1><sect1><title>// and set the reference class for the query</title></sect1><sect1><title/></sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title/></sect1><sect1><title>// Retrieve ExpressionBuilder from the query</title></sect1><sect1><title>ExpressionBuilder builder = query.getExpressionBuilder();</title></sect1><sect1><title/></sect1><sect1><title>// Configure the query execution. Because this example uses </title>// Configure the query execution. Because this example uses</sect1><sect1><title>// an expression, it uses the setSelectionCriteria method</title></sect1><sect1><title>query.setSelectionCriteria(builder.get("id").greaterThan(100)); </title></sect1><sect1><title/></sect1><sect1><title>// Execute the query</title></sect1><sect1><title>List employees = (List) session.executeQuery(query);</title></sect1><sect1><title>The following example illustrates a complex readObject query that uses all available configuration options. </title>readObject</sect1><sect1><title>
      <anchor id="Example_105-6"/>Named Read Query with Two Arguments </title>Named Read Query with Two Arguments</sect1><sect1><title>// Initialize the DatabaseQuery by specifying the query type</title></sect1><sect1><title>// and set the reference class for the query</title></sect1><sect1><title>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</title></sect1><sect1><title>// Retrieve ExpressionBuilder from the query</title></sect1><sect1><title>ExpressionBuilder builder = query.getExpressionBuilder();</title></sect1><sect1><title>// Define two expressions that map to the first and last names of the employee</title></sect1><sect1><title>Expression firstNameExpression = builder.get("firstName").equal(emp.getParameter("firstName"));</title></sect1><sect1><title>Expression lastNameExpression = builder.get("lastName").equal(emp.getParameter("lastName"));</title></sect1><sect1><title/></sect1><sect1><title>// Configure the query execution. Because this example uses an expression, </title>// Configure the query execution. Because this example uses an expression,</sect1><sect1><title>// it uses the setSelectionCriteria method </title></sect1><sect1><title>query.setSelectionCriteria(firstNameExpression.and(lastNameExpression)); </title></sect1><sect1><title>// Specify the required arguments for the query</title></sect1><sect1><title>query.addArgument("firstName");</title></sect1><sect1><title>query.addArgument("lastName");</title></sect1><sect1><title/></sect1><sect1><title>// Add the query to the session</title></sect1><sect1><title>session.addQuery("getEmployeeWithName", query);</title></sect1><sect1><title/></sect1><sect1><title>// Execute the query by referencing its name and providing values for the specified arguments</title></sect1><sect1><title>Employee employee = (Employee) session.executeQuery("getEmployeeWithName","Bob","Smith");</title></sect1><sect1><title>
      <anchor id="Reading_Objects_Using_Partial_Object_Queries"/>Reading Objects Using Partial Object Queries</title></sect1><sect1><title>The following example demonstrates the use of partial object reading. It reads only the last name and primary key for the employees. This reduces the amount of data read from the database. </title></sect1><sect1><title>
      <anchor id="Example_105-7"/>Using Partial Object Reading </title>Using Partial Object Reading</sect1><sect1><title>// Read all the employees from the database, ask the user to choose one and return it. </title>// Read all the employees from the database, ask the user to choose one and return it.</sect1><sect1><title>// This uses partial object reading to read just the last name of the employees. Since  </title>// This uses partial object reading to read just the last name of the employees. Since</sect1><sect1><title>// EclipseLink automatically includes the primary key of the object, the full object </title></sect1><sect1><title>// can easily be read for editing</title></sect1><sect1><title>List list;</title></sect1><sect1><title>// Fetch data from database and add to list box</title></sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title>query.addPartialAttribute("lastName");</title></sect1><sect1><title/></sect1><sect1><title>// The next line avoids a query exception</title></sect1><sect1><title>query.dontMaintainCache();</title></sect1><sect1><title>List employees = (List) session.executeQuery(query);</title></sect1><sect1><title>list.addAll(employees);</title></sect1><sect1><title/></sect1><sect1><title>// Display list box</title></sect1><sect1><title>...</title></sect1><sect1><title>// Get selected employee from list</title></sect1><sect1><title>Employee selectedEmployee = (Employee)session.readObject(list.getSelectedItem());</title></sect1><sect1><title>return selectedEmployee;</title></sect1><sect1><title>
      <anchor id="Reading_Objects_Using_Report_Queries"/>Reading Objects Using Report Queries</title></sect1><sect1><title>The following example reports the total and average salaries for Canadian employees grouped by their city. </title></sect1><sect1><title>
      <anchor id="Example_105-8"/>Querying Reporting Information on Employees </title>Querying Reporting Information on Employees</sect1><sect1><title>ExpressionBuilder emp = new ExpressionBuilder();</title></sect1><sect1><title>ReportQuery query = new ReportQuery(Employee.class, emp);</title></sect1><sect1><title>query.addMaximum("max-salary", emp.get("salary"));</title></sect1><sect1><title>query.addAverage("average-salary", emp.get("salary"));</title></sect1><sect1><title>query.addAttribute("city", emp.get("address").get("city"));</title></sect1><sect1><title/></sect1><sect1><title>query.setSelectionCriteria(emp.get("address").get("country").equal("Canada"));</title></sect1><sect1><title>query.addOrdering(emp.get("address").get("city"));</title></sect1><sect1><title>query.addGrouping(emp.get("address").get("city"));</title></sect1><sect1><title>List reports = (List) session.executeQuery(query);</title></sect1><sect1><title>The ReportQuery class provides an extensive reporting API, including methods for computing average, maximum, minimum, sum, standard deviation, variance, and count of attributes. For more information about the available methods for the ReportQuery, see the EclipseLink API Reference. </title>ReportQueryReportQueryEclipseLink API Reference</sect1><sect1><title/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: Because ReportQuery inherits from ReadAllQuery, it also supports most ReadAllQuery properties. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></sect1><sect1><title>
      <anchor id="Reading_Objects_Using_Query-By-Example"/>Reading Objects Using Query-By-Example</title></sect1><sect1><title>Query-by-example enables you to specify query selection criteria in the form of a sample object instance that you populate with only the attributes you want to use for the query. </title></sect1><sect1><title>To define a query-by-example, provide a ReadObjectQuery or a ReadAllQuery with a sample persistent object instance and an optional query-by-example policy. The sample instance contains the data to query, and, optionally, a QueryByExamplePolicy (see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Defining_a_QueryByExamplePolicy">Defining a QueryByExamplePolicy</ulink>) that specifies configuration settings, such as the operators to use and the attribute values to ignore. You can also combine a query-by-example with an expression (see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Combining_Query-by-Example_and_Expressions">Combining Query-by-Example and Expressions</ulink>). </title>ReadObjectQueryReadAllQueryQueryByExamplePolicy<ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Defining_a_QueryByExamplePolicy">Defining a QueryByExamplePolicy</ulink>
   <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Combining_Query-by-Example_and_Expressions">Combining Query-by-Example and Expressions</ulink></sect1><sect1><title>For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Query-by-Example</ulink>. </title>
   <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Query-by-Example</ulink></sect1><sect1><title>The following example queries the employee Bob Smith. </title></sect1><sect1><title>
      <anchor id="Example_105-9"/>Using Query-by-Example to Query an Employee </title>Using Query-by-Example to Query an Employee</sect1><sect1><title>Employee employee = new Employee();</title></sect1><sect1><title>employee.setFirstName("Bob");</title></sect1><sect1><title>employee.setLastName("Smith");</title></sect1><sect1><title/></sect1><sect1><title>// Create a query and set Employee as its reference class</title></sect1><sect1><title>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</title></sect1><sect1><title>query.setExampleObject(employee);</title></sect1><sect1><title/></sect1><sect1><title>Employee result = (Employee) session.executeQuery(query);</title></sect1><sect1><title>The following example queries across the employee's address. </title></sect1><sect1><title>
      <anchor id="Example_105-10"/>Using Query-by-Example to Query an Employee's Address </title>Using Query-by-Example to Query an Employee's Address</sect1><sect1><title>Employee employee = new Employee();</title></sect1><sect1><title>Address address = new Address();</title></sect1><sect1><title>address.setCity("Ottawa");</title></sect1><sect1><title>employee.setAddress(address);</title></sect1><sect1><title/></sect1><sect1><title>// Create a query and set Employee as its reference class</title></sect1><sect1><title>ReadAllQuery query = new ReadAllQuery (Employee.class);</title></sect1><sect1><title>query.setExampleObject(employee);</title></sect1><sect1><title/></sect1><sect1><title>List results = (List) session.executeQuery(query);</title></sect1><sect1><title>Defining a QueryByExamplePolicy </title>Defining a QueryByExamplePolicy</sect1><sect1><title>EclipseLink support for query-by-example includes a query-by-example policy. You can edit the policy to modify query-by-example default behavior. You can modify the policy to do the following: </title>
   <orderedlist>
      <listitem>
         <title>Use LIKE or other operations to compare attributes. By default, query-by-example allows only EQUALS. </title>
      </listitem>
      <listitem>
         <title>Modify the set of values query-by-example ignores (the IGNORE set). The default ignored values are zero (0), empty strings, and FALSE. </title>
      </listitem>
      <listitem>
         <title>Force query-by-example to consider attribute values, even if the value is in the IGNORE set. </title>
      </listitem>
      <listitem>
         <title>Use isNull or notNull for attribute values. </title>
      </listitem>
   </orderedlist></sect1><sect1><title>Use LIKE or other operations to compare attributes. By default, query-by-example allows only EQUALS. </title>LIKEEQUALS<listitem>
      <title>Modify the set of values query-by-example ignores (the IGNORE set). The default ignored values are zero (0), empty strings, and FALSE. </title>
   </listitem></sect1><sect1><title>Modify the set of values query-by-example ignores (the IGNORE set). The default ignored values are zero (0), empty strings, and FALSE. </title>IGNOREFALSE<listitem>
      <title>Force query-by-example to consider attribute values, even if the value is in the IGNORE set. </title>
   </listitem></sect1><sect1><title>Force query-by-example to consider attribute values, even if the value is in the IGNORE set. </title>IGNORE<listitem>
      <title>Use isNull or notNull for attribute values. </title>
   </listitem></sect1><sect1><title>Use isNull or notNull for attribute values. </title>isNullnotNull</sect1><sect1><title>To specify a query-by-example policy, include an instance of QueryByExamplePolicy with the query. </title>QueryByExamplePolicy</sect1><sect1><title>The following example uses like operator for strings and includes only objects whose salary is greater than zero. </title>like</sect1><sect1><title>
      <anchor id="Example_105-11"/>Query-by-Example Policy Using like Operator </title>Query-by-Example Policy Using like Operator</sect1><sect1><title>Employee employee = new Employee();</title></sect1><sect1><title>employee.setFirstName("B%");</title></sect1><sect1><title>employee.setLastName("S%");</title></sect1><sect1><title>employee.setSalary(0);</title></sect1><sect1><title/></sect1><sect1><title>// Create a query and set Employee as its reference class</title></sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title>query.setExampleObject(employee);</title></sect1><sect1><title>// Query by example policy section adds like and greaterThan </title></sect1><sect1><title>QueryByExamplePolicy policy = new QueryByExamplePolicy();</title></sect1><sect1><title>policy.addSpecialOperation(String.class, "like");</title></sect1><sect1><title>policy.addSpecialOperation(Integer.class, "greaterThan");</title></sect1><sect1><title>policy.alwaysIncludeAttribute(Employee.class, "salary");</title></sect1><sect1><title>query.setQueryByExamplePolicy(policy);</title></sect1><sect1><title>List results = (List) session.executeQuery(query);</title></sect1><sect1><title>This example uses keywords for strings and ignores the value -1. </title></sect1><sect1><title>
      <anchor id="Example_105-12"/>Query-by-Example Policy Using Keywords </title>Query-by-Example Policy Using Keywords</sect1><sect1><title>Employee employee = new Employee();</title></sect1><sect1><title>employee.setFirstName("bob joe fred");</title></sect1><sect1><title>employee.setLastName("smith mc mac");</title></sect1><sect1><title>employee.setSalary(-1);</title></sect1><sect1><title/></sect1><sect1><title>// Create a query and set Employee as its reference class</title></sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title>query.setExampleObject(employee);</title></sect1><sect1><title>// Query by example policy section </title></sect1><sect1><title>QueryByExamplePolicy policy = new QueryByExamplePolicy();</title></sect1><sect1><title>policy.addSpecialOperation(String.class, "containsAnyKeyWords");</title></sect1><sect1><title>policy.excludeValue(-1);</title></sect1><sect1><title>query.setQueryByExamplePolicy(policy);</title></sect1><sect1><title>List results = (List) session.executeQuery(query);</title></sect1><sect1><title>Combining Query-by-Example and Expressions </title>Combining Query-by-Example and Expressions</sect1><sect1><title>To create more complex query-by-example queries, combine query-by-example with EclipseLink expressions, as shown in the following example. </title></sect1><sect1><title>
      <anchor id="Example_105-13"/>Combining Query-by-Example with Expressions </title>Combining Query-by-Example with Expressions</sect1><sect1><title>Employee employee = new Employee();</title></sect1><sect1><title>employee.setFirstName("Bob");</title></sect1><sect1><title>employee.setLastName("Smith");</title></sect1><sect1><title/></sect1><sect1><title>// Create a query and set Employee as its reference class</title></sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title/></sect1><sect1><title>query.setExampleObject(employee);</title></sect1><sect1><title/></sect1><sect1><title>// Specify expression </title></sect1><sect1><title>ExpressionBuilder builder = query.getExpressionBuilder();</title></sect1><sect1><title>query.setSelectionCriteria(builder.get("salary").between(100000,200000);</title></sect1><sect1><title>List results = (List) session.executeQuery(query);</title></sect1><sect1><title>
      <anchor id="Specifying_Read_Ordering"/>Specifying Read Ordering</title></sect1><sect1><title>Ordering is a common DatabaseQuery option. You can order a collection of objects returned from a ReadAllQuery using the addOrdering, addAscendingOrdering, or addDescendingOrdering methods. You can apply order based on attribute names or query keys and expressions. </title>DatabaseQueryReadAllQueryaddOrderingaddAscendingOrderingaddDescendingOrdering</sect1><sect1><title>
      <anchor id="Example_105-14"/>A Query with Simple Ordering </title>A Query with Simple Ordering</sect1><sect1><title>// Retrieves objects ordered by last name then first name in ascending order </title></sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title>query.addAscendingOrdering ("lastName");</title></sect1><sect1><title>query.addAscendingOrdering ("firstName");</title></sect1><sect1><title>List employees = (List) session.executeQuery(query);</title></sect1><sect1><title>
      <anchor id=".27Example_105-15"/>A Query with Complex Ordering </title>A Query with Complex Ordering</sect1><sect1><title>// Retrieves objects ordered by street address, descending case-insensitive </title>// Retrieves objects ordered by street address, descending case-insensitive</sect1><sect1><title>// order of cities, and manager's last name </title></sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title>ExpressionBuilder emp = query.getExpressionBuilder();</title></sect1><sect1><title>query.addOrdering (emp.getAllowingNull("address").get("street"));</title></sect1><sect1><title>query.addOrdering(emp.getAllowingNull("address").get("city").toUpperCase().descending());</title></sect1><sect1><title>query.addOrdering(emp.getAllowingNull("manager").get("lastName"));</title></sect1><sect1><title>List employees = (List) session.executeQuery(query);</title></sect1><sect1><title>Note the use of getAllowingNull, which creates an outer join for the address and manager relationships. This ensures that employees without an address or manager still appear in the list. </title>getAllowingNull</sect1><sect1><title>For more information about configuring read ordering, see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Read All Query Order</ulink>. </title>
   <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Read All Query Order</ulink></sect1><sect1><title>
      <anchor id="Specifying_a_Collection_Class"/>Specifying a Collection Class</title></sect1><sect1><title>By default, a ReadAllQuery returns its result objects in a list. You can configure the query to return the results in any collection class that implements the Collection or Map interface, as shown in the following example. </title>ReadAllQueryCollectionMap</sect1><sect1><title>
      <anchor id="Example_105-16"/>Specifying the Collection Class for a Collection </title>Specifying the Collection Class for a Collection</sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title>query.useCollectionClass(LinkedList.class);</title></sect1><sect1><title>LinkedList employees = (LinkedList) getSession().executeQuery(query);</title></sect1><sect1><title>
      <anchor id="Example_105-17"/>Specifying the Collection Class for a Map </title>Specifying the Collection Class for a Map</sect1><sect1><title/></sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title>query.useMapClass(HashMap.class, "getFirstName");</title></sect1><sect1><title>HashMap employees = (HashMap) getSession().executeQuery(query);</title></sect1><sect1><title/></sect1><sect1><title>
      <anchor id="Specifying_the_Maximum_Rows_Returned"/>Specifying the Maximum Rows Returned</title></sect1><sect1><title>You can limit a query to a specified maximum number of rows. Use this feature to avoid queries that can return an excessive number of objects. </title></sect1><sect1><title>To specify a maximum number of rows, use the setMaxRows method, and pass an integer that represents the maximum number of rows for the query, as shown in the following example. </title>setMaxRows</sect1><sect1><title>
      <anchor id="Example_105-18"/>Setting the Maximum Returned Object Size </title>Setting the Maximum Returned Object Size</sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title>query.setMaxRows(5);</title></sect1><sect1><title>List employees = (List) session.executeQuery(query);</title></sect1><sect1><title>The setMaxRows method limits the number of rows the query returns, but does not let you acquire more records after the initial result set. </title>setMaxRows</sect1><sect1><title>If you want to browse the result set in fixed increments, use either cursors or cursored streams. For more information, see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29">Handling Cursor and Stream Query Results</ulink>. </title>
   <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29">Handling Cursor and Stream Query Results</ulink></sect1><sect1><title>
      <anchor id="Configuring_Query_Timeout_at_the_Query_Level"/>Configuring Query Timeout at the Query Level</title></sect1><sect1><title>You can set the maximum amount of time that EclipseLink waits for results from a query. This forces a hung or lengthy query to abort after the specified time has elapsed. EclipseLink throws a DatabaseException after the timeout interval. </title>DatabaseException</sect1><sect1><title>To specify a timeout interval on a per-query basis, use DatabaseQuery method setQueryTimeout and pass the timeout interval as an integer representing the number of seconds before the timeout interval should occur, as the following example shows. </title>DatabaseQuerysetQueryTimeout</sect1><sect1><title>
      <anchor id="Example_105-19"/>DatabaseQuery Timeout </title>DatabaseQuery Timeout</sect1><sect1><title> // Create the appropriate query and set timeout limits</title>// Create the appropriate query and set timeout limits</sect1><sect1><title/></sect1><sect1><title>ReadAllQuery query = new ReadAllQuery(Employee.class);</title></sect1><sect1><title>query.setQueryTimeout(2);</title></sect1><sect1><title>try {</title></sect1><sect1><title>    List employees = (List) session.executeQuery(query);</title></sect1><sect1><title>} </title></sect1><sect1><title>catch (DatabaseException ex) {</title></sect1><sect1><title>    // timeout occurs</title>// timeout occurs</sect1><sect1><title>}</title></sect1><sect1><title>To specify a timeout interval for all queries on a particular object type, configure a query timeout interval at the descriptor level (see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Query Timeout at the Descriptor Level</ulink>). </title>
   <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Query Timeout at the Descriptor Level</ulink></sect1><sect1><title>
      <anchor id="Using_Batch_Reading"/>Using Batch Reading</title></sect1><sect1><title>Batch reading propagates query selection criteria through an object's relationship attribute mappings. You can also nest batch read operations down through complex object graphs. This significantly reduces the number of required SQL select statements and improves database access efficiency. </title></sect1><sect1><title>Consider the following guidelines when you implement batch reading: </title>
   <orderedlist>
      <listitem>
         <title>Use batch reading for processes that read in objects and all their related objects. </title>
      </listitem>
      <listitem>
         <title>Do not enable batch reading for both sides of a bidirectional relationship. </title>
      </listitem>
      <listitem>
         <title>Avoid nested batch read operations, because they result in multiple joins on the database, slowing query execution. </title>
      </listitem>
   </orderedlist></sect1><sect1><title>Use batch reading for processes that read in objects and all their related objects. </title>
   <listitem>
      <title>Do not enable batch reading for both sides of a bidirectional relationship. </title>
   </listitem></sect1><sect1><title>Do not enable batch reading for both sides of a bidirectional relationship. </title>
   <listitem>
      <title>Avoid nested batch read operations, because they result in multiple joins on the database, slowing query execution. </title>
   </listitem></sect1><sect1><title>Avoid nested batch read operations, because they result in multiple joins on the database, slowing query execution. </title></sect1><sect1><title>For more information, see <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29">Reading Case 2: Batch Reading Objects</ulink>. </title>
   <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29">Reading Case 2: Batch Reading Objects</ulink></sect1><sect1><title>For example, in reading n employees and their related projects, EclipseLink may require n + 1 select operations. All employees are read at once, but the projects of each are read individually. With batch reading, all related projects can also be read with one select operation by using the original selection criteria, for a total of only two select operations. </title>nn + 1</sect1><sect1><title>To implement batch reading, add the batch read attribute to a query, use the query.addBatchReadAttribute(Expression anExpression) API, as the following example shows: </title>query.addBatchReadAttribute(Expression anExpression)</sect1><sect1><title>…</title></sect1><sect1><title>ReadAllQuery raq = new ReadAllQuery(Trade.class);</title></sect1><sect1><title>ExpressionBuilder tradeBuilder = raq.getBuilder();</title></sect1><sect1><title>…</title></sect1><sect1><title>Expression batchReadProduct = tradeBuilder.get("product");</title></sect1><sect1><title>readAllQuery.addBatchReadAttribute(batchReadProduct); </title></sect1><sect1><title>Expression batchReadPricingDetails = batchReadProduct.get("pricingDetails");</title></sect1><sect1><title>readAllQuery.addBatchReadAttribute(batchReadPricingDetails); </title></sect1><sect1><title>…</title></sect1><sect1><title>Alternatively, you can add batch reading at the mapping level for a descriptor. For more information, see <ulink url="http://wiki.eclipse.org/Configuring_a_Relational_Mapping_%28ELUG%29">Configuring Batch Reading</ulink>. </title>
   <ulink url="http://wiki.eclipse.org/Configuring_a_Relational_Mapping_%28ELUG%29">Configuring Batch Reading</ulink></sect1><sect1><title>You can combine batch reading and indirection (lazy loading) to provide controlled reading of object attributes. For example, if you have one-to-one back pointer relationship attributes, you can defer back pointer instantiation until the end of the query, when all parent and owning objects are instantiated. This prevents unnecessary database access and optimizes EclipseLink cache use. </title></sect1><sect1><title>
      <anchor id="Using_Join_Reading_with_ObjectLevelReadQuery"/>Using Join Reading with ObjectLevelReadQuery</title></sect1><sect1><title>Use join reading with ObjectLevelReadQuery to configure a query for a class to return the data to build an instance of that class and its related objects. For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Join Reading and Object-Level Read Queries</ulink>. </title>ObjectLevelReadQuery<ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Join Reading and Object-Level Read Queries</ulink></sect1><sect1><title>To use join reading with an ObjectLevelReadQuery, you can use Workbench (see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Named Query Optimization</ulink>))or Java. </title>ObjectLevelReadQuery<ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Named Query Optimization</ulink></sect1><sect1><title/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: You cannot use Workbench to create an ObjectLevelReadQuery with a join expression on a one-to-many mapped attribute: you must use Java. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></sect1><sect1><title/><sect2><title>
      <anchor id="Using_Java"/>Using Java</title>
   <para>You can use ObjectLevelReadQuery API to add joined attributes for mappings. </para>
   <para>You can use any of the following API: </para>
   <orderedlist>
      <listitem>
         <para>Use the ObjectLevelReadQuery method addJoinedAttribute with a join expression or attribute name for one-to-one or one-to-many mapped attributes.Using this method, you can add multiple joined attributes, including nested joins. The source and target can be the same class type.On a one-to-one mapped attribute, use this method to get the class of the ObjectLevelReadQuery and the target of the one-to-one mapped attribute of that class with a single database hit.On a one-to-many mapped attribute, use this method to get the class of the ObjectLevelReadQuery and the target collection of the one-to-many mapped attribute of that class with a single database hit. </para>
      </listitem>
      <listitem>
         <para>Use the ObjectLevelReadQuery method setShouldFilterDuplicates with a join expression on a one-to-many mapped attribute to filter duplicate rows. Default is true, unless using a JPA query. </para>
      </listitem>
      <listitem>
         <para>Use the ObjectLevelReadQuery method setShouldOuterJoinSubclasses to configure an object-level read query to allow inherited subclasses to be outer-joined to avoid the cost of a single query per class. </para>
      </listitem>
   </orderedlist>
   <para>Use a join expression to configure nested batch reads and inner or outer joins (see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Expressions_%28ELUG%29">Expressions for Joining and Complex Relationships</ulink>). You can also specify inner or outer joins using the mapping methods useInnerJoinFetch or useOuterJoinFetch. </para>
   <para>The <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-20">Join Reading Multiple Attributes</ulink> example is based on the EclipseLink ThreeTierEmployee example project. It shows a ReadAllQuery configured to join-read multiple attributes. </para>
   <para>
      <anchor id="Example_105-20"/>Join Reading Multiple Attributes </para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para/>
   <para>Expression managedEmployees = query.getExpressionBuilder().anyOfAllowingNone("managedEmployees");</para>
   <para>query.addJoinedAttribute(managedEmployees);</para>
   <para>query.addJoinedAttribute(managedEmployees.get("address"));</para>
   <para>query.addJoinedAttribute(managedEmployees.anyOf("phoneNumbers"));</para>
   <para/>
   <para>List employees = (List) getSession().executeQuery(query);</para>
   <para>Use the ObjectLevelReadQuery method addJoinedAttribute(java.lang.String attributeName) to configure the query to join-read a single attribute, as the following shows. </para>
   <para>
      <anchor id="Example_105-22"/>Join Reading a Single Attribute </para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.addJoinedAttribute("address");</para>
   <para>List employees = (List)getSession().executeQuery(query);</para>
   <para/>
   <para>
      <anchor id="How_to_Create.2C_Update.2C_and_Delete_Objects_with_a_DatabaseQuery"/>How to Create, Update, and Delete Objects with a DatabaseQuery</para>
   <para>You can create, update or delete object with a DatabaseQuery using a DatabaseSession. For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Session Queries</ulink>. </para>
   <para>This section describes the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_Write_Query">Using Write Query</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Performing_Noncascading_Write_Queries">Noncascading Write Queries</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Disabling_the_Identity_Map_Cache_During_a_Write_Query">Disabling the Identity Map Cache During a Write Query</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Using_Write_Query"/>Using Write Query</para>
   <para>To execute a write query, use a WriteObjectQuery instance instead of using the writeObject method of the session. Likewise, substitute DeleteObjectQuery, UpdateObjectQuery, and InsertObjectQuery objects for their respective Session methods. </para>
   <para>
      <anchor id="Example_105-24"/>Using a WriteObjectQuery </para>
   <para>WriteObjectQuery writeQuery = new WriteObjectQuery();</para>
   <para>writeQuery.setObject(domainObject);</para>
   <para>session.executeQuery(writeQuery);</para>
   <para>
      <anchor id="Example_105-25"/>Using InsertObjectQuery, UpdateObjectQuery, and DeleteObjectQuery </para>
   <para>InsertObjectQuery insertQuery= new InsertObjectQuery();</para>
   <para>insertQuery.setObject(domainObject);</para>
   <para>session.executeQuery(insertQuery);</para>
   <para/>
   <para>// When you use UpdateObjectQuery without a unit of work,</para>
   <para>// UpdateObjectQuery writes all direct attributes to the database</para>
   <para>UpdateObjectQuery updateQuery= new UpdateObjectQuery();</para>
   <para>updateQuery.setObject(domainObject2);</para>
   <para>session.executeQuery(updateQuery);</para>
   <para/>
   <para>DeleteObjectQuery deleteQuery = new DeleteObjectQuery();</para>
   <para>deleteQuery.setObject(domainObject2);</para>
   <para>session.executeQuery(deleteQuery);</para>
   <para/>
   <para>
      <anchor id="Performing_Noncascading_Write_Queries"/>Performing Noncascading Write Queries</para>
   <para>When you execute a write query, it writes both the object and its privately owned parts to the database by default. To build write queries that do not update privately owned parts, include the dontCascadeParts method in your query definition. </para>
   <para>Use this method to do the following: </para>
   <orderedlist>
      <listitem>
         <para>Increase performance when you know that only the object's direct attributes have changed. </para>
      </listitem>
      <listitem>
         <para>Resolve referential integrity dependencies when you write large groups of new, independent objects. </para>
      </listitem>
   </orderedlist>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: Because the unit of work resolves referential integrity internally, this method is not required if you use the unit of work to write to the database. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>
      <anchor id="Example_105-27"/>Performing a Noncascading Write Query </para>
   <para>// the Employee is an existing employee read from the database</para>
   <para>Employee.setFirstName("Bob");</para>
   <para>UpdateObjectQuery query = new UpdateObjectQuery();</para>
   <para>query.setObject(Employee);</para>
   <para>query.dontCascadeParts();</para>
   <para>session.executeQuery(query);</para>
   <para/>
   <para>
      <anchor id="Disabling_the_Identity_Map_Cache_During_a_Write_Query"/>Disabling the Identity Map Cache During a Write Query</para>
   <para>When you write objects to the database, EclipseLink copies them to the session cache by default. To disable this within a query, call the dontMaintainCache method within the query. This improves query performance when you insert objects into the database, but must be used only on objects that will not be required later by the application. </para>
   <para>The following example reads all the objects from a flat file and writes new copies of the objects into a table. </para>
   <para>
      <anchor id="Example_105-28"/>Disabling the Identity Map Cache During a Write Query </para>
   <para>// Reads objects from an employee file and writes them to the employee table</para>
   <para>void createEmployeeTable(String filename, Session session) {</para>
   <para>   Iterator iterator;</para>
   <para>   Employee employee;</para>
   <para/>
   <para>   // Read the employee data file</para>
   <para>   List employees = Employee.parseFromFile(filename);</para>
   <para>   Iterator iterator = employees.iterator();</para>
   <para>   while (iterator.hasNext()) {</para>
   <para>      Employee employee = (Employee) iterator.next();</para>
   <para>      InsertObjectQuery query = new InsertObjectQuery();</para>
   <para>      query.setObject(employee);</para>
   <para>      query.dontMaintainCache();</para>
   <para>      session.executeQuery(query);</para>
   <para>   }</para>
   <para>}</para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: Disable the identity map only when object identity is unimportant in subsequent operations. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>
      <anchor id="How_to_Update_and_Delete_Multiple_Objects_with_a_DatabaseQuery"/>How to Update and Delete Multiple Objects with a DatabaseQuery</para>
   <para>Using the unit of work, you can perform update and delete operations on multiple objects. </para>
   <para>This section describes the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_UpdateAll_Queries">Using UpdateAll Queries</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_DeleteAll_Queries">Using DeleteAll Queries</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Using_UpdateAll_Queries"/>Using UpdateAll Queries</para>
   <para>Use an UpdateAllQuery to update a large number of objects at once. With this query, you can update a large number of objects with a single SQL statement instead of reading the objects into memory and updating them individually. The following example shows an UpdateAllQuery to give all full-time employees a raise. </para>
   <para>
      <anchor id="Example_105-26"/>Using UpdateAllQuery </para>
   <para>// Give all full time employees a 10% raise</para>
   <para>UpdateAllQuery updateQuery = new UpdateAllQuery(Employee.class);</para>
   <para>ExpressionBuilder employee = updateQuery.getExpressionBuilder();</para>
   <para>updateQuery.setSelectionCriteria(employee.get("status").equal("FULL_TIME"));</para>
   <para>updateQuery.addUpdateExpression(employee.get("salary"), </para>
   <para>            ExpressionMath.multiply(employee.get("salary"), new Float(1.10)));</para>
   <para>UpdateAllQuery takes the cache into consideration and ensures that the cache is kept up to date. You can configure the UpdateAllQuery to invalidate cache (see <ulink url="http://wiki.eclipse.org/Introduction_to_Cache_%28ELUG%29">Cache Invalidation</ulink>) by setting the cache usage to INVALIDATE_CACHE (default), or to not use the cache by specifying NO_CACHE option. You can manipulate these settings through the setCacheUsage method. You can only update the cache for expressions that can conform. For more information on cache, see <ulink url="http://wiki.eclipse.org/Introduction_to_Cache_%28ELUG%29">Introduction to Cache</ulink>. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: You can set an attribute within an aggregate only, but not an entire aggregate. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>You can use an UpdateAllQuery with optimistic locking (see <ulink url="http://wiki.eclipse.org/Introduction_to_Descriptors_%28ELUG%29">Descriptors and Locking</ulink>) at the level of updating a row in a database–there should be no updates in the cache. You will update the locking field on the database. There is also support for version and timestamp locking, as well as indirect support for field locking. </para>
   <para/>
   <para>
      <anchor id="Using_DeleteAll_Queries"/>Using DeleteAll Queries</para>
   <para>The following example shows a DeleteAllQuery to eliminate all part-time employee positions. </para>
   <para>
      <anchor id="Example_105-271"/>Using DeleteAllQuery </para>
   <para>// Delete all part-time employees</para>
   <para>DeleteAllQuery deleteQuery = new DeleteAllQuery(Employee.class);</para>
   <para>ExpressionBuilder employee = deleteQuery.getExpressionBuilder();</para>
   <para>deleteQuery.setSelectionCriteria(employee.get("status").equal("PART_TIME"));</para>
   <para>deleteQuery.setObjects(domainObjects);</para>
   <para>session.executeQuery(deleteQuery);</para>
   <para>For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">DeleteAllQuery</ulink> 
   </para>
   <para>
      <anchor id="How_to_Read_Data_with_a_DatabaseQuery"/>How to Read Data with a DatabaseQuery</para>
   <para>This section describes the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_DataReadQuery">Using a DataReadQuery</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_DirectReadQuery">Using a DirectReadQuery</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_ValueReadQuery">Using a ValueReadQuery</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Using_a_DataReadQuery"/>Using a DataReadQuery</para>
   <para>You can use a DataReadQuery to execute a selecting SQL string that returns a Collection of the Record objects representing the result set, as the following example shows. </para>
   <para>
      <anchor id="Example_105-29"/>Using a DataReadQuery </para>
   <para>DataReadQuery dataReadQuery = new DataReadQuery();</para>
   <para>dataReadQuery.setSQLString("Select * from EMPLOYEE"); </para>
   <para/>
   <para>// queryResults is a List of DatabaseRow objects</para>
   <para>List queryResults = (List)session.executeQuery(dataReadQuery);</para>
   <para/>
   <para>
      <anchor id="Using_a_DirectReadQuery"/>Using a DirectReadQuery</para>
   <para>You can use a DirectReadQuery to read a single column of data (that is, one field) that returns a Collection of the Record objects representing the result set, as this example shows. </para>
   <para>
      <anchor id="Example_105-30"/>Using a DirectReadQuery </para>
   <para>DirectReadQuery directReadQuery = new DirectReadQuery();</para>
   <para>directReadQuery.setSQLString("Select * from EMPLOYEE"); </para>
   <para/>
   <para>// queryResults is a List of Record objects</para>
   <para>List queryResults = (List)session.executeQuery(directReadQuery);</para>
   <para/>
   <para>
      <anchor id="Using_a_ValueReadQuery"/>Using a ValueReadQuery</para>
   <para>You can use a ValueReadQuery to read a single data value (that is, one field). A single data value is returned, or null if no rows are returned, as this example shows. </para>
   <para>
      <anchor id="Example_105-31"/>Using a ValueReadQuery </para>
   <para>ValueReadQuery valueReadQuery = new ValueReadQuery();</para>
   <para>valueReadQuery.setSQLString("SELECT DISTINCT CURRENT TIMESTAMP FROM SYSTABLES");</para>
   <para/>
   <para>// result is a single Object value</para>
   <para>Object result = session.executeQuery(valueReadQuery);</para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>WARNING: Allowing an unverified SQL string to be passed into methods (for example: setSQLString method) makes your application vulnerable to SQL injection attacks. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>
      <anchor id="How_to_Update_Data_with_a_DatabaseQuery"/>How to Update Data with a DatabaseQuery</para>
   <para>You can use a DataModifyQuery to execute a nonselecting SQL statement (directly or as an SQLCall), as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-32">Using a DataModifyQuery</ulink> example shows. This is equivalent to Session method executeNonSelectingCall (see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_SQLCall">Using a SQLCall</ulink>). </para>
   <para>
      <anchor id="Example_105-32"/>Using a DataModifyQuery </para>
   <para>DataModifyQuery query = new DataModifyQuery(new SQLCall("Delete from Employee"));</para>
   <para>session.executeQuery(query);</para>
   <para/>
   <para>
      <anchor id="How_to_Specify_a_Custom_SQL_String_in_a_DatabaseQuery"/>How to Specify a Custom SQL String in a DatabaseQuery</para>
   <para>All DatabaseQuery objects provide a setSQLString method that you can use to define a custom SQL string. </para>
   <para>For more information about using custom SQL in queries, see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_SQLCall">Using a SQLCall</ulink>. </para>
   <para>The following example uses SQL to read all employee IDs. </para>
   <para>
      <anchor id="Example_105-33"/>A Direct Read Query with SQL </para>
   <para>DirectReadQuery query = new DirectReadQuery();</para>
   <para>query.setSQLString("SELECT EMP_ID FROM EMPLOYEE");</para>
   <para>List ids = (List) session.executeQuery(query);</para>
   <para>The following example uses SQL to switch to a different database. </para>
   <para>
      <anchor id="Example_105-34"/>A Data Modify Query with SQL </para>
   <para>DataModifyQuery query = new DataModifyQuery();</para>
   <para>query.setSQLString("USE SALESDATABASE");</para>
   <para>session.executeQuery(query);</para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>WARNING: Allowing an unverified SQL string to be passed into methods (for example: setSQLString method) makes your application vulnerable to SQL injection attacks. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>
      <anchor id="How_to_Specify_a_Custom_JPQL_String_in_a_DatabaseQuery"/>How to Specify a Custom JPQL String in a DatabaseQuery</para>
   <para>Information pending </para>
   <para/>
   <para>
      <anchor id="How_to_Use_Parameterized_SQL_and_Statement_Caching_in_a_DatabaseQuery"/>How to Use Parameterized SQL and Statement Caching in a DatabaseQuery</para>
   <para>By default, EclipseLink enables parameterized SQL (parameter binding) and statement caching. This causes EclipseLink to use a prepared statement, binding all SQL parameters and caching the prepared statement. When you reexecute this query, you avoid the SQL preparation, which improves performance. </para>
   <para>To disable parameterized SQL and statement caching on individual queries, use DatabaseQuery methods setShouldBindAllParameters and setShouldCacheStatement, passing in an argument of false. To re-enable this feature, pass in an argument of true. </para>
   <para>
      <anchor id="Example_105-35"/>A Simple ReadObjectQuery with Parameterized SQL </para>
   <para>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</para>
   <para>query.setShouldBindAllParameters(true);</para>
   <para>query.setShouldCacheStatement(true);</para>
   <para>Alternatively, you can configure parameterized SQL and binding at any of the following levels: </para>
   <orderedlist>
      <listitem>
         <para>project level–applies to all named queries (see <ulink url="http://wiki.eclipse.org/Configuring_a_Relational_Project_%28ELUG%29">Configuring Named Query Parameterized SQL and Statement Caching at the Project Level</ulink>); </para>
      </listitem>
      <listitem>
         <para>descriptor level–applies on a per-named-query basis (see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Named Query Options</ulink>); </para>
      </listitem>
      <listitem>
         <para>session database login level–applies to all queries (see <ulink url="http://wiki.eclipse.org/Configuring_a_Database_Login_%28ELUG%29">Configuring JDBC Options</ulink>) and provides additional parameter binding API to alleviate the limit imposed by some drivers on SQL statement size; </para>
      </listitem>
   </orderedlist>
   <para>For more information about using parameterized SQL and binding for data access optimization, see <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29">How to Use Parameterized SQL (Parameter Binding) and Prepared Statement Caching for Optimization</ulink>. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: For applications using a Java EE data source or external connection pool, you must configure statement caching in the Java EE server's data source–not in EclipseLink. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>
      <anchor id="Using_Named_Queries"/>Using Named Queries</para>
   <para>Named queries improve application performance because they are prepared once and they (and all their associated supporting objects) can be efficiently reused thereafter making them well suited for frequently executed operations. </para>
   <para>You can configure named queries at the session (see <ulink url="http://wiki.eclipse.org/Configuring_a_Session_%28ELUG%29">Configuring Named Queries at the Session Level</ulink>) or descriptor (see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Named Queries at the Descriptor Level</ulink>) level. </para>
   <para>For a session-level named query, you can execute the query using any of the following Session API methods: </para>
   <orderedlist>
      <listitem>
         <para>executeQuery(String queryName) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, arg1) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, arg1, arg2) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, arg1, arg2, arg3) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, List args) </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-36"/>Executing a Session-Level Named Query </para>
   <para>List args = new ArrayList();</para>
   <para>args.add("Sarah");</para>
   <para>Employee sarah = (Employee)session.executeQuery("employeeReadByFirstName", args);</para>
   <para>For a descriptor-level named query, you can execute the query using any of the following Session API calls, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-37">Executing a Descriptor Level Named Query</ulink> example shows: </para>
   <orderedlist>
      <listitem>
         <para>executeQuery(String queryName, Class domainClass) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, Class domainClass, arg1) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, Class domainClass, arg1, arg2) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, Class domainClass, arg1, arg2, arg3) </para>
      </listitem>
      <listitem>
         <para>executeQuery(String queryName, Class domainClass, List args) </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-37"/>Executing a Descriptor Level Named Query </para>
   <para>List args = new ArrayList();</para>
   <para>args.add("Sarah");</para>
   <para>Employee sarah = (Employee)session.executeQuery("ReadByFirstName", Employee.class, args);</para>
   <para>For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Named Queries</ulink> 
   </para>
   <para/>
   <para>
      <anchor id="Using_a_SQLCall"/>Using a SQLCall</para>
   <para>The EclipseLink expression framework enables you to define complex queries at the object level. If your application requires a more complex query or one that accesses data directly, you can specify a custom SQL string in an SQLCall object and execute the SQL string in the context of a DatabaseQuery or using Session API for executing Call objects. </para>
   <para>You can provide an SQLCall object to any query instead of an expression, but the SQL string contained in the SQLCall must return all data required to build an instance of the queried class. </para>
   <para>The SQL string can be a complex SQL query that includes input, output, and input/output arguments using JDBC data types. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>WARNING: Allowing an unverified SQL string to be passed into methods makes your application vulnerable to SQL injection attacks. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>
      <anchor id="How_to_Configure_a_SQLCall_Without_Arguments"/>How to Configure a SQLCall Without Arguments</para>
   <para>You can configure a SQLCall without arguments and execute it directly using Session API. Use this approach when you want to execute a SQL string without arguments (or with hard-coded argument values). </para>
   <para>To configure a SQLCall input without arguments: </para>
   <orderedlist>
      <listitem>
         <para>Instantiate a SQLCall object. </para>
      </listitem>
      <listitem>
         <para>Pass the SQL string into the constructor, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-38">Executing a SQLCall Without Arguments</ulink> example shows. Alternatively, you can use SQLCall method setSQLString. </para>
      </listitem>
      <listitem>
         <para>Execute the SQLCall using the appropriate Session API, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-38">Executing a SQLCall Without Arguments</ulink> example shows. You can use any of the following Session methods, depending on the type of SQL string you define: </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-38"/>Executing a SQLCall Without Arguments </para>
   <para>List result = session.executeSelectingCall(new SQLCall("SELECT * FROM EMPLOYEE WHERE DEPT_ID =44"));</para>
   <para>
      <anchor id="How_to_Configure_a_SQLCall_with_Arguments_Using_JDBC_Data_Types"/>How to Configure a SQLCall with Arguments Using JDBC Data Types</para>
   <para>You can configure a SQLCall that takes any combination of input, output, or input/output arguments. Use this approach when you want to bind argument values to the SQLCall at runtime, receive output values from the SQLCall at execution time, or both. </para>
   <para>To configure a SQLCall with arguments using JDBC data types: </para>
   <orderedlist>
      <listitem>
         <para>Instantiate a SQLCall object. </para>
      </listitem>
      <listitem>
         <para>Create the SQL string and designate arguments as input, output, or input/output.EclipseLink assumes that a token in the custom SQL string of an SQLCall is an argument if it is prefixed with one or more number signs ( # ), as follows: </para>
      </listitem>
      <listitem>
         <para>Pass the SQL string into the constructor, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-39">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> show.Alternatively, you can use SQLCall method setSQLString. </para>
      </listitem>
      <listitem>
         <para>For each output argument, use the appropriate SQLCall method setCustomSQLArgumentType to specify the Java data type EclipseLink uses to return the output value, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink> shows.For an input argument, EclipseLink automatically converts the Java data type to the appropriate JDBC data type.For an input/output argument, the type of the input value determines the type of the output value. As <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> shows, the data type of the argument value passed into in_out is String ("MacDonald") so EclipseLink returns the output value (for EMP_ID) as a String. </para>
      </listitem>
      <listitem>
         <para>Instantiate a DatabaseQuery appropriate for your SQL string. </para>
      </listitem>
      <listitem>
         <para>Configure the DatabaseQuery with your SQLCall using DatabaseQuery method setCall, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-39">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Specify the names for all input and input/output arguments using DatabaseQuery method addArgument, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-39">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Create a Vector of argument values in the same order as you specified argument names in step 7, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-39">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Bind values to the arguments and execute the DatabaseQuery using Session method executeQuery(DatabaseQuery, java.util.Vector), passing in your DatabaseQuery and Vector of argument values, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-39">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-40">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-41">Example 3</ulink> show. </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-39"/>Example 1: Specifying an SQLCall with an Input Argument Using the # Prefix: JDBC Data Types </para>
   <para>SQLCall sqlCall = new SQLCall("INSERT INTO EMPLOYEE (L_NAME) VALUES (#last_name)");</para>
   <para/>
   <para>DataModifyQuery query = new DataModifyQuery();</para>
   <para>query.setCall(sqlCall);</para>
   <para>query.addArgument("last_name");   // input</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald"); </para>
   <para>session.executeQuery(query, args);</para>
   <para>
      <anchor id="Example_105-40"/>Example 2: Specifying a SQLCall with an Output Argument Using the ### Prefix: JDBC Data Types </para>
   <para>SQLCall sqlCall = new SQLCall("BEGIN INSERT INTO EMPLOYEE (L_NAME) VALUES (#last_name) RETURNING EMP_ID INTO ###employee_id; END;");</para>
   <para>sqlCall.setCustomSQLArgumentType("employee_id", Integer.class); // specify output value type</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(sqlCall);</para>
   <para>query.addArgument("last_name");   // input</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald");</para>
   <para/>
   <para>Integer employeeID = (Integer) getSession().executeQuery(query, args);</para>
   <para>
      <anchor id="Example_105-41"/>Example 3: Specifying a SQLCall with an Input/Output Argument Using the #### Prefix: JDBC Data Types </para>
   <para>SQLCall sqlCall = new SQLCall("BEGIN INSERT INTO EMPLOYEE (L_NAME) VALUES (####in_out) RETURNING EMP_ID INTO ####in_out; END;");</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(sqlCall);</para>
   <para>query.addArgument("in_out");   // input and outpu</para>
   <para> </para>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald");         // type of input argument determines type of output value</para>
   <para/>
   <para>String lastName = (String) getSession().executeQuery(query, args);</para>
   <para>
      <anchor id="What_You_May_Need_to_Know_About_Using_a_SQLCall"/>What You May Need to Know About Using a SQLCall</para>
   <para>When using SQL calls, you can use a ReturningPolicy to control whether or not EclipseLink writes a parameter out or retrieves a value generated by the database. </para>
   <para>If you want to invoke a stored procedure or stored function, use a StoredProcedureCall or StoredFunctionCall. </para>
   <para>Alternatively, you can specify a simple SQL string directly on DatabaseQuery. You can use this approach to avoid the overhead of creating a SQLCall object when your SQL string is simple, uses hard-coded arguments (or no arguments), and you do not require the additional API that SQLCall provides. </para>
   <para>For more information, see the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Specify_a_Custom_SQL_String_in_a_DatabaseQuery">How to Specify a Custom SQL String in a DatabaseQuery</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Returning Policy</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_StoredProcedureCall">Using a StoredProcedureCall</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_StoredFunctionCall">Using a StoredFunctionCall</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Using_a_StoredProcedureCall"/>Using a StoredProcedureCall</para>
   <para>The EclipseLink expression framework enables you to define complex queries at the object level. If your application requires a more complex query or one that invokes an existing stored procedure that your database provides, you can define a StoredProcedureCall object using both JDBC and PL/SQL data types and invoke the stored procedure in the context of a DatabaseQuery. </para>
   <para>If you are using an Oracle Database, you can pass in both JDBC and PL/SQL (non-JDBC) data types. </para>
   <para>If you are using a non-Oracle database, you may pass in only JDBC data types. </para>
   <para>
      <ulink url="http://wiki.eclipse.org/EclipseLink/Examples/JPA/nonJDBCArgsToStoredProcedures">This example</ulink> contains additional samples on on using stored procedures. </para>
   <para/>
   <para>
      <anchor id="How_to_Configure_a_StoredProcedureCall_Without_Arguments"/>How to Configure a StoredProcedureCall Without Arguments</para>
   <para>You can configure a StoredProcedureCall without arguments and execute it directly using Session API. Use this approach when you want to execute a stored procedure that does not take arguments or return values. </para>
   <para>To configure a StoredProcedureCall without arguments using JDBC data types: </para>
   <orderedlist>
      <listitem>
         <para>Instantiate a StoredProcedureCall object. </para>
      </listitem>
      <listitem>
         <para>Set the name of the stored procedure to execute using StoredProcedureCall method setProcedureName, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-42">Executing a SQLCall Without Arguments</ulink> example shows. </para>
      </listitem>
      <listitem>
         <para>Execute the StoredProcedureCall using the appropriate Session API, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-42">Executing a SQLCall Without Arguments</ulink> example shows.You can use any of the following Session methods, depending on the type of stored procedure you are executing: </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-42"/>Executing a SQLCall Without Arguments </para>
   <para>StoredProcedureCall spcall = new StoredProcedureCall();</para>
   <para>spcall.setProcedureName("Read_All_Employees");</para>
   <para>spcall.useNamedCursorOutputAsResultSet("RESULT_SET");</para>
   <para/>
   <para>List employees = (List) getSession().executeSelectingCall(spcall);</para>
   <para/>
   <para>
      <anchor id="How_to_Configure_a_StoredProcedureCall_with_Arguments_Using_JDBC_Data_Types"/>How to Configure a StoredProcedureCall with Arguments Using JDBC Data Types</para>
   <para>You can configure a StoredProcedureCall that takes any combination of input, output, or input/output arguments. Use this approach when you want to bind argument values to the StoredProcedureCall at runtime, receive output values from the StoredProcedureCall at execution time, or both. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: Use this procedure when all input, output, and input/output arguments are JDBC data types. If one or more arguments are PL/SQL (non-JDBC) data types, see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Configure_a_PLSQLStoredProcedureCall_with_PL.2FSQL_Data_Type_Arguments">How to Configure a PLSQLStoredProcedureCall with PL/SQL Data Type Arguments</ulink>. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>To configure a StoredProcedureCall with arguments using JDBC data types: </para>
   <orderedlist>
      <listitem>
         <para>Instantiate a StoredProcedureCall object. </para>
      </listitem>
      <listitem>
         <para>Specify the name of the stored procedure to call using StoredProcedureCall method setProcedureName, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-44">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-45">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>For each argument, use the appropriate StoredProcedureCall methods to specify whether arguments are input, output, or input/output arguments: </para>
      </listitem>
      <listitem>
         <para>Instantiate a DatabaseQuery appropriate for your stored procedure. </para>
      </listitem>
      <listitem>
         <para>Configure the DatabaseQuery with your StoredProcedureCall using DatabaseQuery method setCall, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-44">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-45">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Specify the names for all input and input/output arguments using DatabaseQuery method addArgument, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-44">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-45">Example 3</ulink> show. If you associated stored procedure argument names with more meaningful alternate names in step [[#3], use the alternate names in the DatabaseQuery method addArgument, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink> shows. </para>
      </listitem>
      <listitem>
         <para>Create a Vector of argument values in the same order as you specified argument names in step [[#6], as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-44">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-45">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Bind values to the arguments and execute the DatabaseQuery using Session method executeQuery(DatabaseQuery, java.util.Vector), passing in your DatabaseQuery and Vector of argument values, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-43">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-44">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-45">Example 3</ulink> show. </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-43"/>Example 1: Specifying a StoredProcedureCall with an Input Argument: JDBC Data Types </para>
   <para>// CREATE PROCEDURE INSERT_EMPLOYEE(L_NAME IN VARCHAR) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with last name.</para>
   <para>// END;</para>
   <para/>
   <para>StoredProcedureCall spcall = new StoredProcedureCall();</para>
   <para>spcall.setProcedureName("INSERT_EMPLOYEE");</para>
   <para>spcall.addNamedArgument("L_NAME", "last_name");</para>
   <para/>
   <para>DataModifyQuery query = new DataModifyQuery();</para>
   <para>query.setCall(spcall);</para>
   <para>query.addArgument("last_name");   // input</para>
   <para/>
   <para>Vector arguments = new Vector();</para>
   <para>arguments.add("MacDonald");</para>
   <para>session.executeQuery(query, arguments);</para>
   <para>
      <anchor id="Example_105-44"/>Example 2: Specifying a StoredProcedureCall with an Output Argument: JDBC Data Types </para>
   <para>// CREATE PROCEDURE GET_EMP_ID(L_NAME IN VARCHAR, EMP_ID OUT INTEGER) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with last name and return the EMP_ID for this record.</para>
   <para>// END;</para>
   <para/>
   <para>StoredProcedureCall spcall = new StoredProcedureCall();</para>
   <para>spcall.setProcedureName("GET_EMP_ID");</para>
   <para>spcall.addNamedArgument("L_NAME");</para>
   <para>spcall.addNamedOutputArgument(</para>
   <para>    "EMP_ID",      // procedure parameter name</para>
   <para>    "EMP_ID",      // out argument field name</para>
   <para>    Integer.class  // Java type corresponding to type returned by procedure</para>
   <para>);</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(spcall);</para>
   <para>query.addArgument("L_NAME");   // input</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald");</para>
   <para/>
   <para>Integer employeeID = (Integer) getSession().executeQuery(query, args);</para>
   <para>
      <anchor id="Example_105-45"/>Example 3: Specifying a StoredProcedureCall with an Input/Output Argument: JDBC Data Types </para>
   <para>// CREATE PROCEDURE INSERT_EMPLOYEE(IN_OUT INOUT VARCHAR) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with last name and return the EMP_CODE_NAME for this record.</para>
   <para>// END;</para>
   <para/>
   <para>StoredProcedureCall spcall = new StoredProcedureCall();</para>
   <para>spcall.setProcedureName("INSERT_EMP"); // returns EMP_CODE_NAME after insert</para>
   <para>spcall.addNamedInOutputArgument(</para>
   <para>    "IN_OUT",       // procedure parameter name</para>
   <para>    "IN_OUT",       // out argument field name</para>
   <para>    String.class    // Java type corresponding to type returned by procedure</para>
   <para>);</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(sqlCall);</para>
   <para>query.addArgument("INOUT");   // input and outpu</para>
   <para> </para>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald");         // type of input argument determines type of output value</para>
   <para> </para>
   <para>String employeeCode = (String)getSession().executeQuery(query, args));</para>
   <para/>
   <para>
      <anchor id="How_to_Configure_a_PLSQLStoredProcedureCall_with_PL.2FSQL_Data_Type_Arguments"/>How to Configure a PLSQLStoredProcedureCall with PL/SQL Data Type Arguments</para>
   <para>You must use the org.eclipse.persistence.platform.database.oracle.PLSQLStoredProcedureCall class if any combination of input, output, or input/output arguments are PL/SQL (non-JDBC) data types. Use this approach when you want to bind argument values to the PLSQLStoredProcedureCall at run time, receive output values from the PLSQLStoredProcedureCall at execution time, or both. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: If all arguments are JDBC (not PL/SQL data types), see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Configure_a_StoredProcedureCall_with_Arguments_Using_JDBC_Data_Types">How to Configure a StoredProcedureCall with Arguments Using JDBC Data Types</ulink>. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>To configure a PLSQLStoredProcedureCall with arguments using JDBC and PL/SQL data types: </para>
   <orderedlist>
      <listitem>
         <para>Instantiate a PLSQLStoredProcedureCall object. </para>
      </listitem>
      <listitem>
         <para>Specify the name of the stored procedure to call using PLSQLStoredProcedureCall method setProcedureName, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-46">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-47">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>For each argument, use the appropriate PLSQLStoredProcedureCall methods to specify whether arguments are input, output, or input/output arguments: </para>
      </listitem>
      <listitem>
         <para>Instantiate a DatabaseQuery appropriate for your stored procedure. </para>
      </listitem>
      <listitem>
         <para>Configure the DatabaseQuery with your PLSQLStoredProcedureCall using DatabaseQuery method setCall, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-46">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-47">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Specify the names for all input and input/output arguments using DatabaseQuery method addArgument, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-46">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-47">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> show.If you associated stored procedure argument names with more meaningful alternate names in step 3, use the alternate names in the DatabaseQuery method addArgument, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> shows. </para>
      </listitem>
      <listitem>
         <para>Create a Vector of argument values in the same order as you specified argument names in step #6, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-46">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-47">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> show. </para>
      </listitem>
      <listitem>
         <para>Bind values to the arguments and execute the DatabaseQuery using Session method executeQuery(DatabaseQuery, java.util.Vector), passing in your DatabaseQuery and Vector of argument values, as <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-46">Example 1</ulink>, <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-47">Example 2</ulink>, and <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-48">Example 3</ulink> show. </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_105-46"/>Example 1: Specifying a PLSQLStoredProcedureCall with an Input Argument: JDBC and PL/SQL Data Types </para>
   <para>// CREATE PROCEDURE INSERT_EMPLOYEE(L_NAME IN VARCHAR, MANAGER IN BOOLEAN) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with last name and whether or not the employee is a manager.</para>
   <para>// END;</para>
   <para/>
   <para>PLSQLStoredProcedureCall plsqlcall = new PLSQLStoredProcedureCall();</para>
   <para>plsqlcall.setProcedureName("INSERT_EMPLOYEE");</para>
   <para>plsqlcall.addNamedArgument("L_NAME", JDBCTypes.VARCHAR_TYPE, 40); // must specify a length</para>
   <para>plsqlcall.addNamedArgument("MANAGER", OraclePLSQLTypes.PLSQLBoolean);</para>
   <para/>
   <para>DataModifyQuery query = new DataModifyQuery();</para>
   <para>query.setCall(plsqlcall);</para>
   <para>query.addArgument("L_NAME");    // input</para>
   <para>query.addArgument("MANAGER");   // input</para>
   <para/>
   <para>Vector arguments = new Vector();</para>
   <para>arguments.add("MacDonald");</para>
   <para>arguments.add(Integer.valueOf(1));</para>
   <para>session.executeQuery(query, arguments);</para>
   <para/>
   <para>
      <anchor id="Example_105-47"/>Example 2: Specifying a PLSQLStoredProcedureCall with an Output Argument: JDBC and PL/SQL Data Types </para>
   <para>// CREATE PROCEDURE GET_EMP_ID(L_NAME IN VARCHAR, EMP_ID OUT PLS_INTEGER) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with last name and return EMP_ID for this row.</para>
   <para>// END;</para>
   <para/>
   <para>PLSQLStoredProcedureCall plsqlcall= new PLSQLStoredProcedureCall();</para>
   <para>plsqlcall.setProcedureName("GET_EMP_ID");</para>
   <para>plsqlcall.addNamedArgument("L_NAME", JDBCTypes.VARCHAR_TYPE, 25);</para>
   <para>plsqlcall.addNamedOutputArgument("EMP_ID", OraclePLSQLTypes.PLSQLInteger);</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(plsqlcall);</para>
   <para>query.addArgument("L_NAME");   // input</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.add("MacDonald");</para>
   <para/>
   <para>Number employeeID = (Number) getSession().executeQuery(query, args);</para>
   <para/>
   <para>
      <anchor id="Example_105-48"/>Example 3: Specifying a PLSQLStoredProcedureCall with an Input/Output Argument: JDBC and PL/SQL Data Types </para>
   <para>// CREATE PROCEDURE INSERT_EMP(IN_OUT INOUT PLS_INTEGER) AS</para>
   <para>// BEGIN</para>
   <para>//     Insert an EMP record initialized with department id and return </para>
   <para>//     the EMP_ID for this record.</para>
   <para>// END;</para>
   <para/>
   <para>PLSQLStoredProcedureCall plsqlcall= new PLSQLStoredProcedureCall();</para>
   <para>plsqlcall.setProcedureName("INSERT_EMP");</para>
   <para>plsqlcall.addNamedInOutputArgument("IN_OUT", OraclePLSQLTypes.PLSQLInteger);</para>
   <para/>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(plsqlcall);</para>
   <para>query.addArgument("IN_OUT");       // input and outpu</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.add(Integer.valueOf(1234));   // department id</para>
   <para/>
   <para>Integer employeeID = new Integer(BigDecimal.intValue(getSession().executeQuery(query, args)));</para>
   <para/>
   <para>
      <anchor id="How_to_Specify_a_Simple_Optimistic_Version_Locking_Value_with_a_StoredProcedureCall_Using_JDBC_Data_Types"/>How to Specify a Simple Optimistic Version Locking Value with a StoredProcedureCall Using JDBC Data Types</para>
   <para>When using optimistic version locking, you typically delegate the responsibility for updating the version field to EclipseLink. </para>
   <para>Alternatively, you may choose to use stored procedures to manually update the version field for all of create, read, update, and delete operations. </para>
   <para>When using optimistic locking and stored procedure calls, you may only use a simple, sequential numeric value that the stored procedure can generate independently of EclipseLink. To use a complex value, such as a timestamp, you must delegate the responsibility for updating the version field to EclipseLink. </para>
   <para>For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_Descriptors_%28ELUG%29">Optimistic Version Locking Policies</ulink>. </para>
   <para>To specify a simple optimistic version locking value with a StoredProcedureCall using JDBC data types: </para>
   <orderedlist>
      <listitem>
         <para>Create stored procedures for create, read, update, and delete operations.Each stored procedure is responsible for checking and updating the optimistic lock field: a simple sequential numeric value in your database. The following example shows a typical stored procedure for the update operation. <anchor id="Example_105-49"/>Stored Procedure for Update Operation Using Simple Optimistic Version Locking </para>
         <para>PROCEDURE Update_Employee (</para>
         <para>    P_EMP_ID NUMBER,</para>
         <para>    P_SALARY NUMBER,</para>
         <para>    P_END_DATE DATE,</para>
         <para>    P_MANAGER_ID NUMBER,</para>
         <para>    P_START_DATE DATE,</para>
         <para>    P_F_NAME VARCHAR2,</para>
         <para>    P_L_NAME VARCHAR2,</para>
         <para>    P_GENDER VARCHAR2,</para>
         <para>    P_ADDR_ID NUMBER,</para>
         <para>    P_VERSION NUMBER,</para>
         <para>    P_START_TIME DATE,</para>
         <para>    P_END_TIME DATE,</para>
         <para>    O_ERROR_CODE OUT NUMBER) AS</para>
         <para>BEGIN </para>
         <para>Update SALARY set SALARY = P_SALARY WHERE (EMP_ID = P_EMP_ID); </para>
         <para>Update EMPLOYEE set END_DATE = P_END_DATE, MANAGER_ID = P_MANAGER_ID, VERSION = P_VERSION + 1, START_DATE = P_START_DATE, F_NAME = P_F_NAME, L_NAME = P_L_NAME, GENDER = P_GENDER, ADDR_ID = P_ADDR_ID where ((EMP_ID = P_EMP_ID) and (VERSION = P_VERSION)); </para>
         <para>O_ERROR_CODE := SQL%ROWCOUNT; </para>
         <para>END;</para>
      </listitem>
      <listitem>
         <para>Create a StoredProcedureCall for each of your custom create, read, update, and delete stored procedures. The following example shows the StoredProcedureCall for the update stored procedure in the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-49">Stored Procedure for Update Operation Using Simple Optimistic Version Locking</ulink>. <anchor id="Example_105-50"/>example. StoredProcedureCall for Update Stored Procedure </para>
         <para>UpdateObjectQuery updateQuery = new UpdateObjectQuery();</para>
         <para>call = new StoredProcedureCall();</para>
         <para>call.setUsesBinding(true);</para>
         <para>call.setProcedureName("Update_Employee");</para>
         <para>call.addNamedArgument("P_EMP_ID", "EMP_ID");</para>
         <para>call.addNamedArgument("P_SALARY", "SALARY");</para>
         <para>call.addNamedArgument("P_END_DATE", "END_DATE");</para>
         <para>call.addNamedArgument("P_MANAGER_ID", "MANAGER_ID");</para>
         <para>call.addNamedArgument("P_START_DATE", "START_DATE");</para>
         <para>call.addNamedArgument("P_F_NAME", "F_NAME");</para>
         <para>call.addNamedArgument("P_L_NAME", "L_NAME");</para>
         <para>call.addNamedArgument("P_GENDER", "GENDER");</para>
         <para>call.addNamedArgument("P_ADDR_ID", "ADDR_ID");</para>
         <para>call.addNamedArgument("P_VERSION", "VERSION");</para>
         <para>call.addNamedArgument("P_START_TIME", "START_TIME");</para>
         <para>call.addNamedArgument("P_END_TIME", "END_TIME");</para>
         <para>call.addNamedOutputArgument("O_ERROR_CODE", "O_ERROR_CODE", Long.class);</para>
         <para>updateQuery.setCall(call);</para>
         <para>For more information, see the following: </para>
      </listitem>
      <listitem>
         <para>Configure the EclipseLink descriptor query manager to use your StoredProcedureCall objects for create, read, update, and delete operations. The following example shows how to use a descriptor customizer class to update the EclipseLink descriptor query manager with the update StoredProcedureCall from the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-50">StoredProcedureCall for Update Stored Procedure</ulink> example. <anchor id="Example_105-51"/>Configuring the EclipseLink Descriptor Query Manager with a StoredProcedureCall </para>
         <para>import org.eclipse.persistence.sessions.factories.DescriptorCustomizer;</para>
         <para>import org.eclipse.persistence.descriptors.ClassDescriptor;</para>
         <para/>
         <para>public class EmployeeDescriptorCustomizer implements DescriptorCustomizer {</para>
         <para/>
         <para>    public void customize(ClassDescriptor descriptor) {</para>
         <para>        descriptor.getQueryManager().setUpdateQuery(updateQuery);</para>
         <para>    }</para>
         <para>}</para>
         <para>For more information, see the following: </para>
      </listitem>
      <listitem>
         <para>Define a StoredProcedureCall output parameter event to handle any errors.In the Oracle database, the rowcount is not maintained when calling a stored procedure. You must ensure that the rowcount is returned using an output parameter. Use the Session event outputParametersDetected to check the rowcount and raise an error. Alternatively, the stored procedure could check the rowcount and throw an exception.For more information, see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#How_to_Configure_a_StoredProcedureCall_Output_Parameter_Event_Using_JDBC_or_PL.2FSQL_Data_Types">How to Configure a StoredProcedureCall Output Parameter Event Using JDBC or PL/SQL Data Types</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="How_to_Configure_a_StoredProcedureCall_Output_Parameter_Event_Using_JDBC_or_PL.2FSQL_Data_Types"/>How to Configure a StoredProcedureCall Output Parameter Event Using JDBC or PL/SQL Data Types</para>
   <para>EclipseLink manages output parameter events for databases that support them. For example, if a stored procedure returns an error code that indicates that the application wants to check for an error condition, EclipseLink raises the session event outputParametersDetected to allow the application to process the output parameters. </para>
   <para>To configure a StoredProcedureCall output parameter event using JDBC or PL/SQL data types: </para>
   <orderedlist>
      <listitem>
         <para>Create a StoredProcedureCall using JDBC arguments, PL/SQL arguments, or both. The <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-55">Stored Procedure</ulink> example shows a StoredProcedureCall using JDBC arguments.For more information, see the following: </para>
         <para>
            <anchor id="Example_105-52"/>Stored Procedure </para>
         <para>PROCEDURE Update_Employee (</para>
         <para>    P_EMP_ID NUMBER,</para>
         <para>    P_SALARY NUMBER,</para>
         <para>    P_END_DATE DATE,</para>
         <para>    P_MANAGER_ID NUMBER,</para>
         <para>    P_START_DATE DATE,</para>
         <para>    P_F_NAME VARCHAR2,</para>
         <para>    P_L_NAME VARCHAR2,</para>
         <para>    P_GENDER VARCHAR2,</para>
         <para>    P_ADDR_ID NUMBER,</para>
         <para>    P_VERSION NUMBER,</para>
         <para>    P_START_TIME DATE,</para>
         <para>    P_END_TIME DATE,</para>
         <para>    O_ERROR_CODE OUT NUMBER) AS</para>
         <para>BEGIN </para>
         <para>Update SALARY set SALARY = P_SALARY WHERE (EMP_ID = P_EMP_ID); </para>
         <para>Update EMPLOYEE set END_DATE = P_END_DATE, MANAGER_ID = P_MANAGER_ID, VERSION = P_VERSION + 1, START_DATE = P_START_DATE, F_NAME = P_F_NAME, L_NAME = P_L_NAME, GENDER = P_GENDER, ADDR_ID = P_ADDR_ID where ((EMP_ID = P_EMP_ID) and (VERSION = P_VERSION)); </para>
         <para>O_ERROR_CODE := SQL%ROWCOUNT; </para>
         <para>END;</para>
      </listitem>
      <listitem>
         <para>Create a SessionEventListener that handles the outputParametersDetected event, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-53">SessionEventListener for outputParametersDetected Event</ulink> example shows. Subclassing the org.eclipse.persistence.sessions.SessionEventAdapter is an easy way to create a SessionEventListener: you only need to override the specific SessionEventListener methods you are interested in. In the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-53">SessionEventListener for outputParametersDetected Event</ulink> example, SessionEvent method getProperty uses an argument value of ERROR_CODE. This property name and its data type is defined in the StoredProcedureCall method addNamedOutputArgument. <anchor id="Example_105-53"/>SessionEventListener for outputParametersDetected Event </para>
         <para>import org.eclipse.persistence.sessions.SessionEventAdapter;</para>
         <para>importorg.eclipse.persistence.sessions.SessionEvent;</para>
         <para/>
         <para>public class OptimisticLockListener extends SessionEventAdapter {</para>
         <para/>
         <para>    public OptimisticLockListener() {}</para>
         <para> </para>
         <para>    public void outputParametersDetected(SessionEvent event) {</para>
         <para>        DatabaseQuery query = event.getQuery();</para>
         <para>        if ((query != null) &amp;&amp; query.isObjectLevelModifyQuery()) {</para>
         <para>            Number rowcount = new Integer(1);</para>
         <para>            if (event.getResult() instanceof Map) {</para>
         <para>                rowcount = (Number)((Map)event.getResult()).get("O_ERROR_CODE");</para>
         <para>            }</para>
         <para>            if (rowcount.longValue() &lt;= 0) {</para>
         <para>                if (query.isDeleteObjectQuery()) {</para>
         <para>                    DeleteObjectQuery deleteQuery = (DeleteObjectQuery)query;</para>
         <para>                    throw OptimisticLockException.objectChangedSinceLastReadWhenDeleting</para>
         <para>                                                  (deleteQuery.getObject(), deleteQuery);</para>
         <para>                } </para>
         <para>                else if (query.isWriteObjectQuery()) {</para>
         <para>                    WriteObjectQuery updateQuery = (WriteObjectQuery)query;</para>
         <para>                    throw OptimisticLockException.objectChangedSinceLastReadWhenUpdating</para>
         <para>                                                  (updateQuery.getObject(), updateQuery);</para>
         <para>                }</para>
         <para>            }</para>
         <para>        }</para>
         <para>    }</para>
         <para>}</para>
      </listitem>
      <listitem>
         <para>Add your SessionEventListener instance to the session event manager, as the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-54">Adding SessionEventListener to the Session Event Manager</ulink> example shows. You must do this step before executing your stored procedure. For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Sessions_%28ELUG%29">Managing Session Events with the Session Event Manager</ulink> 
            <anchor id="Example_105-54"/>Adding SessionEventListener to the Session Event Manager </para>
         <para>getSession().getEventManager().addListener(new OptimisticLockListener());</para>
      </listitem>
      <listitem>
         <para>Execute the query.If there is an error and a SessionEvent of type outputParametersDetected is raised, EclipseLink will notify your SessionEventListener. &lt;/div&gt; </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="What_You_May_Need_to_Know_About_Using_a_StoredProcedureCall"/>What You May Need to Know About Using a StoredProcedureCall</para>
   <para>EclipseLink automatically converts PL/SQL data types into the Java data types that the following table lists for out arguments (and the out value of input/output arguments). </para>
   <para>
      <anchor id="Table_105-1"/>EclipseLink PL/SQL to Java Data Type Conversion: Out Arguments and Out Value of Input/Output Arguments </para>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>
                  <anchor id="r1c1-t14"/>PL/SQL Data Type <anchor id="r1c2-t14"/>
               </para>
            </entry>
            <entry>
               <para>OraclePLSQLTypes Enum <anchor id="r1c3-t14"/>
               </para>
            </entry>
            <entry>
               <para>Java Type <anchor id="r2c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>BINARY_INTEGER </para>
            </entry>
            <entry>
               <para>BinaryInteger </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r3c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>BOOLEAN </para>
            </entry>
            <entry>
               <para>PLSQLBoolean </para>
            </entry>
            <entry>
               <para>java.lang.Integer <anchor id="r4c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>DEC </para>
            </entry>
            <entry>
               <para>Dec </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r5c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>INT </para>
            </entry>
            <entry>
               <para>Int </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r6c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>NATURAL </para>
            </entry>
            <entry>
               <para>Natural </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r7c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>NATURALN </para>
            </entry>
            <entry>
               <para>NaturalN </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r8c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>PLS_INTEGER </para>
            </entry>
            <entry>
               <para>PLSQLInteger </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r9c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>POSITIVE </para>
            </entry>
            <entry>
               <para>Positive </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r10c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>POSITIVEN </para>
            </entry>
            <entry>
               <para>PositiveN </para>
            </entry>
            <entry>
               <para>java.math.BigDecimal <anchor id="r11c1-t14"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>SIGNTYPE </para>
            </entry>
            <entry>
               <para>SignType </para>
            </entry>
            <entry>
               <para>java.lang.Integer </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>You may use the value from any Java type for a PL/SQL in argument (or in value of an input/output argument) as long as the size and precision of the Java type is appropriate for the PL/SQL type. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: You no longer need to use DatabaseQuery method bindAllParameters when using a StoredProcedureCall with OUT or INOUT parameters. However, you should always specify the Java type for all OUT and INOUT parameters. If you do not, be aware of the fact that they default to type String. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>
      <anchor id="Using_a_StoredFunctionCall"/>Using a StoredFunctionCall</para>
   <para>The EclipseLink expression framework enables you to define complex queries at the object level. If your application requires a more complex query or one that invokes an existing stored function that your database provides, you can define a StoredFunctionCall object using both JDBC and PL/SQL data types and invoke the stored function in the context of a DatabaseQuery. </para>
   <para>Note that not all databases provide stored functions. </para>
   <para>In the <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Example_105-56">Creating a StoredFunctionCall</ulink> example, note that the name of the stored function is set using StoredFunctionCall method setProcedureName. </para>
   <para>
      <anchor id="Example_105-56"/>Creating a StoredFunctionCall </para>
   <para>StoredFunctionCall functionCall = new StoredFunctionCall();</para>
   <para>functionCall.setProcedureName("CHECK_VALID_EMPLOYEE");</para>
   <para>functionCall.addNamedArgument("EMP_ID");</para>
   <para>functionCall.setResult("FUNCTION_RESULT", String.class);</para>
   <para>ValueReadQuery query = new ValueReadQuery();</para>
   <para>query.setCall(functionCall);</para>
   <para>query.addArgument("EMP_ID");</para>
   <para>List args = new ArrayList();</para>
   <para>args.addElement(new Integer(44));</para>
   <para>String valid = (String) session.executeQuery(query, args);</para>
   <para/>
   <para>
      <anchor id="What_You_May_Need_to_Know_About_Using_a_StoredFunctionCall"/>What You May Need to Know About Using a StoredFunctionCall</para>
   <para>In general, both stored procedures and stored functions let you specify input parameters, output parameters, and input and output parameters. For more information, see <ulink url="http://wiki.eclipse.org/Using_Basic_Query_API_%28ELUG%29#Using_a_StoredProcedureCall">Using a StoredProcedureCall</ulink>. However, stored procedures need not return values, while stored functions always return a single value. </para>
   <para>The StoredFunctionCall class extends StoredProcedureCall to add one new method - setResult. Use this method to specify the name (and alternatively both the name and type) under which EclipseLink stores the return value of the stored function. </para>
   <para>When EclipseLink prepares a StoredFunctionCall, it validates its SQL and throws a ValidationException under the following circumstances: </para>
   <orderedlist>
      <listitem>
         <para>If your current platform does not support stored functions. Stored functions are supported only for Oracle. </para>
      </listitem>
      <listitem>
         <para>If you fail to specify the return type. </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Using_Java_Persistence_Query_Language_.28JPQL.29_Calls"/>Using Java Persistence Query Language (JPQL) Calls</para>
   <para>Information pending </para>
   <para/>
   <para/>
   <para>
      <anchor id="Using_EIS_Interactions"/>Using EIS Interactions</para>
   <para>For an EIS root descriptor, you can define EIS interactions to invoke methods on an EIS. </para>
   <para>EclipseLink represents EIS interactions using instances of org.eclipse.persistence.eis.interactions.EISInteraction. These classes implement the Call interface and can be used wherever a Call can be used. </para>
   <para>This table lists the type of EIS interactions that EclipseLink supports. </para>
   <para>
      <anchor id="Table_105-2"/>
   </para>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>
                  <anchor id="r1c1-t16"/>EIS Interaction Type <anchor id="r1c2-t16"/>
               </para>
            </entry>
            <entry>
               <para>Description <anchor id="r2c1-t16"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>IndexedInteraction </para>
            </entry>
            <entry>
               <para>Defines the specification for a call to a JCA interaction that uses indexed records. Builds the input and output records from the arguments by position. <anchor id="r3c1-t16"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>MappedInteraction </para>
            </entry>
            <entry>
               <para>Defines the specification for a call to a JCA interaction that uses mapped records. Builds the input and output records from the arguments by name. <anchor id="r4c1-t16"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>XMLInteraction </para>
            </entry>
            <entry>
               <para>Specifies an instance of MappedInteraction that defines the specification for a call to a JCA interaction that uses XML records defined by the XML schema document (XSD) associated with the EIS project (for more information, see <ulink url="http://wiki.eclipse.org/Using_Workbench_%28ELUG%29">How to Import an XML Schema</ulink>). <anchor id="r5c1-t16"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>QueryStringInteraction </para>
            </entry>
            <entry>
               <para>Specifies an instance of MappedInteraction that defines the specification for a call to a JCA interaction that uses a query string. Prefix arguments in the query string with a number sign ( # ) character. <anchor id="r6c1-t16"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>XQueryInteraction </para>
            </entry>
            <entry>
               <para>Specifies an instance of XMLInteraction that defines the specification for a call to a JCA interaction that uses XQuery. Translates the XQuery from the query arguments. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>You can use EclipseLink to define an interaction for each basic persistence operation (insert, update, delete, read object, read all, or does exist) so that when you query and modify your EIS-mapped objects, the EclipseLink runtime will use the appropriate EIS interaction. For more information, see <ulink url="http://wiki.eclipse.org/Configuring_an_EIS_Descriptor_%28ELUG%29">Configuring Custom EIS Interactions for Basic Persistence Operations</ulink>. </para>
   <para>You can also use EclipseLink to define an interaction as a named query for read object and read-all object queries. These queries are not called for basic persistence operations; you can call these additional queries by name in your application for special purposes. For more information, see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Creating an EIS Interaction for a Named Query</ulink>. </para>
   <para/>
   <para>
      <anchor id="Handling_Exceptions"/>Handling Exceptions</para>
   <para>Most exceptions in queries are database exceptions, resulting from a failure in the database operation. Write operations can also throw an OptimisticLockException on a write, update, or delete operation in applications that use optimistic locking. To catch these exceptions, execute all database operations within a try-catch block: </para>
   <para>    try {</para>
   <para>        List employees = session.readAllObjects(Employee.class); </para>
   <para>    } </para>
   <para>    catch (DatabaseException exception) {</para>
   <para>        // handle exception </para>
   <para>    }</para>
   <para>See <ulink url="http://wiki.eclipse.org/EclipseLink_Exception_Error_Reference_%28ELUG%29">EclipseLink Exception Error Reference</ulink> for more information about exceptions in an EclipseLink application. </para>
   <para/>
   <para>
      <anchor id="Handling_Collection_Query_Results"/>Handling Collection Query Results</para>
   <para>EclipseLink provides a useCollectionClass method to all subclasses of DataReadQuery and ReadAllQuery, that you can use to configure a query to return results as any concrete instance of Collection or Map. </para>
   <para>Do not confuse collection query result configuration with a mapping container policy (see <ulink url="http://wiki.eclipse.org/Configuring_a_Mapping_%28ELUG%29">Configuring Container Policy</ulink>): there is no relationship between the two. Collection query result configuration determines how EclipseLink returns multiobject results from a particular query. A mapping container policy tells EclipseLink how your domain object implements a data member that contains a collection. </para>
   <para>For example, consider a class Employee with a data member phoneNumbers. In your implementation of Employee, the getPhoneNumbers method returns a Vector. Using Workbench, you map the phoneNumbers data member as a one-to-many mapping. You configure the mapping container policy so that the mapping contains its value (many PhoneNumber objects) in a Vector. This corresponds to your implementation of Employee. </para>
   <para>You define a ReadAllQuery named localPhoneNumbers on the DescriptorQueryManager of the PhoneNumber. The localPhoneNumbers query takes one argument, the ID of an Employee object, and returns all the phone numbers from its phoneNumbers data member whose area code is 613. </para>
   <para>You get this query by name from the DescriptorQueryManager for PhoneNumber. You call the useCollectionClass method on this ReadAllQuery, passing in the ArrayList class. You execute the query, passing in the ID of an Employee. The query returns all the PhoneNumber objects from the Employee object's phoneNumbers data member whose area code is 613. The query returns these results as an ArrayList. </para>
   <para/>
   <para>
      <anchor id="Handling_Report_Query_Results"/>Handling Report Query Results</para>
   <para>The following table lists the ReportQuery methods you can use to configure how a ReportQuery returns its results. </para>
   <para>By default, the ReportQuery returns a Collection of ReportQueryResult objects. </para>
   <para>
      <anchor id="Table_105-3"/>Report Query Result Options </para>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>
                  <anchor id="r1c1-t17"/>Method <anchor id="r1c2-t17"/>
               </para>
            </entry>
            <entry>
               <para>Query Returns <anchor id="r1c3-t17"/>
               </para>
            </entry>
            <entry>
               <para>Description <anchor id="r2c1-t17"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>setShouldReturnSingleAttribute </para>
            </entry>
            <entry>
               <para>Collection </para>
            </entry>
            <entry>
               <para>Returns a single attribute (not wrapped in a ReportQueryResult). </para>
               <para>Use this option if you know that the ReportQuery returns only one attribute. <anchor id="r3c1-t17"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>setShouldReturnSingleResult </para>
            </entry>
            <entry>
               <para>ReportQueryResult </para>
            </entry>
            <entry>
               <para>Returns only the first ReportQueryResult object (not wrapped in a Collection or Map). </para>
               <para>Use this option if you know that the ReportQuery returns only one row. <anchor id="r4c1-t17"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>setShouldReturnSingleValue </para>
            </entry>
            <entry>
               <para>Object </para>
            </entry>
            <entry>
               <para>Returns only a single value. </para>
               <para>Use this option if you know that the ReportQuery returns only one row that contains only one attribute. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>Advanced Queries</para>
   <para/>
   <para>Using Redirect Queries</para>
   <para>A redirect query is a named query that delegates query execution control to your application. redirect queried allow you to define the query implementation in code as a static method. </para>
   <para>To perform complex operations, you can combine query redirectors with the EclipseLink query framework. </para>
   <para/>
   <para>
      <anchor id="How_to_Create_a_Redirect_Query"/>How to Create a Redirect Query</para>
   <para>To perform complex operations, you can combine query redirectors with the EclipseLink query framework. To create a redirector, implement the org.eclipse.persistence.queries.QueryRedirector interface. The query mechanism executes the Object invokeQuery(DatabaseQuery query, Record arguments, Session session) method and waits for the results. </para>
   <para>EclipseLink provides one preimplemented redirector, the MethodBasedQueryRedirector method. To use this redirector, create a static invoke method on a class, and use the setMethodName(String) call to specify the method to invoke. </para>
   <para>
      <anchor id="Example_107-1"/>Redirect Query </para>
   <para>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</para>
   <para>query.setName("findEmployeeByAnEmployee");</para>
   <para>query.addArgument("employee");</para>
   <para/>
   <para>MethodBaseQueryRedirector redirector = new</para>
   <para>     MethodBaseQueryRedirector(QueryRedirectorTest.class, "findEmployeeByAnEmployee");</para>
   <para>query.setRedirector(redirector);</para>
   <para>Descriptor descriptor = getSession().getDescriptor(query.getReferenceClass());</para>
   <para>descriptor.getQueryManager().addQuery(query.getName(), query);</para>
   <para/>
   <para>List args = new ArrayList();</para>
   <para>args.addElement(employee);</para>
   <para>objectFromDatabase = </para>
   <para>    getSession().executeQuery("findEmployeeByAnEmployee", Employee.class, args);</para>
   <para/>
   <para>public class QueryRedirectorTest {</para>
   <para/>
   <para>    public static Object findEmployeeByAnEmployee(</para>
   <para>                                 DatabaseQuery query,</para>
   <para>                                 org.eclipse.peristence.sessions.Record arguments,</para>
   <para>                                 org.eclipse.peristence.sessions.Session</para>
   <para>                                 session) {</para>
   <para>        ((ReadObjectQuery) query).setSelectionObject(arguments.get("employee"));</para>
   <para>        return session.executeQuery(query);</para>
   <para>    }</para>
   <para>}</para>
   <para/>
   <para>
      <anchor id="Using_Historical_Queries"/>Using Historical Queries</para>
   <para>To make a query time-aware, you specify an AsOfClause that EclipseLink appends to the query. Use the AsOfClause class if your historical schema is based on time stamps or the AsOfSCNClause class if your historical schema is based on database system change numbers. You can specify an AsOfClause at the time you acquire a historical session so that EclipseLink appends the same clause to all queries, or you can specify an AsOfClause on a query-by-query basis. </para>
   <para>The following example shows how to create a query that uses a particular AsOfClause. This query will read all Employee objects as of the time specified by timestamp using the appropriate history tables described by the HistoryPolicy set on the Employee descriptor. </para>
   <para>
      <anchor id="Example_107-2"/>Using a Historical Session </para>
   <para>ReadAllQuery historicalQuery = new ReadAllQuery(Employee.class);</para>
   <para>AsOfClause asOfClause = new AsOfClause(timestamp);</para>
   <para>historicalQuery.setAsOfClause(asOfClause);</para>
   <para>historicalQuery.dontMaintainCache();</para>
   <para>List pastEmployees = (List)historicalSession.executeQuery(historicalQuery);</para>
   <para/>
   <para>
      <anchor id="Using_Queries_with_Fetch_Groups"/>Using Queries with Fetch Groups</para>
   <para>You can use a fetch group with a ReadObjectQuery or ReadAllQuery. When you execute the query, EclipseLink retrieves only the attributes in the fetch group. EclipseLink automatically executes a query to fetch all the attributes excluded from this subset when and if you call a getter method on any one of the excluded attributes. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: When you use fetch groups outside of CMP, use weaving (see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Application_Development_%28ELUG%29">Using Weaving</ulink>). </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <para>This section describes the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Configure_Default_Fetch_Group_Behavior">How to Configure Default Fetch Group Behavior</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Query_with_a_Static_Fetch_Group">How to Query with a Static Fetch Group</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Query_with_a_Dynamic_Fetch_Group">How to Query with a Dynamic Fetch Group</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para>For more information about fetch groups, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29#Fetch_Groups_and_Object-Level_Read_Queries">Fetch Groups and Object-Level Read Queries</ulink>. </para>
   <para/>
   <para>
      <anchor id="How_to_Configure_Default_Fetch_Group_Behavior"/>How to Configure Default Fetch Group Behavior</para>
   <para>You can optionally designate at most one fetch group as the default fetch group for a descriptor's reference class. </para>
   <para>If you execute a ReadObjectQuery or ReadAllQuery without specifying a fetch group, EclipseLink will use the default fetch group unless you configure the query otherwise, as this example shows. </para>
   <para>
      <anchor id="Example_107-3"/>Configuring Default Fetch Group Behavior </para>
   <para>// at the descriptor level</para>
   <para>FetchGroup group = new FetchGroup("nameOnly");</para>
   <para>group.addAttribute("firstName");</para>
   <para>group.addAttribute("lastName");</para>
   <para>employeeDescriptor.getFetchGroupManager().addFetchGroup(group);</para>
   <para>// set the default fetch group</para>
   <para>employeeDescriptor.getFetchGroupManager().setDefaultFetchGroup(group);</para>
   <para/>
   <para>// when query1 is executed, the default fetch group applies</para>
   <para>ReadAllQuery query1 = new ReadAllQuery(Employee.class);</para>
   <para/>
   <para>// when query2 is executed, the default fetch group does not apply</para>
   <para>ReadAllQuery query2 = new ReadAllQuery(Employee.class);</para>
   <para>query2.setShouldUsedefaultFetchGroup(false);</para>
   <para/>
   <para>
      <anchor id="How_to_Query_with_a_Static_Fetch_Group"/>How to Query with a Static Fetch Group</para>
   <para>
      <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#Example_107-4">Configuring a Query with a FetchGroup Using the FetchGroupManager</ulink> shows how to configure a ReadObjectQuery for the Employee class with a FetchGroup named nameOnly previously stored in the FetchGroupManager owned by the Employee class's descriptor. </para>
   <para>
      <anchor id=".27Example_107-4"/>' Configuring a Query with a FetchGroup Using the FetchGroupManager </para>
   <para>In this example, only the Employee attributes firstName and lastName are fetched. If you call the Employee method get for any other attribute, EclipseLink executes another query to retrieve all unfetched attribute values. Thereafter, calling that get method will return the value directly from the object. </para>
   <para/>
   <para>// create static fetch group at the descriptor level</para>
   <para>FetchGroup group = new FetchGroup("nameOnly");</para>
   <para>group.addAttribute("firstName");</para>
   <para>group.addAttribute("lastName");</para>
   <para>descriptor.getFetchGroupManager().addFetchGroup(group);</para>
   <para/>
   <para>// use static fetch group at query level</para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.setFetchGroupName("nameOnly");</para>
   <para/>
   <para>
      <anchor id="How_to_Query_with_a_Dynamic_Fetch_Group"/>How to Query with a Dynamic Fetch Group</para>
   <para>
      <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#Example_107-5">Configuring a Query with a FetchGroup Dynamically</ulink> shows how to create a FetchGroup instance dynamically, at the time you create and execute a query, and configure the query with that FetchGroup directly. </para>
   <para>In this example, only the firstName, lastName, and salary attributes are fetched. If you call the Employee method get for any other attribute, EclipseLink executes another query to retrieve all unfetched attribute values. Thereafter, calling that get method will return the value directly from the object. </para>
   <para>
      <anchor id="Example_107-5"/>Configuring a Query with a FetchGroup Dynamically </para>
   <para/>
   <para>// dynamic fetch group query</para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>FetchGroup group = new FetchGroup("nameAndSalary");</para>
   <para>group.addAttribute("firstName");</para>
   <para>group.addAttribute("lastName");</para>
   <para>group.addAttribute("salary");</para>
   <para>query. setFetchGroup(group);</para>
   <para>
      <anchor id="Using_Read-Only_Queries"/>Using Read-Only Queries</para>
   <para>This example shows how to create an object-level read query to return data that you know is read-only. Using such a query for read-only data can improve performance. </para>
   <para>
      <anchor id="Example_107-6"/>Configuring an ObjectLevelReadQuery as Read-Only </para>
   <para/>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.setIsReadOnly(true);</para>
   <para>For more information, see the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Read-Only Query</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29">How to Use Read-Only Queries for Optimization</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Querying_on_Interfaces"/>Querying on Interfaces</para>
   <para>When you define descriptors for an interface to enable querying, EclipseLink supports querying on an interface, as follows: </para>
   <orderedlist>
      <listitem>
         <para>If there is only a single implementor of the interface, the query returns an instance of the concrete class. </para>
      </listitem>
      <listitem>
         <para>If there are multiple implementors of the interfaces, the query returns instances of all implementing classes. </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="Querying_on_an_Inheritance_Hierarchy"/>Querying on an Inheritance Hierarchy</para>
   <para>When you query on a class that is part of an inheritance hierarchy, the session checks the descriptor to determine the type of the class, as follows: </para>
   <orderedlist>
      <listitem>
         <para>If you configure the descriptor to read subclasses (the default configuration), the query returns instances of the class and its subclasses. </para>
      </listitem>
      <listitem>
         <para>If you configure the descriptor not to read subclasses, the query returns only instances of the queried class, but no instances of the subclasses. </para>
      </listitem>
      <listitem>
         <para>If you configure the descriptor to outer-join subclasses, the query returns instances of the class and its subclasses. </para>
      </listitem>
      <listitem>
         <para>If neither of these conditions applies, the class is a leaf class and does not have any subclasses. The query returns instances of the queried class. </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Appending_Additional_Join_Expressions"/>Appending Additional Join Expressions</para>
   <para>You can set the query manager to automatically append an expression to every query it performs on a class. For example, you can add an expression that filters the database for the valid instances of a given class. </para>
   <para>Use this to do the following: </para>
   <orderedlist>
      <listitem>
         <para>Filter logically deleted objects </para>
      </listitem>
      <listitem>
         <para>Enable two independent classes to share a single table without inheritance </para>
      </listitem>
      <listitem>
         <para>Filter historical versions of objects </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="How_to_Append_Additional_Join_Expressions_Using_Java"/>How to Append Additional Join Expressions Using Java</para>
   <para>Using Java, configure a descriptor with additional join expressions by creating an amendment method (see <ulink url="http://wiki.eclipse.org/Configuring_a_Descriptor_%28ELUG%29">Configuring Amendment Methods</ulink>), and then using the DescriptorQueryManager methods setAdditionalJoinExpression or setMultipleTableJoinExpression, as this example shows. </para>
   <para>
      <anchor id="Example_107-7"/>Registering a Query That Includes a Join Expression </para>
   <para>In this exmaple, the join expression filters invalid instances of employee from the query. </para>
   <para/>
   <para>public static void addToDescriptor(Descriptor descriptor) {</para>
   <para>    ExpressionBuilder builder = new ExpressionBuilder();</para>
   <para>    descriptor.getQueryManager().setAdditionalJoinExpression(</para>
   <para>        (builder.getField("EMP.STATUS").notEqual("DELETED")).and(</para>
   <para>             builder.getField("EMP.STATUS").notEqual("HISTORICAL"))</para>
   <para>    );</para>
   <para>}</para>
   <para/>
   <para>
      <anchor id="Using_Queries_on_Variable_One-to-One_Mappings"/>Using Queries on Variable One-to-One Mappings</para>
   <para>EclipseLink does not provide a method to directly query against variable one-to-one mappings. To query against this type of mapping, combine EclipseLink DirectQueryKeys and EclipseLink ReportQueries to create query selection criteria for classes that implement the interface, as follows: </para>
   <orderedlist>
      <listitem>
         <para>Create two DirectQueryKeys to query for the possible implementors of the interface: </para>
      </listitem>
      <listitem>
         <para>Create a subSelect statement for each concrete class that implements the interface included in the query selection criteria. </para>
      </listitem>
      <listitem>
         <para>Implement a ReportQuery. </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_107-8"/>Creating DirectQueryKeys </para>
   <para>// The DirectQueryKeys as generated in the EclipseLink project Java </para>
   <para>// source code from Workbench </para>
   <para>…</para>
   <para>descriptor.addDirectQueryKey("locationTypeCode","DEALLOCATION.DEALLOCATIONOBJECTTYPE");</para>
   <para>descriptor.addDirectQueryKey("locationTypeId","DEALLOCATION.DEALLOCATIONOBJECTID");     </para>
   <para/>
   <para>
      <anchor id="Using_Oracle_Database_Features"/>Using Oracle Database Features</para>
   <para>If you are using Oracle Database, you can take advantage of EclipseLink support for the following Oracle Database features: </para>
   <orderedlist>
      <listitem>
         <para>Oracle Hints (see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Use_Oracle_Hints">How to Use Oracle Hints</ulink>) </para>
      </listitem>
      <listitem>
         <para>Hierarchical Queries (see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Use_Hierarchical_Queries">How to Use Hierarchical Queries</ulink>) </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="How_to_Use_Oracle_Hints"/>How to Use Oracle Hints</para>
   <para>Oracle Hints is an Oracle Database feature through which you can make decisions usually reserved for the optimizer. You use hints to specify things such as join order for a join statement, or the optimization approach of an SQL call. </para>
   <para>The EclipseLink query framework supports Oracle Hints with the following API: </para>
   <para>setHintString("/*[hints or comments]*/");</para>
   <para> </para>
   <para>EclipseLink adds the hint to the SQL string as a comment immediately following a SELECT, UPDATE, INSERT, or DELETE statement. </para>
   <para>Add hints to a read query as follows: </para>
   <orderedlist>
      <listitem>
         <para>Create a ReadObjectQuery or a ReadAllQuery </para>
      </listitem>
      <listitem>
         <para>Set the selection criteria. </para>
      </listitem>
      <listitem>
         <para>Add hints as needed. </para>
      </listitem>
   </orderedlist>
   <para>For example, the following code uses the FULL hint (which explicitly chooses a full table scan for the specified table): </para>
   <para/>
   <para>// Create the query and set Employee as its reference class</para>
   <para>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</para>
   <para>// Retrieve ExpressionBuilder from the query</para>
   <para>ExpressionBuilder builder = query.getExpressionBuilder();</para>
   <para>query.setSelectionCritera(builder.get("id").equal(new Integer(1));</para>
   <para>// Add the hint</para>
   <para>query.setHintString("/*+ FULL */" ); </para>
   <para/>
   <para>This code generates the following SQL: </para>
   <para>SELECT /*+ FULL */ FROM EMPLOYEE WHERE ID=1</para>
   <para>To add hints to WRITE, INSERT, UPDATE, and DELETE, create custom queries for these operations in the EclipseLink query framework, then specify hints as required. For more information, see the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Configuring_a_Relational_Descriptor_%28ELUG%29">Configuring Custom SQL Queries for Basic Persistence Operations</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Configuring_an_EIS_Descriptor_%28ELUG%29">Configuring Custom EIS Interactions for Basic Persistence Operations</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para>For more information about the available hints, see the Oracle Database documentation. </para>
   <para/>
   <para>
      <anchor id="How_to_Use_Hierarchical_Queries"/>How to Use Hierarchical Queries</para>
   <para>Hierarchical Queries is an Oracle Database mechanism that lets you select database rows based on hierarchical order. For example, you can design a query that reads the row of a given employee, followed by the rows of people this employee manages, followed by their managed employees, and so on. </para>
   <para>To create a hierarchical query, use the setHierarchicalQueryClause method. This method takes three parameters, as follows: </para>
   <para/>
   <para>setHierarchicalQueryClause(startWith, connectBy, orderSibling)</para>
   <para>This expression requires all three parameters, as described in the subsequent text. </para>
   <para/>
   <para>
      <anchor id="Using_startWith_Parameter"/>Using startWith Parameter</para>
   <para>The startWith parameter in the expression specifies the first object in the hierarchy. This parameter mirrors the Oracle Database START WITH clause. </para>
   <para>To include a startWith parameter, build an expression to specify the appropriate object, and pass it as a parameter in the setHierarchicalQueryClause method. If you do not specify the root object for the hierarchy, set this value to null. </para>
   <para/>
   <para>
      <anchor id="Using_connectBy_Parameter"/>Using connectBy Parameter</para>
   <para>The connectBy parameter specifies the relationship that creates the hierarchy. This parameter mirrors the Oracle Database CONNECT BY clause. </para>
   <para>Build an expression to specify the connectBy parameter, and pass it as a parameter in the setHierarchicalQueryClause method. Because this parameter defines the nature of the hierarchy, it is required for the setHierarchicalQueryClause implementation. </para>
   <para/>
   <para>
      <anchor id="Using_orderSibling_Parameter"/>Using orderSibling Parameter</para>
   <para>The orderSibling parameter in the expression specifies the order in which the query returns sibling objects in the hierarchy. This parameter mirrors the Oracle Database ORDER SIBLINGS clause. </para>
   <para>To include an orderSibling parameter, define a vector, and to include the order criteria, use the addElement method. Pass the vector as the third parameter in the setHierarchicalQueryClause method. If you do not specify an order, set this value to null. </para>
   <para>
      <anchor id="Example_107-9"/>Hierarchical Query </para>
   <para>ReadAllQuery raq = new ReadAllQuery(Employee.class);</para>
   <para>// Specifies a START WITH expression</para>
   <para>Expression startExpr = expressionBuilder.get("id").equal(new Integer(1));</para>
   <para>// Specifies a CONNECT BY expression</para>
   <para>Expression connectBy = expressionBuilder.get("managedEmployees");</para>
   <para>// Specifies an ORDER SIBLINGS BY vector</para>
   <para>Vector order = new Vector();</para>
   <para>order.addElement(expressionBuilder.get("lastName"));</para>
   <para>order.addElement(expressionBuilder.get("firstName"));</para>
   <para>raq.setHierarchicalQueryClause(startExpr, connectBy, order);</para>
   <para>Vector employees = uow.executeQuery(raq);</para>
   <para>This code generates the following SQL: </para>
   <para>SELECT * FROM EMPLOYEE START WITH ID=1 CONNECT BY PRIOR ID=MANAGER_ID ORDER SIBLINGS BY LAST_NAME, FIRST_NAME</para>
   <para/>
   <para>
      <anchor id="Handling_Cursor_and_Stream_Query_Results"/>Handling Cursor and Stream Query Results</para>
   <para>Cursors and streams are related mechanisms that let you work with large result sets efficiently. See <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29#Stream_and_Cursor_Query_Results">Stream and Cursor Query Results</ulink> for more information. </para>
   <para>
      <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#Table_107-1">Stream and Cursor Query Result Options</ulink> table lists the methods that EclipseLink provides for all subclasses of DataReadQuery and ReadAllQuery that you can use to make your query return its results as a cursor or stream. </para>
   <para>
      <anchor id="Table_107-1"/>Stream and Cursor Query Result Options </para>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>
                  <anchor id="r1c1-t3"/>Method <anchor id="r1c2-t3"/>
               </para>
            </entry>
            <entry>
               <para>Query Returns <anchor id="r1c3-t3"/>
               </para>
            </entry>
            <entry>
               <para>Description <anchor id="r2c1-t3"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>useScrollableCursor </para>
            </entry>
            <entry>
               <para>ScrollableCursor </para>
            </entry>
            <entry>
               <para>Allows you access a database result set cursor, allowing you to move forward and backward through the result set. <anchor id="r3c1-t3"/>
               </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>useCursoredStream </para>
            </entry>
            <entry>
               <para>CursoredStream </para>
            </entry>
            <entry>
               <para>Allows you to access results one at a time in sequence, as results become available to the underlying database result set cursor. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Using a ScrollableCursor or CursoredStream combines the features of an EclipseLink with the ability of the database to cursor data, and breaks up the result set into smaller, more manageable pieces. </para>
   <para>The behavior of a query that uses a ScrollableCursor or CursoredStream differs from other queries in that the elements requested by the client are sent to the client. </para>
   <para>This section describes the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Handle_Cursors_and_Java_Iterators">How to Handle Cursors and Java Iterators</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Handle_Java_Streams">How to Handle Java Streams</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Optimize_Streams">How to Optimize Streams</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="How_to_Handle_Cursors_and_Java_Iterators"/>How to Handle Cursors and Java Iterators</para>
   <para>The EclipseLink scrollable cursor lets you scroll through a result set from the database without reading the whole result set in a single database read operation. The ScrollableCursor class implements the Java ListIterator interface to allow for direct and relative access within the stream. Scrollable cursors also let you scroll forward and backward through the stream. </para>
   <para/>
   <para>
      <anchor id="Traversing_Data_with_Scrollable_Cursors"/>Traversing Data with Scrollable Cursors</para>
   <para>The following methods let you navigate data with a scrollable cursor: </para>
   <orderedlist>
      <listitem>
         <para>relative(int i): advances the row number in relation to the current row by one row </para>
      </listitem>
      <listitem>
         <para>absolute(int i): places the cursor at an absolute row position, 1 being the first row </para>
      </listitem>
   </orderedlist>
   <para>Several strategies are available for traversing data with cursors. For example, to start at the end of the data set and work toward the first record, do the following: </para>
   <orderedlist>
      <listitem>
         <para>Call the afterLast method to place the cursor after the last row in the result set. </para>
      </listitem>
      <listitem>
         <para>Use the hasPrevious method to determine whether there is a record above the current record. This method returns false when you reach the final record in the data set. </para>
      </listitem>
      <listitem>
         <para>If the hasPrevious method returns true, call the previous method to move the cursor to the row prior to the current row and read that object. </para>
      </listitem>
   </orderedlist>
   <para>These are common methods for data traversal, but they are not the only available methods. For more information about the available methods, see EclipseLink API Reference. </para>
   <para>To use the ScrollableCursor object, the JDBC driver must be compatible with the JDBC 2.0 specifications. </para>
   <para>
      <anchor id="_107-10"/>Example Traversing with a Scrollable Cursor </para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.useScrollableCursor();</para>
   <para>ScrollableCursor cursor = (ScrollableCursor) session.executeQuery(query);</para>
   <para/>
   <para>while (cursor.hasNext()) {</para>
   <para>    System.out.println(cursor.next().toString());</para>
   <para>}</para>
   <para>cursor.close();</para>
   <para/>
   <para>
      <anchor id="How_to_Handle_Java_Streams"/>How to Handle Java Streams</para>
   <para>Java streams let you retrieve query results as individual records or groups of records, which can result in a performance increase. You can use streams to build efficient EclipseLink queries, especially when the queries are likely to generate large result sets. </para>
   <para/>
   <para>
      <anchor id="Using_Cursored_Stream_Support"/>Using Cursored Stream Support</para>
   <para>Cursored streams provide the ability to read back a query result set from the database in manageable subsets, and to scroll through the result set stream. </para>
   <para>The useCursoredStream method of the ReadAllQuery class provides cursored stream support. </para>
   <para>
      <anchor id="Example_107-11"/>Cursored Streams </para>
   <para>CursoredStream stream;</para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.useCursoredStream();</para>
   <para>stream = (CursoredStream) session.executeQuery(query);</para>
   <para>The query returns an instance of CursoredStream rather than a List, which can be a more efficient approach. For example, consider the following two code examples. The <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#Example_107-12">Using a List</ulink> example returns a List that contains all employee objects. If ACME has 10,000 employees, the List contains references to 10,000 Employee objects. </para>
   <para>
      <anchor id="Example_107-12"/>Using a List </para>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>Enumeration employeeEnumeration;</para>
   <para/>
   <para>List employees = (List) session.executeQuery(query);</para>
   <para>employeeEnumeration = employee.elements();</para>
   <para/>
   <para>while (employeeEnumeration.hasMoreElements()) {</para>
   <para>    Employee employee = (Employee) employeeEnumeration.nextElement();</para>
   <para>    employee.doSomeWork();</para>
   <para>}</para>
   <para>The following example returns a CursoredStream instance rather than a List. The CursoredStream collection appears to contain all 10,000 objects, but initially contains a reference to only the first 10 Employee objects. It retrieves the remaining objects in the collection as they are needed. In many cases, the application never needs to read all the objects: </para>
   <para/>
   <para>ReadAllQuery query = new ReadAllQuery(Employee.class);</para>
   <para>query.useCursoredStream();</para>
   <para/>
   <para>CursoredStream stream = (CursoredStream) session.executeQuery(query);</para>
   <para>while (! stream.atEnd()) {</para>
   <para>    Employee employee = (Employee) stream.read();</para>
   <para>    employee.doSomeWork();</para>
   <para>    stream.releasePrevious();</para>
   <para>}</para>
   <para>stream.close();</para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>Note: The releasePrevious message is optional. This releases any previously read objects and frees system memory. Even though released objects are removed from the cursored stream storage, they may remain in the identity map. </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>
      <anchor id="How_to_Optimize_Streams"/>How to Optimize Streams</para>
   <para>To optimize CursoredStream performance, provide a threshold and page size to the useCursoredStream(Threshold, PageSize) method, as follows: </para>
   <orderedlist>
      <listitem>
         <para>The threshold specifies the number of objects to read into the stream initially. The default threshold is 10. </para>
      </listitem>
      <listitem>
         <para>The page size specifies the number of objects to read into the stream after the initial group of objects. This occurs after the threshold number of objects is read. Although larger page sizes result in faster overall performance, they introduce delays into the application when EclipseLink loads each page. The default page size is 5. </para>
      </listitem>
   </orderedlist>
   <para>When you execute a batch-type operation, use the dontMaintainCache method with a cursored stream. A batch operation performs simple operations on large numbers of objects and then discards the objects. Cursored streams create the required objects only as needed, and the dontMaintainCache ensures that these transient objects are not cached. </para>
   <para/>
   <para>
      <anchor id="Handling_Query_Results_Using_Pagination"/>Handling Query Results Using Pagination</para>
   <para>You can configure a query to retrieve a result set in pages, that is, a partial result as a List of pageSize (or less) results. The following example demonstrates paging through the result set of a query using ReadQuery methods setMaxRows and setFirstResult. </para>
   <para>For more information, see the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29#How_to_Use_Result_Set_Pagination_for_Optimization">How to Use Result Set Pagination for Optimization</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Optimizing_the_EclipseLink_Application_%28ELUG%29#How_to_Use_JDBC_Fetch_Size_for_Optimization">How to Use JDBC Fetch Size for Optimization</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para>
      <anchor id="Example_107-13"/>Using setMaxRows and setFirstResult to Page Through a Result Set </para>
   <para>...</para>
   <para>int pageSize = 100;</para>
   <para>int firstResult = 0;</para>
   <para>int maxRows = pageSize;</para>
   <para>boolean hasNext = true;</para>
   <para>List page = null;</para>
   <para/>
   <para>while (hasNext) {</para>
   <para>    query.setFirstResult(firstResult);</para>
   <para>    query.setMaxRows(maxRows);</para>
   <para>    page = (List)sesssion.executeQuery(query);</para>
   <para>    // process this page of results</para>
   <para>    if (page.size() == 0) {</para>
   <para>        hasNext = false;</para>
   <para>    } else {</para>
   <para>        firstResult = firstResult + pageSize;</para>
   <para>        maxRows = maxRows + pageSize;</para>
   <para>    }</para>
   <para>}</para>
   <para>...</para>
   <para>
      <anchor id="Using_Queries_and_the_Cache"/>Using Queries and the Cache</para>
   <para>This section describes how to use caching options in EclipseLink queries, including the following: </para>
   <orderedlist>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Cache_Results_in_a_ReadQuery">How to Cache Results in a ReadQuery</ulink> 
         </para>
      </listitem>
      <listitem>
         <para>
            <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Configure_Cache_Expiration_at_the_Query_Level">How to Configure Cache Expiration at the Query Level</ulink> 
         </para>
      </listitem>
   </orderedlist>
   <para/>
   <para>
      <anchor id="How_to_Cache_Results_in_a_ReadQuery"/>How to Cache Results in a ReadQuery</para>
   <para>By default, each time you execute a ReadQuery, EclipseLink applies the current query configuration to the read operation. In doing so, EclipseLink will access the session cache, the data source, or both. </para>
   <para>Some queries are known to return the same result set (for example, the number of units sold last year by the current sales person). After the first query execution, there is no need to actually execute the query if it is invoked again. </para>
   <para>For these types of queries, you can use any EclipseLink ReadQuery and configure it to store its query results in an internal query cache. </para>
   <para>After its first execution for a set of query parameters, the query will return its cached result set each time it is invoked with the same query parameters. This improves query performance for frequently executed queries. By default a query will cache the results sets for the last 100 queries of specific parameters. You can configure this query cache as part of the QueryResultsCachePolicy. </para>
   <para>Enable this feature using ReadQuery method cacheQueryResults or by calling the ReadQuery method setQueryResultsCachePolicy with an instance of QueryResultsCachePolicy, and disable it using ReadQuery method doNotCacheQueryResults. </para>
   <para>Before using this feature, consider the restrictions in <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">Internal Query Cache Restrictions</ulink>. For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_EclipseLink_Queries_%28ELUG%29">How to Cache Query Results in the Query Cache</ulink>. </para>
   <para>You can apply a cache invalidation policy to the query's internal cache (see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Configure_Cache_Expiration_at_the_Query_Level">How to Configure Cache Expiration at the Query Level</ulink>). For more information, see <ulink url="http://wiki.eclipse.org/Introduction_to_Cache_%28ELUG%29#Cache_Invalidation">Cache Invalidation</ulink>. </para>
   <para>This example shows how to configure a ReadQuery to cache its results. </para>
   <para>
      <anchor id="Example_107-14"/>Configuring a ReadQuery to Cache Its Query Results </para>
   <para>ReadObjectQuery query = new ReadObjectQuery(Employee.class);</para>
   <para/>
   <para>// Instruct the ReadQuery to cache its query results</para>
   <para>query.cacheQueryResults();</para>
   <para/>
   <para>// The first time you invoke it, the ReadQuery reads from the database, session </para>
   <para>// cache, or both and stores the result set in its internal query cache</para>
   <para>Employee employeeFirst = (Employee) session.executeQuery(query);</para>
   <para>The following example shows how to configure the ReadQuery to stop caching its results. The next time the query is executed, EclipseLink does not use the query cache. Instead, the query accesses the data source. </para>
   <para>
      <anchor id="Example_107-15"/>Configuring a ReadQuery to Stop Caching Its Query Results </para>
   <para>// Disable query caching</para>
   <para>query.doNotCacheQueryResults();</para>
   <para/>
   <para>// The ReadQuery does not use the query cahce and instead accesses the database</para>
   <para>Employee employee = (Employee) session.executeQuery(query);</para>
   <para>Alternatively, you can clear the query's internal cache using ReadQuery method clearQueryResults passing in your session. This clears the currently cached results and ensures that the next query execution reads from the database. </para>
   <para/>
   <para>
      <anchor id="How_to_Configure_Cache_Expiration_at_the_Query_Level"/>How to Configure Cache Expiration at the Query Level</para>
   <para>You can configure a ReadQuery with a CacheInvalidationPolicy. </para>
   <para>If you configure a query to cache results in its own internal cache (see <ulink url="http://wiki.eclipse.org/Using_Advanced_Query_API_%28ELUG%29#How_to_Cache_Results_in_a_ReadQuery">How to Cache Results in a ReadQuery</ulink>), the cache invalidation policy allows the cached query result set to expire, based on a time-to-live or daily-expiry. This invalidation time is calculated from the time of the query execution that cached the query result set for the specific set of query parameters. </para>
   <para>The following example shows how to configure a ReadQuery so that a TimeToLiveCacheInvalidationPolicy is applied to all the objects returned by the query and cached in the query's internal cache. </para>
   <para>
      <anchor id="Example_107-16"/>Configuring a CacheInvalidationPolicy on a ReadQuery for the Query's Internal Cache </para>
   <para>// The TimeToLiveCacheInvalidationPolicy applies to all objects returned by the query and</para>
   <para>// cached in the query's internal cache </para>
   <para/>
   <para>readQuery.setQueryResultsCachePolicy(</para>
   <para>    new QueryResultsCachePolicy(new TimeToLiveCacheInvalidationPolicy(1000))</para>
   <para>);</para>
   <para/></sect2></sect1></article>