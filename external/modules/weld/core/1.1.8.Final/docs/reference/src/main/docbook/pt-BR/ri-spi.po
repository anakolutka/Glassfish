# Language pt-BR translations for Introduction_to_Web_Beans package.
# Automatically generated, 2009.
# 
# Bruno Leonardo Gonçalves <brunolmfg@gmail.com>, 2012. #zanata
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2012-01-16T16:07:16\n"
"PO-Revision-Date: 2009-12-19 18:04-0300\n"
"Last-Translator: João Paulo Viragine <joao.viragine@redhat.com>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: \n"

#. Tag: title
#, no-c-format
msgid "Integrating Weld into other environments"
msgstr "Integrando o Weld em outros ambientes"

#. Tag: para
#, no-c-format
msgid ""
"If you want to use Weld in another environment, you will need to provide "
"certain information to Weld via the integration SPI. In this Appendix we "
"will briefly discuss the steps needed."
msgstr ""
"Se você quer usar o Weld em um outro ambiente, você precisará fornecer "
"certas informações ao Weld por meio da integração SPI. neste Apêndice nós "
"discutiremos brevemente os passos necessários."

#. Tag: title
#, no-c-format
msgid "Enterprise Services"
msgstr "Serviços Corporativos"

#. Tag: para
#, no-c-format
msgid ""
"If you just want to use managed beans, and not take advantage of enterprise "
"services (EE resource injection, CDI injection into EE component classes, "
"transactional events, support for CDI services in EJBs) and non-flat "
"deployments, then the generic servlet support provided by the \"Weld: "
"Servlets\" extension will be sufficient, and will work in any container "
"supporting the Servlet API."
msgstr ""
"Se você quer somente utilizar beans gerenciados, e não quer tirar vantagem "
"dos serviços corporativos (injeção de recursos EE, injeção CDI em classes de"
" componente EE, eventos transacionais, suporte a serviços CDI nos EJBs) e "
"implantações non-flat, então o suporte genérico por servlet provido pela "
"extensão \"Weld: Servlets\" será suficiente e funcionará em qualquer "
"contêiner que suporte a Servlet API."

#. Tag: para
#, no-c-format
msgid ""
"All SPIs and APIs described have extensive JavaDoc, which spell out the "
"detailed contract between the container and Weld."
msgstr ""
"Todos SPIs e APIs descritas possuem um extensivo JavaDoc, o qual explicita o"
" contrato detalhado entre o contêiner e o Weld."

#. Tag: title
#, no-c-format
msgid "The Weld SPI"
msgstr "A SPI do Weld"

#. Tag: para
#, no-c-format
msgid ""
"The Weld SPI is located in the <literal>weld-spi</literal> module, and "
"packaged as <literal>weld-spi.jar</literal>. Some SPIs are optional, and "
"should only be implemented if you need to override the default behavior; "
"others are required."
msgstr ""
"A Weld SPI está localizada no módulo <literal>weld-spi</literal>, e "
"empacotado como <literal>weld-spi.jar</literal>. Algumas SPIs são opcionais "
"e deveriam ser implementadas somente se você precisar de substituir o "
"comportamento padrão; outras são obrigatórias."

#. Tag: para
#, no-c-format
msgid ""
"All interfaces in the SPI support the decorator pattern and provide a "
"<literal>Forwarding</literal> class located in the "
"<literal>helpers</literal> sub package. Additional, commonly used, utility "
"classes, and standard implementations are also located in the "
"<literal>helpers</literal> sub package."
msgstr ""
"Todas as interfaces na SPI suportam o padrão decorador e fornecem a classe "
"<literal>Forwarding</literal> localizada no sub-pacote "
"<literal>helpers</literal>. Adicionalmente, as comumente utilizadas classes "
"utilitárias e implementações padrão, também estão localizadas no sub-pacote "
"<literal>helpers</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Weld supports multiple environments. An environment is defined by an "
"implementation of the <literal>Environment</literal> interface. A number of "
"standard environments are built in, and described by the "
"<literal>Environments</literal> enumeration. Different environments require "
"different services to be present (for example a Servlet container doesn't "
"require transaction, EJB or JPA services). By default an EE environment is "
"assumed, but you can adjust the environment by calling "
"<literal>bootstrap.setEnvironment()</literal>."
msgstr ""
"O Weld suporta múltiplos ambientes. Um ambiente é definido por uma "
"implementação da interface <literal>Environment</literal>. Uma série de "
"ambientes padrões já estão embutidos e descritos pela enumeração "
"<literal>Environments</literal>. Os diferentes ambientes requerem diferentes"
" serviços presentes (por exemplo um contêiner Servlet não requer transação, "
"EJB ou serviços JPA). Por padrão um ambiente EE é assumido, mas você pode "
"ajustar o ambiente chamando <literal>bootstrap.setEnvironment()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Weld uses a generic-typed service registry to allow services to be "
"registered. All services implement the <literal>Service</literal> interface."
" The service registry allows services to be added and retrieved."
msgstr ""
"O Weld utiliza um registro de serviço com tipagem genérica para permitir que"
" os serviços sejam registrados. Todos os serviços implementam a interface "
"<literal>Service</literal>. O registro de serviço permite que os serviços "
"sejam acrescentados e recuperados."

#. Tag: title
#, no-c-format
msgid "Deployment structure"
msgstr "Estrutura de implantação"

#. Tag: para
#, no-c-format
msgid ""
"An application is often comprised of a number of modules. For example, a "
"Java EE deployment may contain a number of EJB modules (containing business "
"logic) and war modules (containing the user interface). A container may "
"enforce certain <emphasis>accessibility</emphasis> rules which limit the "
"visibility of classes between modules. CDI allows these same rules to apply "
"to bean and observer method resolution. As the accessibility rules vary "
"between containers, Weld requires the container to "
"<emphasis>describe</emphasis> the deployment structure, via the "
"<literal>Deployment</literal> SPI."
msgstr ""
"Uma aplicação é normalmente composta por uma série de módulos. Por exemplo, "
"uma aplicação Java EE pode conter vários módulos EJB (contendo lógica de "
"negócio) e módulos war (contendo a interface de usuário). Um contêiner pode "
"obrigar certas regras de <emphasis>acessibilidade</emphasis> como limitar a "
"visibilidade de classes entre módulos. CDI permite que estas mesmas regras "
"sejam aplicadas a resolução de beans e métodos observadores. Como as regras "
"de acessibilidade variam entre contêineres, o Weld requer que o contêiner "
"<emphasis>descreva</emphasis> a estrutura de implantação, por meio da SPI "
"<literal>Deployment</literal>."

#. Tag: para
#, no-c-format
msgid ""
"The CDI specification discusses <emphasis>Bean Deployment "
"Archives</emphasis> (BDAs)&mdash;archives which are marked as containing "
"beans which should be deployed to the CDI container, and made available for "
"injection and resolution. Weld reuses this description of <emphasis>Bean "
"Deployment Archives</emphasis> in its deployment structure SPI. Each "
"deployment exposes the BDAs which it contains; each BDA may also reference "
"other which it can access. Together, the transitive closure of this graph "
"forms the beans which are deployed in the application."
msgstr ""
"A especificação CDI aborda os <emphasis>Bean Deployment Archives</emphasis> "
"(BDAs)&mdash;arquivos que são marcados como possuindo beans que devem ser "
"implantados no contêiner CDI, e os tornam disponíveis para injeção e "
"resolução. O Weld reusa esta descrição de <emphasis>Bean Deployment "
"Archives</emphasis> em sua estrutura SPI de implantação. Cada implantaçao "
"expõe os BDAs que ela contém; cada BDA pode também referenciar outros que "
"ele pode acessar. Conjuntamente, o percurso transitivo deste grafo forma os "
"beans que são implantados na aplicação."

#. Tag: para
#, no-c-format
msgid ""
"To describe the deployment structure to Weld, the container should provide "
"an implementation of <literal>Deployment</literal>. "
"<literal>Deployment.getBeanDeploymentArchives()</literal> allows Weld to "
"discover the modules which make up the application. The CDI specification "
"also allows beans to be specified programmatically as part of the bean "
"deployment. These beans may, or may not, be in an existing BDA. For this "
"reason, Weld will call <literal>Deployment.loadBeanDeploymentArchive(Class "
"clazz)</literal> for each programmatically described bean."
msgstr ""
"Para descrever a estrutura de implantação para o Weld, o contêiner deve "
"fornecer uma implementação de <literal>Deployment</literal>. O método "
"<literal>Deployment.getBeanDeploymentArchives()</literal> permite que o Weld"
" descubra os módulos que compõem a aplicação. A especificação CDI também "
"permite que beans sejam especificado programaticamente como parte da "
"implantação do bean. Estes beans podem, ou não, estar em um BDA existente. "
"Por esta razão, o Weld chamará "
"<literal>Deployment.loadBeanDeploymentArchive(Class clazz)</literal> para "
"cada bean descrito programaticamente."

#. Tag: para
#, no-c-format
msgid ""
"As programmatically described beans may result in additional BDAs being "
"added to the graph, Weld will discover the BDA structure every time an "
"unknown BDA is returned by "
"<literal>Deployment.loadBeanDeploymentArchive</literal>."
msgstr ""
"Como os beans programaticamente descritos podem resultar em BDAs adicionais "
"sendo inseridos ao grafo, o Weld descobrirá a estrutura BDA cada vez que um "
"BDA desconhecido for retornado por "
"<literal>Deployment.loadBeanDeploymentArchive</literal>."

#. Tag: title
#, no-c-format
msgid "Virtual BDAs"
msgstr "BDAs Virtuais"

#. Tag: para
#, no-c-format
msgid ""
"In a strict container, each BDA might have to explicitly specify which other"
" BDAs it can access. However many containers will allow an easy mechanism to"
" make BDAs bi-directionally accessible (such as a library directory). In "
"this case, it is allowable (and reasonable) to describe all such archives as"
" a single, 'virtual' <literal>BeanDeploymentArchive</literal>."
msgstr ""
"Em um contêiner rigoroso, cada BDA deve especificar explicitamente quais "
"outros BDAs ele pode acessar. Entretanto, muitos contêineres permitirão um "
"mecanismo fácil para tornar os BDAs bi-direcionalmente acessíveis (como em "
"um diretório de bibliotecas). Neste caso, é admissível (e razoável) "
"descrever todos tais arquivos como um único e 'virtual' "
"<literal>BeanDeploymentArchive</literal>."

#. Tag: para
#, no-c-format
msgid ""
"A container, might, for example, use a flat accessibility structure for the "
"application. In this case, a single <literal>BeanDeploymentArchive</literal>"
" would be attached to the <literal>Deployment</literal>."
msgstr ""
"Um contêiner, pode, por exemplo, usar uma estrutura de acessibilidade rasa "
"para a aplicação. Neste caso, um único "
"<literal>BeanDeploymentArchive</literal> deveria ser anexado ao "
"<literal>Deployment</literal>."

#. Tag: para
#, no-c-format
msgid ""
"<literal>BeanDeploymentArchive</literal> provides three methods which allow "
"it's contents to be discovered by "
"Weld&mdash;<literal>BeanDeploymentArchive.getBeanClasses()</literal> must "
"return all the classes in the BDA, "
"<literal>BeanDeploymentArchive.getBeansXml()</literal> must return a data "
"structure representing the <code>beans.xml</code> deployment descriptor for "
"the archive, and <literal>BeanDeploymentArchive.getEjbs()</literal> must "
"provide an EJB descriptor for every EJB in the BDA, or an empty list if it "
"is not an EJB archive."
msgstr ""
"O <literal>BeanDeploymentArchive</literal> fornece três métodos que permitem"
" que seu conteúdo seja descoberto pelo "
"Weld&mdash;<literal>BeanDeploymentArchive.getBeanClasses()</literal> deve "
"retornar todas as classes no BDA, "
"<literal>BeanDeploymentArchive.getBeansXml()</literal> deve retornar uma "
"estrutura de dados representando o descritor <code>beans.xml</code> de "
"implantação para o archive, e "
"<literal>BeanDeploymentArchive.getEjbs()</literal> deve fornecer um "
"descritor EJB para cada EJB no BDA, ou uma lista vazia se ele não for um "
"arquivo EJB."

#. Tag: para
#, no-c-format
msgid ""
"To aid container integrator, Weld provides a built-in <code>beans.xml</code>"
" parser. To parse a <code>beans.xml</code> into the data-structure required "
"by <code>BeanDeploymentArchive</code>, the container should call "
"<code>Bootstrap.parseBeansXml(URL)</code>. Weld can also parse multiple "
"<code>beans.xml</code> files, merging them to become a single data-"
"structure. This can be achieved by calling "
"<code>Bootstrap.parseBeansXml(Iterable&lt;URL&gt;)</code>."
msgstr ""
"Para auxiliar o integrador do contêiner, o Weld fornece um parser do "
"<code>beans.xml</code> embutido. Para analisar um <code>beans.xml</code> "
"para a estrutura de dados requerida pelo <code>BeanDeploymentArchive</code>,"
" o contêiner deve chamar <code>Bootstrap.parseBeansXml(URL)</code>. O Weld "
"também pode analisar vários arquivos <code>beans.xml</code>, mesclando-os "
"para se tornar uma única estrutura de dados. Isto pode ser realizado "
"chamando <code>Bootstrap.parseBeansXml(Iterable&lt;URL&gt;)</code>."

#. Tag: para
#, no-c-format
msgid ""
"BDA X may also reference another BDA Y whose beans can be resolved by, and "
"injected into, any bean in BDA X. These are the accessible BDAs, and every "
"BDA that is directly accessible by BDA X should be returned. A BDA will also"
" have BDAs which are accessible transitively, and the transitive closure of "
"the sub-graph of BDA X describes all the beans resolvable by BDA X."
msgstr ""
"Um BDA X também pode referenciar um outro BDA Y cujos beans podem ser "
"resolvidos e injetados dentro de qualquer bean em BDA X. Estes são os BDAs "
"acessíveis, e todo BDA que é diretamente acessível pelo BDA X deve ser "
"retornado. Um BDA também terá BDAs que são transitivamente acessíveis, e o "
"percurso transitivo do sub-grafo de BDA X descreve todos os beans "
"resolvíveis pelo BDA X."

#. Tag: title
#, no-c-format
msgid "Matching the classloader structure for the deployment"
msgstr "Correspondendo a estrutura do classloader com a implantação"

#. Tag: para
#, no-c-format
msgid ""
"In practice, you can regard the deployment structure represented by "
"<literal>Deployment</literal>, and the virtual BDA graph as a mirror of the "
"classloader structure for a deployment. If a class can from BDA X can be "
"loaded by another in BDA Y, it is accessible, and therefore BDA Y's "
"accessible BDAs should include BDA X."
msgstr ""
"Na prática, você pode respeitar a estrutura de implantação representada por "
"<literal>Deployment</literal>, e o grafo virtual de BDAs será como um "
"espelho da estrutura do classloader para uma implantação. Se uma classe pode"
" a partir do BDA X ser carregada por outro no BDA Y, ele é acessível, e "
"portanto os BDAs acessíveis do BDA Y deve incluir o BDA X."

#. Tag: para
#, no-c-format
msgid ""
"To specify the directly accessible BDAs, the container should provide an "
"implementation of "
"<literal>BeanDeploymentArchive.getBeanDeploymentArchives()</literal>."
msgstr ""
"Para especificar os BDAs diretamente acessíveis, o contêiner deve fornecer "
"uma implementação de "
"<literal>BeanDeploymentArchive.getBeanDeploymentArchives()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Weld allows the container to describe a circular graph, and will convert a "
"graph to a tree as part of the deployment process."
msgstr ""
"O Weld permite ao contêiner descrever um grafo circular e converter um grafo"
" para uma árvore como parte do processo de implantação."

#. Tag: para
#, no-c-format
msgid ""
"Certain services are provided for the whole deployment, whilst some are "
"provided per-BDA. BDA services are provided using "
"<literal>BeanDeploymentArchive.getServices()</literal> and only apply to the"
" BDA on which they are provided."
msgstr ""
"Certos serviços são fornecidos para a implantação inteira, embora alguns "
"sejam providos por-BDA. Os serviços BDA são fornecidos utilizando "
"<literal>BeanDeploymentArchive.getServices()</literal> e somente aplicados "
"aos BDAs que eles são providos."

#. Tag: para
#, no-c-format
msgid ""
"The contract for <code>Deployment</code> requires the container to specify "
"the portable extensions (see chapter 12 of the CDI specification) which "
"should be loaded by the application. To aid the container integrator, Weld "
"provides the method <code>Bootstrap.loadExtensions(ClassLoader)</code> which"
" will load the extensions for the specified classloader."
msgstr ""
"O contrato de <code>Deployment</code> requer ao contêiner especificar as "
"extensões portáveis (veja o capítulo 12 da especificação CDI) que deveriam "
"ser carregadas pela aplicação. Para auxiliar o integrador do contêiner, o "
"Weld fornece o método <code>Bootstrap.loadExtensions(ClassLoader)</code> que"
" carregará as extensões para o classloader especificado."

#. Tag: title
#, no-c-format
msgid "EJB descriptors"
msgstr "Descritores EJB"

#. Tag: para
#, no-c-format
msgid ""
"Weld delegates EJB 3 bean discovery to the container so that it doesn't "
"duplicate the work done by the EJB container, and respects any vendor-"
"extensions to the EJB definition."
msgstr ""
"O Weld delega a descoberta de beans do EJB 3 ao contêiner, uma vez que ele "
"não duplica o trabalho feito pelo contêiner EJB e respeita qualquer extensão"
" do fornecedor para a definição de EJB."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>EjbDescriptor</literal> should return the relevant metadata as "
"defined in the EJB specification. Each business interface of a session bean "
"should be described using a <literal>BusinessInterfaceDescriptor</literal>."
msgstr ""
"O <literal>EjbDescriptor</literal> deve retornar os metadados relevantes "
"conforme definido na especificação EJB. Cada interface de negócio de um "
"session bean deve ser descrita usando um "
"<literal>BusinessInterfaceDescriptor</literal>."

#. Tag: title
#, no-c-format
msgid "EE resource injection and resolution services"
msgstr "Injeção de recursos EE e serviços de resolução"

#. Tag: para
#, no-c-format
msgid ""
"All the EE resource services are per-BDA services, and may be provided using"
" one of two methods. Which method to use is at the discretion of the "
"integrator."
msgstr ""
"Todos os serviços de recursos EE são serviços por-BDA, e podem ser providos "
"utilizando um de dois métodos. Qual método utilizar está a critério do "
"integrador."

#. Tag: para
#, no-c-format
msgid ""
"The integrator may choose to provide all EE resource injection services "
"themselves, using another library or framework. In this case the integrator "
"should use the <literal>EE</literal> environment, and implement the <xref "
"linkend=\"injection.services\" /> SPI."
msgstr ""
"O integrador pode escolher fornecer todos os serviços de injeção de recursos"
" EE usando outra biblioteca ou framework. Neste caso o integrador deve usar "
"o ambiente <literal>EE</literal> e implementar a SPI na <xref "
"linkend=\"injection.services\" />."

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, the integrator may choose to use CDI to provide EE resource "
"injection. In this case, the <literal>EE_INJECT</literal> environment should"
" be used, and the integrator should implement the <xref "
"linkend=\"ejb.services.resolution\" />, <xref linkend=\"resource.services\" "
"/> and <xref linkend=\"jpa.services\" />."
msgstr ""
"Alternativamente, o integrador pode escolher utilizar CDI para prover "
"injeção de recursos EE. Neste caso, o ambiente <literal>EE_INJECT</literal> "
"deve ser utilizado e o integrador deve implementar <xref "
"linkend=\"ejb.services.resolution\" />, <xref linkend=\"resource.services\" "
"/> e <xref linkend=\"jpa.services\" />."

#. Tag: para
#, no-c-format
msgid ""
"CDI only provides annotation-based EE resource injection; if you wish to "
"provide deployment descriptor (e.g. <literal>ejb-jar.xml</literal>) "
"injection, you must use <xref linkend=\"injection.services\" />."
msgstr ""
"CDI somente fornece injeção de recursos EE baseado em anotações; se você "
"deseja prover injeção do descritor de implantação (i.e. <literal>ejb-"
"jar.xml</literal>), você deve usar <xref linkend=\"injection.services\" />."

#. Tag: para
#, no-c-format
msgid ""
"If the container performs EE resource injection, the injected resources must"
" be serializable. If EE resource injection is provided by Weld, the resolved"
" resource must be serializable."
msgstr ""
"Se o contêiner realiza injeção de recursos EE, os recursos injetados devem "
"ser serializáveis. Se a injeção de recursos EE for fornecida pelo Weld, o "
"recurso resolvido deve ser serializável."

#. Tag: para
#, no-c-format
msgid ""
"If you use a non-EE environment then you may implement any of the EE service"
" SPIs, and Weld will provide the associated functionality. There is no need "
"to implement those services you don't need!"
msgstr ""
"Se você usa um ambiente não-EE, então você pode implementar qualquer uma das"
" SPIs de serviço EE, e o Weld proverá a funcionalidade associada. Não existe"
" necessidade de implementar aqueles serviços que você não utilizará!"

#. Tag: title
#, no-c-format
msgid "EJB services"
msgstr "Serviços EJB"

#. Tag: para
#, no-c-format
msgid "EJB services are split between two interfaces which are both per-BDA."
msgstr ""
"Os serviços EJB são separados em duas interfaces que são ambas por-BDA."

#. Tag: para
#, no-c-format
msgid ""
"<literal>EJBServices</literal> is used to resolve local EJBs used to back "
"session beans, and must always be provided in an EE environment. "
"<literal>EJBServices.resolveEjb(EjbDescriptor ejbDescriptor)</literal> "
"returns a "
"wrapper&mdash;<literal>SessionObjectReference</literal>&mdash;around the EJB"
" reference. This wrapper allows Weld to request a reference that implements "
"the given business interface, and, in the case of SFSBs, both request the "
"removal of the EJB from the container and query whether the EJB has been "
"previously removed."
msgstr ""
"<literal>EJBServices</literal> é utilizado para resolver EJBs locais usados "
"para apoiar session beans e sempre deve ser fornecido em um ambiente EE. "
"<literal>EJBServices.resolveEjb(EjbDescriptor ejbDescriptor)</literal> "
"retornar um "
"envólucro&mdash;<literal>SessionObjectReference</literal>&mdash;sobre a "
"referência do EJB. Este envólucro permite que o Weld solicite um referência "
"que implementa uma dada interface de negócio, e, no caso de SFSBs, também "
"solicitar a remoção do EJB do contêiner e consultar se o EJB tinha sido "
"anteriormente removido."

#. Tag: para
#, no-c-format
msgid ""
"<literal>EJBResolutionServices.resolveEjb(InjectionPoint ij)</literal> "
"allows the resolution of <literal>@EJB</literal> (for injection into managed"
" beans). This service is not required if the implementation of <xref "
"linkend=\"injection.services\" /> takes care of <literal>@EJB</literal> "
"injection."
msgstr ""
"<literal>EJBResolutionServices.resolveEjb(InjectionPoint ij)</literal> "
"permite a resolução de <literal>@EJB</literal> (para injeção dentro de "
"managed beans). Este serviço não é necessário se a implementação de <xref "
"linkend=\"injection.services\" /> tomar conta da injeção de "
"<literal>@EJB</literal>."

#. Tag: title
#, no-c-format
msgid "JPA services"
msgstr "Serviços JPA"

#. Tag: para
#, no-c-format
msgid ""
"Just as EJB resolution is delegated to the container, resolution of "
"<literal>@PersistenceContext</literal> for injection into managed beans "
"(with the <literal>InjectionPoint</literal> provided), is delegated to the "
"container."
msgstr ""
"Assim como a resolução de EJB é delegada ao contêiner, a resolução de "
"<literal>@PersistenceContext</literal> para injeção dentro dos beans "
"gerenciados (com o <literal>InjectionPoint</literal> fornecido) é delegada "
"ao contêiner."

#. Tag: para
#, no-c-format
msgid ""
"To allow JPA integration, the <literal>JpaServices</literal> interface "
"should be implemented. This service is not required if the implementation of"
" <xref linkend=\"injection.services\" /> takes care of "
"<literal>@PersistenceContext</literal> injection."
msgstr ""
"Para permitir integração com JPA, a interface <literal>JpaServices</literal>"
" deve ser implementada. Este serviço não é requirido se a implementação de "
"<xref linkend=\"injection.services\" /> tomar conta da injeção de "
"<literal>@PersistenceContext</literal>."

#. Tag: title
#, no-c-format
msgid "Transaction Services"
msgstr "Servicos de transação"

#. Tag: para
#, no-c-format
msgid ""
"Weld delegates JTA activities to the container. The SPI provides a couple "
"hooks to easily achieve this with the <literal>TransactionServices</literal>"
" interface."
msgstr ""
"O Weld delega as atividades JTA para o contêiner. A SPI fornece vários "
"ganchos para facilmente conseguir isso com a interface "
"<literal>TransactionServices</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Any <literal>javax.transaction.Synchronization</literal> implementation may "
"be passed to the <literal>registerSynchronization()</literal> method and the"
" SPI implementation should immediately register the synchronization with the"
" JTA transaction manager used for the EJBs."
msgstr ""
"Qualquer implementação de "
"<literal>javax.transaction.Synchronization</literal> pode ser passada para o"
" método <literal>registerSynchronization()</literal> e a implementação SPI "
"deve registrar imediatamente a sincronização com o gerenciador de transação "
"JTA usado pelos EJBs."

#. Tag: para
#, no-c-format
msgid ""
"To make it easier to determine whether or not a transaction is currently "
"active for the requesting thread, the "
"<literal>isTransactionActive()</literal> method can be used. The SPI "
"implementation should query the same JTA transaction manager used for the "
"EJBs."
msgstr ""
"Para tornar mais fácil determinar se uma transação está ou não atualmente "
"ativa para a thread solicitante, o método "
"<literal>isTransactionActive()</literal> pode ser usado. A implementação SPI"
" deve consultar o mesmo gerenciador de transação JTA usado pelos EJBs."

#. Tag: title
#, no-c-format
msgid "Resource Services"
msgstr "Serviços de Recursos"

#. Tag: para
#, no-c-format
msgid ""
"The resolution of <literal>@Resource</literal> (for injection into managed "
"beans) is delegated to the container. You must provide an implementation of "
"<literal>ResourceServices</literal> which provides these operations. This "
"service is not required if the implementation of <xref "
"linkend=\"injection.services\" /> takes care of <literal>@Resource</literal>"
" injection."
msgstr ""
"A resolução de <literal>@Resource</literal> (para injeção dentro de managed "
"beans) é delegada ao contêiner. Você deve prover uma implementação de "
"<literal>ResourceServices</literal> o qual fornece estas operações. Este "
"serviço não é necessário se a implementação de <xref "
"linkend=\"injection.services\" /> tomar conta da injeção de "
"<literal>@Resource</literal>."

#. Tag: title
#, no-c-format
msgid "Injection Services"
msgstr "Serviços de Injeção"

#. Tag: para
#, no-c-format
msgid ""
"An integrator may wish to use <literal>InjectionServices</literal> to "
"provide additional field or method injection over-and-above that provided by"
" Weld. An integration into a Java EE environment may use "
"<literal>InjectionServices</literal> to provide EE resource injection for "
"managed beans."
msgstr ""
"Um integrador pode desejar usar <literal>InjectionServices</literal> para "
"fornecer injeção por campo ou método melhor do que o fornecido pelo Weld. "
"Uma integração em um ambiente Java EE pode utilizar "
"<literal>InjectionServices</literal> para prover injeção de recursos EE para"
" beans gerenciados."

#. Tag: para
#, no-c-format
msgid ""
"<literal>InjectionServices</literal> provides a very simple contract, the "
"<literal>InjectionServices.aroundInject(InjectionContext ic);</literal> "
"interceptor will be called for every instance that CDI injects, whether it "
"is a contextual instance, or a non-contextual instance injected by "
"<literal>InjectionTarget.inject()</literal>."
msgstr ""
"<literal>InjectionServices</literal> fornece um contrato muito simples, o "
"interceptador <literal>InjectionServices.aroundInject(InjectionContext "
"ic);</literal> será chamado para cada instância que CDI injeta, se for uma "
"instância contextual, ou não-contextual injetada por "
"<literal>InjectionTarget.inject()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>InjectionContext</literal> can be used to discover additional "
"information about the injection being performed, including the "
"<literal>target</literal> being injected. <literal>ic.proceed()</literal> "
"should be called to perform CDI-style injection, and call initializer "
"methods."
msgstr ""
"O <literal>InjectionContext</literal> pode ser usado para descobrir "
"informações adicionais sobre a injeção sendo realizada, incluindo o "
"<literal>target</literal> sendo injetado. <literal>ic.proceed()</literal> "
"deve ser chamado para realizar injeção no estilo CDI e chama os métodos "
"inicializadores."

#. Tag: title
#, no-c-format
msgid "Security Services"
msgstr "Serviços de Segurança"

#. Tag: para
#, no-c-format
msgid ""
"In order to obtain the <literal>Principal</literal> representing the current"
" caller identity, the container should provide an implementation of "
"<literal>SecurityServices</literal>."
msgstr ""
"No intuito de obter um <literal>Principal</literal> representando a "
"identidade do requisitante atual, o contêiner deve fornecer uma "
"implementação de <literal>SecurityServices</literal>."

#. Tag: title
#, no-c-format
msgid "Bean Validation Services"
msgstr "Serviços da Bean Validation"

#. Tag: para
#, no-c-format
msgid ""
"In order to obtain the default <literal>ValidatorFactory</literal> for the "
"application deployment, the container should provide an implementation of "
"<literal>ValidationServices</literal>."
msgstr ""
"A fim de se obter o <literal>ValidatorFactory</literal> padrão para a "
"implantação da aplicação, o contêiner deve fornecer uma implementação de "
"<literal>ValidationServices</literal>."

#. Tag: title
#, no-c-format
msgid "Identifying the BDA being addressed"
msgstr "Identificando o BDA sendo endereçado"

#. Tag: para
#, no-c-format
msgid ""
"When a client makes a request to an application which uses Weld, the request"
" may be addressed at any of the BDAs in the application deployment. To allow"
" Weld to correctly service the request, it needs to know which BDA the "
"request is addressed at. Where possible, Weld will provide some context, but"
" use of these by the integrator is optional."
msgstr ""
"Quando um cliente faz uma requisição a uma aplicação que utiliza o Weld, a "
"requisição pode ser endereçada a qualquer dos BDAs na aplicação. Para "
"permitir que o Weld sirva corretamente a requisição, ele precisa saber qual "
"BDA a requisição está endereçada. Onde possível, o Weld fornecerá algum "
"contexto, mas o uso deste pelo integrador é opcional."

#. Tag: para
#, no-c-format
msgid ""
"Most Servlet contains use a classloader-per-war, this may provide a good way"
" to identify the BDA in use for web requests."
msgstr ""
"A maioria das Servlet usam um classloader por war, isto pode prover um bom "
"meio para identificar o BDA em uso pelas requisições web."

#. Tag: para
#, no-c-format
msgid ""
"When Weld needs to identify the BDA, it will use one of these services, "
"depending on what is servicing the request:"
msgstr ""
"Quando o Weld precisa identificar o BDA, ele usará um destes serviços, "
"dependendo do que está servindo a requisição:"

#. Tag: term
#, no-c-format
msgid ""
"<literal>ServletServices.getBeanDeploymentArchive(ServletContext "
"ctx)</literal>"
msgstr ""
"<literal>ServletServices.getBeanDeploymentArchive(ServletContext "
"ctx)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Identify the war in use. The <literal>ServletContext</literal> is provided "
"for additional context."
msgstr ""
"Identificar o war em uso. O <literal>ServletContext</literal> é fornecido "
"por contexto adicional."

#. Tag: title
#, no-c-format
msgid "The bean store"
msgstr "O armazenador de beans"

#. Tag: para
#, no-c-format
msgid ""
"Weld uses a map like structure to store bean instances - "
"<literal>org.jboss.weld.context.api.BeanStore</literal>. You may find "
"<literal>org.jboss.weld.context.api.helpers.ConcurrentHashMapBeanStore</literal>"
" useful."
msgstr ""
"O Weld utiliza um mapa como estrutura para armazenar instâncias de beans - "
"<literal>org.jboss.weld.context.api.BeanStore</literal>. Você pode achar "
"<literal>org.jboss.weld.context.api.helpers.ConcurrentHashMapBeanStore</literal>"
" útil."

#. Tag: title
#, no-c-format
msgid "The application context"
msgstr "O contexto de aplicação"

#. Tag: para
#, no-c-format
msgid ""
"Weld expects the Application Server or other container to provide the "
"storage for each application's context. The "
"<literal>org.jboss.weld.context.api.BeanStore</literal> should be "
"implemented to provide an application scoped storage."
msgstr ""
"O Weld espera que o Servidor de Aplicação ou outro contêiner forneça o "
"armazenamento para cada contexto da aplicação. O "
"<literal>org.jboss.weld.context.api.BeanStore</literal> deve ser "
"implementado para prover um armazenamento em escopo de aplicação."

#. Tag: title
#, no-c-format
msgid "Initialization and shutdown"
msgstr "Inicialização e Encerramento"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>org.jboss.weld.bootstrap.api.Bootstrap</literal> interface "
"defines the initialization for Weld, bean deployment and bean validation. To"
" boot Weld, you must create an instance of "
"<literal>org.jboss.weld.bootstrap.WeldBeansBootstrap</literal> (which "
"implements <literal>Boostrap</literal>), tell it about the services in use, "
"and then request the container start."
msgstr ""
"A interface <literal>org.jboss.weld.bootstrap.api.Bootstrap</literal> define"
" a inicialização para o Weld, a implantação e validação de beans. Para "
"iniciar o Weld, você deve criar uma instância de "
"<literal>org.jboss.weld.bootstrap.WeldBeansBootstrap</literal> (que "
"implementa <literal>Boostrap</literal>), indicar quais serviços usará, e "
"então solicitar que o contêiner inicie."

#. Tag: para
#, no-c-format
msgid ""
"The bootstrap is split into phases, container initialization, bean "
"deployment, bean validation and shutdown. Initialization will create a "
"manager, and add the built-in contexts, and examine the deployment "
"structure. Bean deployment will deploy any beans (defined using annotations,"
" programmatically, or built in). Bean validation will validate all beans."
msgstr ""
"Toda a inicialização é separada em fases, a inicialização do contêiner, "
"implantação dos beans, validação dos beans, e desligamento. A inicialização "
"criará um gerenciador, adicionará os contextos embutidos e examinará a "
"estrutura de implantação. A implantação de beans implantará todos os beans "
"(definidos usando anotações, programaticamente ou embutidos). A validação de"
" beans validará todos os beans."

#. Tag: para
#, no-c-format
msgid ""
"To initialize the container, you call "
"<literal>Bootstrap.startInitialization()</literal>. Before calling "
"<literal>startInitialization()</literal>, you must register any services "
"required by the environment. You can do this by calling, for example, "
"<literal>bootstrap.getServices().add(JpaServices.class, new "
"MyJpaServices())</literal>. You must also provide the application context "
"bean store."
msgstr ""
"Para inicializar o contêiner, você chama "
"<literal>Bootstrap.startInitialization()</literal>. Antes de chamar "
"<literal>startInitialization()</literal>, você deve registrar todos os "
"serviços requeridos pelo ambiente. Você pode fazer isto chamando, por "
"exemplo, <literal>bootstrap.getServices().add(JpaServices.class, new "
"MyJpaServices())</literal>. Você também deve fornecer o armazenador de beans"
" do contexto da aplicação."

#. Tag: para
#, no-c-format
msgid ""
"Having called <literal>startInitialization()</literal>, the "
"<literal>Manager</literal> for each BDA can be obtained by calling "
"<literal>Bootstrap.getManager(BeanDeploymentArchive bda)</literal>."
msgstr ""
"Tendo chamado <literal>startInitialization()</literal>, o "
"<literal>Manager</literal> de cada BDA pode ser obtido chamando "
"<literal>Bootstrap.getManager(BeanDeploymentArchive bda)</literal>."

#. Tag: para
#, no-c-format
msgid ""
"To deploy the discovered beans, call "
"<literal>Bootstrap.deployBeans()</literal>."
msgstr ""
"Para implantar os beans descobertos, chame "
"<literal>Bootstrap.deployBeans()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"To validate the deployed beans, call "
"<literal>Bootstrap.validateBeans()</literal>."
msgstr ""
"Para validar os beans implantados, chame "
"<literal>Bootstrap.validateBeans()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"To place the container into a state where it can service requests, call "
"<literal>Bootstrap.endInitialization()</literal>"
msgstr ""
"Para colocar o contêiner em um estado onde ele pode servir requisições, "
"chame <literal>Bootstrap.endInitialization()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"To shutdown the container you call <literal>Bootstrap.shutdown()</literal>. "
"This allows the container to perform any cleanup operations needed."
msgstr ""
"Para encerrar o contêiner você chama "
"<literal>Bootstrap.shutdown()</literal>. Isto permite que o contêiner "
"realize qualquer operação de limpeza necessária."

#. Tag: title
#, no-c-format
msgid "Resource loading"
msgstr "Carregando recursos"

#. Tag: para
#, no-c-format
msgid ""
"Weld needs to load classes and resources from the classpath at various "
"times. By default, they are loaded from the Thread Context ClassLoader if "
"available, if not the same classloader that was used to load Weld, however "
"this may not be correct for some environments. If this is case, you can "
"implement <literal>org.jboss.weld.spi.ResourceLoader</literal>."
msgstr ""
"O Weld precisa carregar classes e recursos a partir do classpath em vários "
"momentos. Por padrão, eles são carregados a partir do ClassLoader do "
"contexto da Thread se disponível, se não o mesmo classloader que foi usado "
"para carregar o Weld, entretanto este pode não ser o correto para alguns "
"embientes. Se este é caso, você pode implementar "
"<literal>org.jboss.weld.spi.ResourceLoader</literal>."

#. Tag: title
#, no-c-format
msgid "The contract with the container"
msgstr "O contrato com o container"

#. Tag: para
#, no-c-format
msgid ""
"There are a number of requirements that Weld places on the container for "
"correct functioning that fall outside implementation of APIs."
msgstr ""
"Existe uma série de requisitos que o Weld coloca sobre o contêiner para o "
"correto funcionamento que não se enquadram na implementação de APIs."

#. Tag: term
#, no-c-format
msgid "Classloader isolation"
msgstr "Isolamento de Classloader (Classloader isolation)"

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into an environment that supports deployment of "
"multiple applications, you must enable, automatically, or through user "
"configuration, classloader isolation for each CDI application."
msgstr ""
"Se você está integrando o Weld em um ambiente que suporta implantação de "
"várias aplicações, você de deve habilitar, automaticamente ou por "
"configuração, o isolamento do classloader para cada aplicação CDI."

#. Tag: term
#, no-c-format
msgid "Servlet"
msgstr "Servlet"

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into a Servlet environment you must register "
"<literal>org.jboss.weld.servlet.WeldListener</literal> as a Servlet "
"listener, either automatically, or through user configuration, for each CDI "
"application which uses Servlet."
msgstr ""
"Se você esta integrando o Weld em um ambiente Servlet você deve registrar "
"<literal>org.jboss.weld.servlet.WeldListener</literal> como um Servlet "
"listener, seja automaticamente ou por configuração, para cada aplicação CDI "
"que utiliza Servlet."

#. Tag: para
#, no-c-format
msgid ""
"You must ensure that <literal>WeldListener.contextInitialized()</literal> is"
" called after beans are deployed is complete "
"(<literal>Bootstrap.deployBeans()</literal> has been called)."
msgstr ""
"Você deve assegurar que <literal>WeldListener.contextInitialized()</literal>"
" seja chamada depois dos beans serem completamente implantados (garantir que"
" <literal>Bootstrap.deployBeans()</literal> tenha sido chamado)."

#. Tag: term
#, no-c-format
msgid "JSF"
msgstr "JSF"

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must register "
"<literal>org.jboss.weld.jsf.WeldPhaseListener</literal> as a phase listener."
msgstr ""
"Se você está integrando o Weld em um ambiente JSF você deve registrar "
"<literal>org.jboss.weld.jsf.WeldPhaseListener</literal> como um phase "
"listener."

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must register "
"<literal>org.jboss.weld.el.WeldELContextListener</literal> as an EL Context "
"listener."
msgstr ""
"Se você etá integrando o Weld em um ambiente JSF você deve registrar "
"<literal>org.jboss.weld.el.WeldELContextListener</literal> como um "
"<emphasis>listener</emphasis> do contexto EL."

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must register "
"<literal>org.jboss.weld.jsf.ConversationAwareViewHandler</literal> as a "
"delegating view handler."
msgstr ""
"Se você está integrando o Weld em um ambiente JSF você deve registrar "
"<literal>org.jboss.weld.jsf.ConversationAwareViewHandler</literal> como um "
"manipulador de visão delegante."

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must obtain the bean "
"manager for the module and then call "
"<literal>BeanManager.wrapExpressionFactory()</literal>, passing "
"<literal>Application.getExpressionFactory()</literal> as the argument. The "
"wrapped expression factory must be used in all EL expression evaluations "
"performed by JSF in this web application."
msgstr ""
"Se você está integrando o Weld em um ambiente JSF você deve obter o "
"gerenciador de beans para o módulo e então chamar "
"<literal>BeanManager.wrapExpressionFactory()</literal>, passando "
"<literal>Application.getExpressionFactory()</literal> como argumento. A "
"fábrica de expressão envolvida deve ser usada em todas as avaliações de "
"expressões EL realizadas por JSF nesta aplicação web."

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must obtain the bean "
"manager for the module and then call "
"<literal>BeanManager.getELResolver()</literal>, The returned EL resolver "
"should be registered with JSF for this web application."
msgstr ""
"Se você está integrando o Weld em um ambiente JSF você precisa obter o "
"gerenciador de beans para o módulo e então chamar "
"<literal>BeanManager.getELResolver()</literal>. O EL resolver retornado deve"
" ser registrado com o JSF para esta aplicação web."

#. Tag: para
#, no-c-format
msgid ""
"There are a number of ways you can obtain the bean manager for the module. "
"You could call <literal>Bootstrap.getManager()</literal>, passing in the BDA"
" for this module. Alternatively, you could use the injection into Java EE "
"component classes, or look up the bean manager in JNDI."
msgstr ""
"Existem uma série de meios que você pode obter o gerenciador de beans para o"
" módulo. Você poderia chamar <literal>Bootstrap.getManager()</literal>, "
"passando o BDA deste módulo. Alternativamente, você poderia usar a injeção "
"em classes de componentes Java EE, ou pesquisar o gerenciador de beans em "
"JNDI."

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must register "
"<literal>org.jboss.weld.servlet.ConversationPropagationFilter</literal> as a"
" Servlet listener, either automatically, or through user configuration, for "
"each CDI application which uses JSF. This filter can be registered for all "
"Servlet deployment safely."
msgstr ""
"Se você está integrando o Weld em um ambiente JSF você deve registrar "
"<literal>org.jboss.weld.servlet.ConversationPropagationFilter</literal> como"
" um Servlet listener, seja automaticamente ou por configuração, para cada "
"aplicação CDI que utiliza JSF. Este filtro pode ser registrado em qualquer "
"implantações Servlet sem problemas."

#. Tag: para
#, no-c-format
msgid "Weld only supports JSF 1.2 and above."
msgstr "Weld somente suporta JSF 1.2 e versões posteriores."

#. Tag: term
#, no-c-format
msgid "JSP"
msgstr "JSP"

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into a JSP environment you must register "
"<literal>org.jboss.weld.el.WeldELContextListener</literal> as an EL Context "
"listener."
msgstr ""
"Se você está integrando o Weld em um ambiente JSP você deve registrar "
"<literal>org.jboss.weld.el.WeldELContextListener</literal> como um listener "
"do contexto EL."

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into a JSP environment you must obtain the bean "
"manager for the module and then call "
"<literal>BeanManager.wrapExpressionFactory()</literal>, passing "
"<literal>Application.getExpressionFactory()</literal> as the argument. The "
"wrapped expression factory must be used in all EL expression evaluations "
"performed by JSP."
msgstr ""
"Se você está integrando o Weld em um ambiente JSP você deve obter o "
"gerenciador de beans para o módulo e então chamar "
"<literal>BeanManager.wrapExpressionFactory()</literal>, passando "
"<literal>Application.getExpressionFactory()</literal> como argumento. A "
"fábrica de expressão envolvida deve ser usada em todas as avaliações de "
"expressões EL realizadas por JSP."

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into a JSP environment you must obtain the bean "
"manager for the module and then call "
"<literal>BeanManager.getELResolver()</literal>, The returned EL resolver "
"should be registered with JSP for this web application."
msgstr ""
"Se você está integrando o Weld em um ambiente JSP você deve obter o "
"gerenciador de beans para o módulo e então chamar "
"<literal>BeanManager.getELResolver()</literal>. O EL resolver retornado deve"
" ser registrado no JSP para esta aplicação web."

#. Tag: term
#, no-c-format
msgid "Session Bean Interceptor"
msgstr "Interceptador de Session Bean"

#. Tag: para
#, no-c-format
msgid ""
"If you are integrating Weld into an EJB environment you must register the "
"<literal>aroundInvoke</literal> method of "
"<literal>org.jboss.weld.ejb.SessionBeanInterceptor</literal> as a EJB "
"around-invoke interceptor for all EJBs in the application, either "
"automatically, or through user configuration, for each CDI application which"
" uses enterprise beans. If you are running in a EJB 3.1 environment, you "
"should register this as an around-timeout interceptor as well."
msgstr ""
"Se você está integrando o Weld em um ambiente EJB você deve registrar o "
"método <literal>aroundInvoke</literal> de "
"<literal>org.jboss.weld.ejb.SessionBeanInterceptor</literal> como um "
"interceptador EJB around-invoke para todos EJBs na aplicação, seja "
"automaticamente ou por configuração, para cada aplicação CDI que utiliza "
"beans corporativos. Se você está rodando em um ambiente EJB 3.1, você deve "
"registrar este como um interceptador around-timeout também."

#. Tag: para
#, no-c-format
msgid ""
"You must register the <literal>SessionBeanInterceptor</literal> as the inner"
" most interceptor in the stack for all EJBs."
msgstr ""
"Você deve registrar o <literal>SessionBeanInterceptor</literal> como o "
"interceptador mais interno na pilha para todos EJBs."

#. Tag: term
#, no-c-format
msgid "The <literal>weld-core.jar</literal>"
msgstr "O <literal>weld-core.jar</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Weld can reside on an isolated classloader, or on a shared classloader. If "
"you choose to use an isolated classloader, the default "
"<literal>SingletonProvider</literal>, "
"<literal>IsolatedStaticSingletonProvider</literal>, can be used. If you "
"choose to use a shared classloader, then you will need to choose another "
"strategy."
msgstr ""
"O Weld pode residir dentro de um classloader isolado ou em um classloader "
"compartilhado. Se você escolher utilizar um classloader isolado, o padrão "
"<literal>SingletonProvider</literal>, "
"<literal>IsolatedStaticSingletonProvider</literal>, pode ser usado. Se você "
"escolher utilizar um classloader compartilhado, então você precisará "
"escolher outra estratégia."

#. Tag: para
#, no-c-format
msgid ""
"You can provide your own implementation of <literal>Singleton</literal> and "
"<literal>SingletonProvider</literal> and register it for use using "
"<literal>SingletonProvider.initialize(SingletonProvider provider)</literal>."
msgstr ""
"Você pode fornecer sua própria implementação de <literal>Singleton</literal>"
" e <literal>SingletonProvider</literal> e registrá-la utilizando "
"<literal>SingletonProvider.initialize(SingletonProvider provider)</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Weld also provides an implementation of Thread Context Classloader per "
"application strategy, via the <literal>TCCLSingletonProvider</literal>."
msgstr ""
"O Weld também fornece uma implementação da estratégia por aplicação com "
"Thread Context Classloader, por meio de "
"<literal>TCCLSingletonProvider</literal>."

#. Tag: term
#, no-c-format
msgid "Binding the manager in JNDI"
msgstr "Vinculando o gerenciador em JNDI"

#. Tag: para
#, no-c-format
msgid ""
"You should bind the bean manager for the bean deployment archive into JNDI "
"at <literal>java:comp/BeanManager</literal>. The type should be "
"<literal>javax.enterprise.inject.spi.BeanManager</literal>. To obtain the "
"correct bean manager for the bean deployment archive, you may call "
"<literal>bootstrap.getBeanManager(beanDeploymentArchive)</literal>"
msgstr ""
"Você deveria vincular o gerenciador de beans ao arquivo de implantação de "
"beans dentro de JNDI em <literal>java:comp/BeanManager</literal>. O tipo "
"deve ser <literal>javax.enterprise.inject.spi.BeanManager</literal>. Para "
"obter o gerenciador de beans correto para o arquivo de implantação de beans,"
" você pode chamar "
"<literal>bootstrap.getBeanManager(beanDeploymentArchive)</literal>."

#. Tag: term
#, no-c-format
msgid "Performing CDI injection on Java EE component classes"
msgstr "Realizando injeção CDI em classes de componente Java EE"

#. Tag: para
#, no-c-format
msgid ""
"The CDI specification requires the container to provide injection into non-"
"contextual resources for all Java EE component classes. Weld delegates this "
"responsibility to the container. This can be achieved using the CDI defined "
"<literal>InjectionTarget</literal> SPI. Furthermore, you must perform this "
"operation on the correct bean manager for the bean deployment archive "
"containing the EE component class."
msgstr ""
"A especificação CDI requer que o contêiner forneça injeção dentro de "
"recursos não-contextuais para todas classes de componentes Java EE. O Weld "
"delega esta responsabilidade ao contêiner. Isto pode ser alcançado "
"utilizando o SPI de CDI <literal>InjectionTarget</literal> já definido. Além"
" disso, você deve realizar esta operação sobre o gerenciador de beans "
"correto para o arquivo de implantação de beans que contenha a classe de "
"componente EE."

#. Tag: para
#, no-c-format
msgid ""
"The CDI specification also requires that a "
"<literal>ProcessInjectionTarget</literal> event is fired for every Java EE "
"component class. Furthermore, if an observer calls "
"<literal>ProcessInjectionTarget.setInjectionTarget()</literal> the container"
" must use <emphasis>the specified</emphasis> injection target to perform "
"injection."
msgstr ""
"A especificação CDI também requer que um evento "
"<literal>ProcessInjectionTarget</literal> seja disparado para cada classe de"
" componente Java EE. Além disso, se um observador chamar "
"<literal>ProcessInjectionTarget.setInjectionTarget()</literal> o contêiner "
"deve usar o alvo de injeção <emphasis>especificado</emphasis> para realizar "
"a injeção."

#. Tag: para
#, no-c-format
msgid ""
"To help the integrator, Weld provides "
"<literal>WeldManager.fireProcessInjectionTarget()</literal> which returns "
"the <literal>InjectionTarget</literal> to use."
msgstr ""
"Para ajudar o integrador, o Weld fornece o método "
"<literal>WeldManager.fireProcessInjectionTarget()</literal>, o qual retorna "
"o <literal>InjectionTarget</literal> a ser utilizado."

#. Tag: programlisting
#, no-c-format
msgid ""
"// Fire ProcessInjectionTarget, returning the InjectionTarget\n"
"// to use\n"
"InjectionTarget it = weldBeanManager.fireProcessInjectionTarget(clazz);\n"
"\n"
"// Per instance required, create the creational context\n"
"CreationalContext&lt;?&gt; cc = beanManager.createCreationalContext(null);\n"
"\n"
"// Produce the instance, performing any constructor injection required\n"
"Object instance = it.produce();\n"
"\n"
"// Perform injection and call initializers\n"
"it.inject(instance, cc);\n"
"\n"
"// Call the post-construct callback\n"
"it.postConstruct(instance);\n"
"\n"
"// Call the pre-destroy callback\n"
"it.preDestroy(instance);\n"
"\n"
"// Clean up the instance\n"
"it.dispose();\n"
"cc.release();"
msgstr ""
"// Dispara ProcessInjectionTarget, retornando o InjectionTarget\n"
"// a utilizar\n"
"InjectionTarget it = weldBeanManager.fireProcessInjectionTarget(clazz);\n"
"\n"
"// Requerido por instância, cria o contexto de criação\n"
"CreationalContext&lt;?&gt; cc = beanManager.createCreationalContext(null);\n"
"\n"
"// Produz a instância, realizando qualquer injeção de construtor\n"
"Object instance = it.produce();\n"
"\n"
"// Realiza injeção e chama os inicializadores\n"
"it.inject(instance, cc);\n"
"\n"
"// Chama o método post-construct\n"
"it.postConstruct(instance);\n"
"\n"
"// Chama o método pre-destroy\n"
"it.preDestroy(instance);\n"
"\n"
"// Limpa a instância\n"
"it.dispose();\n"
"cc.release();"

#. Tag: para
#, no-c-format
msgid ""
"The container may intersperse other operations between these calls. Further,"
" the integrator may choose to implement any of these calls in another "
"manner, assuming the contract is fulfilled."
msgstr ""
"O contêiner pode intercalar outras operações entre estas chamadas. Além "
"disso, o integrador pode escolher implementar qualquer dessas chamadas de "
"uma outra maneira, assumindo que o contrato seja cumprido."

#. Tag: para
#, no-c-format
msgid ""
"When performing injections on EJBs you must use the Weld-defined SPI, "
"<literal>WeldManager</literal>. Furthermore, you must perform this operation"
" on the correct bean manager for the bean deployment archive containing the "
"EJB."
msgstr ""
"Ao realizar injeções em EJBs você deve utilizar o SPI definido pelo Weld, "
"<literal>WeldManager</literal>. Além disso, você deve realizar esta operação"
" sobre o gerenciador de beans correto para o arquivo de implantação de beans"
" que contenha o EJB."

#. Tag: programlisting
#, no-c-format
msgid ""
"// Obtain the EjbDescriptor for the EJB\n"
"// You may choose to use this utility method to get the descriptor\n"
"EjbDescriptor&lt;?&gt; ejbDescriptor = beanManager.getEjbDescriptor(ejbName);\n"
"\n"
"// Get an the Bean object\n"
"Bean&lt;?&gt; bean = beanManager.getBean(ejbDescriptor);\n"
"\n"
"// Create the injection target\n"
"InjectionTarget it = deploymentBeanManager.createInjectionTarget(ejbDescriptor);\n"
"\n"
"// Per instance required, create the creational context\n"
"CreationalContext&lt;?&gt; cc = deploymentBeanManager.createCreationalContext(bean);\n"
"\n"
"// Perform injection and call initializers\n"
"it.inject(instance, cc);\n"
"\n"
"// You may choose to have CDI call the post construct and pre destroy\n"
"// lifecycle callbacks\n"
"\n"
"// Call the post-construct callback\n"
"it.postConstruct(instance);\n"
"\n"
"// Call the pre-destroy callback\n"
"it.preDestroy(instance);\n"
"\n"
"// Clean up the instance\n"
"it.dispose();\n"
"cc.release();"
msgstr ""
"// Obtém o EjbDescriptor para o EJB\n"
"// Você pode escolher usar este método utilitário para pegar o descritor\n"
"EjbDescriptor&lt;?&gt; ejbDescriptor = beanManager.getEjbDescriptor(ejbName);\n"
"\n"
"// Obtém um objeto Bean\n"
"Bean&lt;?&gt; bean = beanManager.getBean(ejbDescriptor);\n"
"\n"
"// Cria o alvo da injeção\n"
"InjectionTarget it = deploymentBeanManager.createInjectionTarget(ejbDescriptor);\n"
"\n"
"// Requerido por instância, cria o contexto de criação\n"
"CreationalContext&lt;?&gt; cc = deploymentBeanManager.createCreationalContext(bean);\n"
"\n"
"// Realiza a injeção e chama os inicializadores\n"
"it.inject(instance, cc);\n"
"\n"
"// Você pode escolher se CDI chama os callbacks pós-construção e pré-destruição\n"
"// do ciclo de vida\n"
"\n"
"// Chama o método post-construct\n"
"it.postConstruct(instance);\n"
"\n"
"// Chama o método pre-destroy\n"
"it.preDestroy(instance);\n"
"\n"
"// Limpa a instância\n"
"it.dispose();\n"
"cc.release();"
