#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2012 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#
#
# This file incorporates work covered by the following copyright and
# permission notice:
#
# Copyright 2004 The Apache Software Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# Message IDs reserved for this file: PWC6600-PWC6624
#
object.invalidScope=PWC6600: N\u00E3o \u00E9 poss\u00EDvel usar este objeto fora do m\u00E9todo de servi\u00E7o de um servlet ou fora do m\u00E9todo doFilter de um filtro

#
# Message IDs reserved for this file: PWC3980-PWC4209
#
coyoteConnector.alreadyInitialized=PWC3980: O conector j\u00E1 foi inicializado
coyoteConnector.alreadyStarted=PWC3981: O conector j\u00E1 foi inicializado
coyoteConnector.cannotRegisterProtocol=PWC3982: N\u00E3o \u00E9 poss\u00EDvel registrar MBean para o Protocolo
coyoteConnector.notStarted=PWC3983: O conector Coyote ainda n\u00E3o foi inicializado
coyoteConnector.protocolHandlerDestroyFailed=PWC3984: Destrui\u00E7\u00E3o do handler de protocolo falhou: {0}
coyoteConnector.protocolHandlerInitializationFailed=PWC3985: Inicializa\u00E7\u00E3o do handler de protocolo falhou: {0}
coyoteConnector.protocolHandlerInstantiationFailed=PWC3986: Instancia\u00E7\u00E3o do handler de protocolo falhou: {0}
coyoteConnector.protocolHandlerStartFailed=PWC3987: In\u00EDcio do handler de protocolo falhou: {0}
coyoteConnector.protocolRegistrationFailed=PWC3988: O registro JMX de protocolo falhou
coyoteConnector.illegalAdapter=PWC4015: mod_jk - implementa\u00E7\u00E3o de Adaptador inv\u00E1lida: {0} 
coyoteAdapter.service=PWC3989: Ocorreu uma exce\u00E7\u00E3o ou erro no cont\u00EAiner durante o processamento da solicita\u00E7\u00E3o
coyoteResponse.getOutputStream.ise=PWC3990: getWriter() j\u00E1 foi chamado para esta resposta
coyoteResponse.getWriter.ise=PWC3991: getOutputStream() j\u00E1 foi chamado para esta resposta
coyoteResponse.resetBuffer.ise=PWC3992: N\u00E3o \u00E9 poss\u00EDvel redefinir o buffer depois que a resposta j\u00E1 foi submetida a commit
coyoteResponse.sendError.ise=PWC3993: N\u00E3o \u00E9 poss\u00EDvel chamar sendError() depois que a resposta j\u00E1 foi submetida a commit
coyoteResponse.sendRedirect.ise=PWC3994: N\u00E3o \u00E9 poss\u00EDvel chamar sendRedirect() depois que a resposta j\u00E1 foi submetida a commit
coyoteResponse.setBufferSize.ise=PWC3995: N\u00E3o \u00E9 poss\u00EDvel alterar o tamanho do buffer depois que os dados s\u00E3o gravados
responseFacade.nullResponse=PWC3996: Objeto de resposta nulo
coyoteRequest.getInputStream.ise=PWC3997: getReader() j\u00E1 foi chamado para esta solicita\u00E7\u00E3o
coyoteRequest.getReader.ise=PWC3998: getInputStream() j\u00E1 foi chamado para esta solicita\u00E7\u00E3o
coyoteRequest.sessionCreateCommitted=PWC3999: N\u00E3o \u00E9 poss\u00EDvel criar uma sess\u00E3o depois que a resposta j\u00E1 foi submetida a commit
coyoteRequest.setAttribute.namenull=PCW4000: N\u00E3o \u00E9 poss\u00EDvel chamar setAttribute com um nome nulo
coyoteRequest.listenerStart=PWC4001: Exce\u00E7\u00E3o ao enviar evento inicializado de contexto \u00E0 inst\u00E2ncia do listener da classe {0}
coyoteRequest.listenerStop=PWC4002: Exce\u00E7\u00E3o ao enviar evento destru\u00EDdo de contexto \u00E0 inst\u00E2ncia do listener da classe {0}
coyoteRequest.attributeEvent=PWC4003: Exce\u00E7\u00E3o gerada pelo listener de eventos de atributos
coyoteRequest.postTooLarge=PWC4004: Os par\u00E2metros n\u00E3o tiveram parsing porque o tamanho dos dados postados era muito grande. Utilize o atributo maxPostSize do conector para resolver isso se a aplica\u00E7\u00E3o tiver de aceitar POSTs grandes.
requestFacade.nullRequest=PWC4005: N\u00E3o \u00E9 poss\u00EDvel solicitar o objeto fora do escopo de servi\u00E7o de um servlet ou fora do m\u00E9todo doFilter de um filtro
coyoteAdapter.proxyAuthCertError=PWC4009: Erro ao efetuar parsing da cadeia de certificados do cliente no array de inst\u00E2ncia de java.security.cert.X509Certificate
coyoteAdapter.listenerOff=PWC4010: Listener HTTP na porta {0} foi desativado
#no ID on coyoteAdapter.noHost as it is sent to client
coyoteAdapter.noHost=Nenhum Host corresponde ao nome do servidor {0}
coyoteRequest.setCharacterEncoding.ise=PWC4011: N\u00E3o \u00E9 poss\u00EDvel definir a codifica\u00E7\u00E3o de caracteres para {0} a partir do contexto {1}, pois os par\u00E2metros da solicita\u00E7\u00E3o j\u00E1 foram lidos, ou ServletRequest.getReader() j\u00E1 foi chamado
coyoteRequest.unknownHost=PWC4012: N\u00E3o \u00E9 poss\u00EDvel resolver o endere\u00E7o IP {0} no nome do host
coyoteRequest.nullRemoteAddressFromProxy=PWC4013: N\u00E3o \u00E9 poss\u00EDvel determinar o endere\u00E7o remoto do cliente a partir do proxy (retorna nulo)
object.invalidScope=PWC4014: N\u00E3o \u00E9 poss\u00EDvel usar este objeto fora do m\u00E9todo de servi\u00E7o de um servlet ou fora do m\u00E9todo doFilter de um filtro
inputBuffer.streamClosed=PWC4015: Fluxo fechado
coyoteRequest.sendfileNotCanonical=PWC4016: N\u00E3o \u00E9 poss\u00EDvel determinar o nome can\u00F4nico do arquivo [{0}] especificado com sendfile
coyoteRequest.multipart.not.configured=PWC4017: A solicita\u00E7\u00E3o {0} foi chamada sem configura\u00E7\u00E3o de multiparte. Adicione uma @MultipartConfig ao servlet ou um elemento multipart-config a web.xml
inputBuffer.alreadysetReadListener=PWC4018: O ReadListener j\u00E1 foi definido.
outputBuffer.alreadysetWriteListener=PWC4019: O WriteListener j\u00E1 foi definido.
coyoteRequest.changeSessionId.ise=PWC4020: changeSessionId foi chamado sem uma sess\u00E3o
coyoteReader.readline.skipFailure=PWC4021: Falha ao ignorar {0} caracteres no buffer subjacente do CoyoteReader em readLine().

#
# Messages related to async processing mode
#
async.dispatchInProgress=Dispatch ass\u00EDncrono j\u00E1 est\u00E1 em andamento; chame ServletRequest.startAsync primeiro
async.addListenerIllegalState=AsyncContext.addListener n\u00E3o deve ser chamado ap\u00F3s o dispatch iniciado pelo cont\u00EAiner durante o qual ServletRequest.startAsync ter sido chamado e retornado ao cont\u00EAiner
async.setTimeoutIllegalState=AsyncContext.setTimeout n\u00E3o deve ser chamado ap\u00F3s o dispatch iniciado pelo cont\u00EAiner durante o qual ServletRequest.startAsync ter sido chamado e retornado ao cont\u00EAiner
async.listenerInvocationError=Erro ao chamar AsyncListener
request.notInAsyncMode=A solicita\u00E7\u00E3o n\u00E3o foi colocado no modo ass\u00EDncrono; ServletRequest.startAsync deve ser chamado primeiro
request.startAsync.notSupported=A solicita\u00E7\u00E3o est\u00E1 dentro do escopo de um filtro, ou o servlet n\u00E3o suporta opera\u00E7\u00F5es ass\u00EDncronas
request.startAsync.alreadyCalled=ServletRequest.startAsync chamado novamente sem dispatch ass\u00EDncrono, chamado fora do escopo desse dispatch ou chamado novamente dentro escopo do mesmo dispatch
request.startAsync.alreadyComplete=Resposta j\u00E1 fechada
request.startAsync.notInScope=ServletRequest.startAsync chamada fora do escopo de um dispatch ass\u00EDncrono
request.asyncComplete.alreadyComplete=Solicita\u00E7\u00E3o j\u00E1 foi liberada do modo ass\u00EDncrono
