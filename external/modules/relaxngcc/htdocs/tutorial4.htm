<html>
<head>
	<title>RelaxNGCC <?ja?>チュートリアル４<?/ja?><?en?>Tutorial 4<?/en?></title>
	<link rel="stylesheet" href="ngcc.css">
<!--	<?ja?><meta HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=shift_jis"><?/ja?>-->
</head>
<body>
<h1>RelaxNGCC <?ja?>チュートリアル４<?/ja?><?en?>Tutorial 4<?/en?></h1>
<div align=right>
	$Revision: 1.2 $ by <a href="mailto:kk@kohsuke.org">Kohsuke Kawaguchi</a>
</div>

<p>
	In the previous tutorial, we saw how RelaxNGCC can make it a snap to build AST out of a RELAX NG grammar. The main drawback there was the beauty of the generated code. Hey, it's a machine-generated code. What would you expect?
</p><p>
	In this tutorial, you'll learn how RelaxNGCC can be used to develop AST with the quality equvalent to hand-written ones.
</p>


<h2>Combining hand-written code with machine-generated code</h2>
<p>
	The technique we pursue in this tutorial is to combine hand-written code with code generated by RelaxNGCC; you write the object model by yourself, then you use RelaxNGCC to build a parser that reads XML documents and compose an AST from those objects.
</p><p>
	Obviously this approach needs you to write more code, but it has the following advantages:
</p>
<ol>
	<li>The interface you'll expose will be as good as you can write. It won't have any single ugly internal method exposed. You can write nice javadoc comments as well.
	<li>You can design a fairly complicated inheritance relationship among your AST node.
	<li>If you already have AST code, then you can write a parser that builds that AST.
	<li>People who use your exposed interface won't even notice that you are using RelaxNGCC.
	<li>Since RelaxNGCC uses SAX, it is more memory-efficient. More importantly, you can access line number information, which is quite useful to produce human-readble messages.
</ol>

<p>
	To illustrate the difference in the beauty of the exposed interfaces, we use the same schema as in the previous tutorial again.
</p>


<h2>Hand-code Your Object Model</h2>
<p>
	First, we design our AST. We'll have <tt>Folder</tt> and <tt>File</tt>. Since those two are common in being an object of a file system, we also introduce the <tt>FileSystemObject</tt> as the base class.
</p>
<pre>
public abstract class FileSystemObject {
    protected FileSystemObject( String _name ) {
        this.name = _name;
    }
    
    private String name;
    
    public String getName() { return name; }
}
</pre>
<p>
	At this base class, we only define the name. Then we define
	<tt>File</tt> and <tt>Folder</tt>.
</p>
<pre>
public final class File extends FileSystemObject {
    public File( String name ) {
        super(name);
    }
    
    /**
     * blah blah blah
     *
     * @return something useful
     */
    public InputStream open() {
        ....
    }
    
    // other methods that you define
    .....
}

public final class Folder extends FileSystemObject {
    public Folder( String name ) {
        super(name);
    }
    
    // files and sub-folders inside this folder.
    private final Map items = new Hashtable();
    
    public void add( FileSystemObject fso ) {
        items.put(fso.getName(),fso);
    }
    
    public FileSystemObject get( String name ) {
        return (FileSystemObject)items.get(name);
    }
    
    .....
}
</pre>



<h2>Use RelaxNGCC to write a parser</h2>
<p>
	Once you define your object model and define how it can be constructed, then you'll use RelaxNGCC to build a parser.
</p>
<pre>
&lt;?xml version="1.0" ?&gt;
&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"
  xmlns:c="http://www.xml.gr.jp/xmlns/relaxngcc"
  <em>c:package="test.sample4.parser"</em>&gt;

  <em>&lt;c:java-import&gt;
    import test.sample4.*;
  &lt;/c:java-import&gt;</em>

  &lt;start <em>c:class="Sample4"</em>&gt;
    &lt;element name="files"&gt;
      <em>result=</em>&lt;ref name="FolderContents" /><em>("");</em><span class="remark">[1]</span>
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="FolderContents" <em>c:params="String name"
    c:return-type="Folder" c:return-value="folder"</em>>
    <span class="remark">[2]</span>
    <em>&lt;c:java-body>
      private Folder folder;
      private FileSystemObject child;
    &lt;/c:java-body></em>
    
    <em>folder = new Folder(name);</em>
    &lt;zeroOrMore&gt;
      &lt;choice&gt;
        <em>child=</em>&lt;ref name="File" />
        &lt;element name="directory"&gt;
          <em>subFolderName=</em>&lt;attribute name="name"/>
          <em>child=</em>&lt;ref name="Dir" /><em>(subFolderName);</em>
        &lt;/element&gt;
      &lt;/choice&gt;
      <em>folder.add(child);</em><span class="remark">[3]</span>
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;
  
  &lt;define name="File"
    <em>c:return-type="File" c:return-value="makeResult()"</em>><span class="remark">[4]</span>
    
    <em>&lt;c:java-body>
        private File makeResult() {
            return new File(name);
        }
    &lt;/c:java-body></em>
    &lt;element name="file"&gt;
      <em>name=</em>&lt;attribute name="name" /&gt;
    &lt;/element>
  &lt;/define>
&lt;/grammar&gt;
</pre>

<table cellspacing=10>
<tr>
	<td valign=top><span class="remark">[1]</span></td>
	<td>
		We define this <tt>Sample4</tt> class to have the <tt>result</tt> field. Upon the completion of a parsing, this field will hold a reference to the parsed result.
	</td>
</tr><tr>
	<td valign=top><span class="remark">[2]</span></td>
	<td>
		This is the heart of this parser. We take the folder name as a parameter, then build a <tt>Folder</tt> object and return it as a parsed result from this RELAX NG pattern. Three attributes are used to specify this behavior.
	</td>
</tr><tr>
	<td valign=top><span class="remark">[3]</span></td>
	<td>
		This part of the code is a bit interesting. We declare the <tt>child</tt> variable to be of type <tt>FileSystemObject</tt>, so regardless of the branch this <tt>&lt;choice></tt> took (whether it is a <tt>File</tt> or a <tt>Folder</tt>), this variable will have a reference to it. So we will add the newly parsed child object to the <tt>folder</tt> variable here.
	</td>
</tr><tr>
	<td valign=top><span class="remark">[4]</span></td>
	<td>
		It is often useful to make a function call inside the return-value attribute, as shown in this example.
	</td>
</tr>
</table>


<h2>Conclusion</h2>
<p>
	This technique is so powerful that RelaxNGCC is using itself in this way to parse RELAX NG grammars. To see how it works, have a look at <code>src/relaxngcc/parser/relaxng.rng</code> file.
</p>
<hr>
<div align="right"><a href="index.htm">RelaxNGCC home</a></div>
</body>
</html>