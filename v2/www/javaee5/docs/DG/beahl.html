<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html><!-- GenHTML@12751-->
<head>
<META HTTP-EQUIV="Content-type" CONTENT="text/html; charset=iso-8859-1">
<!-- ident	"%Z%%M%	%I%	%E% SMI" -->

    <title>8.&nbsp;&nbsp;Using Enterprise JavaBeans Technology
    </title>
</head>
<body>
<font style="color: red; font-family:arial,helvetica,sans-serif; font-size:12pt; font-weight:bold}">Not For Publication</font>&nbsp;&nbsp;&nbsp;<br>Glassfish Review Draft<br> </td>

<A href="toc.html">Sun Java System Application Server Platform Edition 9.0 Developer's Guide</A>&nbsp;<br>
<A HREF="beafs.html">Previous</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="toc.html">Contents</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="idx.html">Index</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="beajj.html">Next</A><br>
            <!--startindex--><A NAME="beahl"></A><b>Chapter&nbsp;8</b><h1>Using Enterprise JavaBeans Technology</h1>
<p>This chapter describes how Enterprise JavaBeans&#153; (EJB&#153;)
technology is supported in the Sun Java System Application Server. This chapter addresses
the following topics:</p>
<ul><li><p><A HREF="beahl.html#beahm">Summary of EJB 2.1 Changes</A></p>
</li>
<li><p><A HREF="beahl.html#beahn">Value Added Features</A></p>
</li>
<li><p><A HREF="beahl.html#beahw">EJB Timer Service</A></p>
</li>
<li><p><A HREF="beahl.html#beahx">Using Session Beans</A></p>
</li>
<li><p><A HREF="beahl.html#beail">Using Read-Only Beans</A></p>
</li>
<li><p><A HREF="beahl.html#beait">Using Message-Driven Beans</A></p>
</li>
<li><p><A HREF="beahl.html#beaje">Handling Transactions with Enterprise Beans</A></p>
</li>
</ul>
<A NAME="beahm"></A><h2>Summary of EJB 2.1 Changes</h2>
<p><A NAME="indexterm-375"></A>The Application Server supports the Sun Microsystems Enterprise JavaBeans (EJB)
architecture as defined by the Enterprise JavaBeans Specification, v2.1 and is compliant
with the Enterprise JavaBeans Specification, v2.0.</p>
<p><hr size="1" noshade><p><b>Note - </b>The Application Server is backward compatible with 1.1 and 2.0 enterprise beans.
However, to take advantage of version 2.1 features, you should develop new beans as
2.1 enterprise beans.</p>
<hr size="1" noshade></p><p>The changes in the Enterprise JavaBeans Specification, v2.1 that impact enterprise
beans in the Application Server environment are as follows:</p>
<ul><li><p><b>EJB Timer Service:</b> This is a container-managed,
reliable, and transactional notification service that provides methods to allow callbacks
to be scheduled for time-based events. See <A HREF="beahl.html#beahw">EJB Timer Service</A>.</p>
</li>
<li><p><b>Message-driven beans:</b> This type
of enterprise bean can consume any inbound messages from a Connector 1.5 inbound resource
adapter, primarily but not exclusively JMS messages. See <A HREF="beahl.html#beait">Using Message-Driven Beans</A>.</p>
</li>
<li><p><b>EJB Web Services:</b> A stateless session
bean can serve as a web service endpoint. In addition, all EJB component types can
act as web service clients. For details, see the web service elements in the <tt>sun-ejb-jar.xml</tt> file, described in <A HREF="http://docs.sun.com/app/docs/doc/819-3660">"The sun-ejb-jar.xml File" in <i>Sun Java System Application Server Platform Edition 9.0 Application Deployment Guide</i></A>.</p>
</li>
</ul>
<A NAME="beahn"></A><h2>Value Added Features</h2>
<p>The Application Server provides a number of <A NAME="indexterm-376"></A>value additions that relate to EJB development. These capabilities are
discussed in the following sections (references to more in-depth material are included):</p>
<ul><li><p><A HREF="beahl.html#beaho">Read-Only Beans</A></p>
</li>
<li><p><A HREF="beahl.html#beahp">pass-by-reference</A></p>
</li>
<li><p><A HREF="beahl.html#beahq">Pooling and Caching</A></p>
</li>
<li><p><A HREF="beahl.html#beaht">Bean-Level Container-Managed Transaction Timeouts</A></p>
</li>
<li><p><A HREF="beahl.html#beahu">Priority Based Scheduling of Remote Bean Invocations</A></p>
</li>
<li><p><A HREF="beahl.html#beahv">Immediate Flushing</A></p>
</li>
</ul>
<A NAME="beaho"></A><h3>Read-Only Beans</h3>
<p>Another feature that the Application Server provides is the <A NAME="indexterm-377"></A><i>read-only bean</i>, an entity bean that is never modified
by an EJB client. Read-only beans avoid database updates completely. A read-only bean
is not portable.</p>
<p>A read-only bean can be used to cache a database entry that is frequently accessed
but rarely updated (externally by other beans). When the data that is cached by a
read-only bean is updated by another bean, the read-only bean can be notified to refresh
its cached data.</p>
<p>The Application Server provides a number of ways by which a read-only bean's
state can be refreshed. By setting the <tt>refresh-period-in-seconds</tt> element
in the <tt>sun-ejb-jar.xml</tt> file and the <tt>trans-attribute</tt> element
in the <tt>ejb-jar.xml</tt> file, it is easy to configure a read-only bean
that is (a) always refreshed, (b) periodically refreshed, (c) never refreshed, or
(d) programmatically refreshed.</p>
<p>Read-only beans are best suited for situations where the underlying data never
changes, or changes infrequently. For further information and usage guidelines, see <A HREF="beahl.html#beail">Using Read-Only Beans</A>.</p>
<A NAME="beahp"></A><h3>pass-by-reference</h3>
<p>The <A NAME="indexterm-378"></A><tt>pass-by-reference</tt> element in the <tt>sun-ejb-jar.xml</tt> file allows you to specify the parameter passing semantics for colocated
remote EJB invocations. This is an opportunity to improve performance. However, use
of this feature results in non-portable applications. See <A HREF="http://docs.sun.com/app/docs/doc/819-3660">"pass-by-reference" in <i>Sun Java System Application Server Platform Edition 9.0 Application Deployment Guide</i></A>.</p>
<A NAME="beahq"></A><h3>Pooling and Caching</h3>
<p>The EJB container of the Application Server <A NAME="indexterm-379"></A>pools anonymous instances (message-driven beans, stateless session beans,
and entity beans) to reduce the overhead of creating and destroying objects. The EJB
container maintains the free pool for each bean that is deployed. Bean instances in
the free pool have no identity (that is, no primary key associated) and are used to
serve the method calls of the home interface. The free beans are also used to serve
all methods for stateless session beans.</p>
<p>Bean instances in the free pool transition from a Pooled state to a Cached state
after <tt>ejbCreate</tt> and the business methods run. The size and behavior
of each pool is controlled using pool-related properties in the EJB container or the <tt>sun-ejb-jar.xml</tt> file.</p>
<p>In addition, the Application Server supports a number of tunable parameters that
can control the number of "stateful" instances (stateful session beans
and entity beans) <A NAME="indexterm-380"></A>cached as well as the duration they are cached. Multiple bean instances
that refer to the same database row in a table can be cached. The EJB container maintains
a cache for each bean that is deployed.</p>
<p>To achieve scalability, the container selectively evicts some bean instances
from the cache, usually when cache overflows. These evicted bean instances return
to the free bean pool. The size and behavior of each cache can be controlled using
the cache-related properties in the EJB container or the <tt>sun-ejb-jar.xml</tt> file.</p>
<p>Pooling and caching parameters for the <tt>sun-ejb-jar.xml</tt> file
are described in <A HREF="http://docs.sun.com/app/docs/doc/819-3660">"bean-cache" in <i>Sun Java System Application Server Platform Edition 9.0 Application Deployment Guide</i></A>.</p>
<A NAME="beahr"></A><h4>Pooling Parameters</h4>
<p>One of the most important parameters of Application Server pooling is <tt>steady-pool-size</tt>. When <tt>steady-pool-size</tt> is set to greater than 0, the
container not only pre-populates the bean pool with the specified number of beans,
but also attempts to ensure that there is always this many beans in the free pool.
This ensures that there are enough beans in the ready to serve state to process user
requests.</p>
<p>This parameter does not necessarily guarantee that no more than <tt>steady-pool-size</tt> instances exist at a given time. It only governs the number of instances
that are pooled over a long period of time. For example, suppose an idle stateless
session container has a fully-populated pool with a <tt>steady-pool-size</tt> of <tt>10</tt>. If 20 concurrent requests arrive for the EJB component, the container
creates 10 additional instances to satisfy the burst of requests. The advantage of
this is that it prevents the container from blocking any of the incoming requests.
However, if the activity dies down to 10 or fewer concurrent requests, the additional
10 instances are discarded.</p>
<p>Another parameter, <tt>pool-idle-timeout-in-seconds</tt>, allows the
administrator to specify, through the amount of time a bean instance can be idle in
the pool. When <tt>pool-idle-timeout-in-seconds</tt> is set to greater than
0, the container removes or destroys any bean instance that is idle for this specified
duration.</p>
<A NAME="beahs"></A><h4>Caching Parameters</h4>
<p>Application Server provides a way that completely avoids caching of entity beans,
using commit option C. Commit option C is particularly useful if beans are accessed
in large number but very rarely reused. For additional information, refer to <A HREF="beahl.html#beajh">Commit Options</A>.</p>
<p>The Application Server caches can be either bounded or unbounded. <i>Bounded
caches</i> have limits on the number of beans that they can hold beyond which
beans are passivated. For stateful session beans, there are three ways (LRU, NRU and
FIFO) of picking victim beans when cache overflow occurs. Caches can also passivate
beans that are idle (not accessed for a specified duration).</p>
<A NAME="beaht"></A><h3>Bean-Level Container-Managed Transaction Timeouts</h3>
<p>The default <A NAME="indexterm-381"></A>transaction timeout for the domain is specified using the Transaction
Timeout setting of the Transaction Service. A transaction started by the container
must commit (or rollback) within this time, regardless of whether the transaction
is suspended (and resumed), or the transaction is marked for rollback.</p>
<p>To override this timeout for an individual bean, use the optional <tt>cmt-timeout-in-seconds</tt> element in <tt>sun-ejb-jar.xml</tt>. The
default value, <tt>0</tt>, specifies that the default Transaction Service
timeout is used. The value of <tt>cmt-timeout-in-seconds</tt> is used for
all methods in the bean that start a new container-managed transaction. This value
is <i>not</i> used if the bean joins a client transaction.</p>
<A NAME="beahu"></A><h3>Priority Based Scheduling of Remote Bean Invocations</h3>
<A NAME="indexterm-382"></A><p>You can create multiple <A NAME="indexterm-383"></A><A NAME="indexterm-384"></A>thread pools, each having its own work queues. An optional element in
the <tt>sun-ejb-jar.xml</tt> file, <A NAME="indexterm-385"></A><tt>use-thread-pool-id</tt>, specifies the thread pool that
processes the requests for the bean. The bean must have a remote interface, or <tt>use-thread-pool-id</tt> is ignored. You can create different thread pools and
specify the appropriate thread pool ID for a bean that requires a quick response time.
If there is no such thread pool configured or if the element is absent, the default
thread pool is used.</p>
<A NAME="beahv"></A><h3>Immediate Flushing</h3>
<A NAME="indexterm-386"></A><A NAME="indexterm-387"></A><p>Normally, all entity bean updates within a transaction are batched and executed
at the end of the transaction. The only exception is the database flush that precedes
execution of a finder or select query.</p>
<p>Since a transaction often spans many method calls, you might want to find out
if the updates made by a method succeeded or failed immediately after method execution.
To force a flush at the end of a method's execution, use the <tt>flush-at-end-of-method</tt> element in the <tt>sun-ejb-jar.xml</tt> file. Only non-finder
methods in the Local, Local Home, Remote, and Remote Home interfaces of an entity
bean can be flush-enabled. See <A HREF="http://docs.sun.com/app/docs/doc/819-3660">"flush-at-end-of-method" in <i>Sun Java System Application Server Platform Edition 9.0 Application Deployment Guide</i></A>.</p>
<p>Upon completion of the method, the EJB container updates the database. Any exception
thrown by the underlying data store is wrapped as follows:</p>
<ul><li><p>If the method that triggered the flush is a <tt>create</tt> method,
the exception is wrapped with <tt>CreateException</tt>.</p>
</li>
<li><p>If the method that triggered the flush is a <tt>remove</tt> method,
the exception is wrapped with <tt>RemoveException</tt>.</p>
</li>
<li><p>For all other methods, the exception is wrapped with <tt>EJBException</tt>.</p>
</li>
</ul>
<p>All normal end-of-transaction database synchronization steps occur regardless
of whether the database has been flushed during the transaction.</p>
<A NAME="beahw"></A><h2>EJB Timer Service</h2>
<p>The <A NAME="indexterm-388"></A>EJB Timer Service uses a database to store persistent information about
EJB timers. By default, the EJB Timer Service in Application Server is
preconfigured to use an embedded version of Derby. The EJB Timer Service configuration
can store persistent timer information in any database supported by the Application Server CMP
container.</p>
<p>For a list of the JDBC drivers currently supported by the Application Server, see
the <i><A HREF="http://docs.sun.com/app/docs/doc/819-3653"><i>Sun Java System Application Server Platform Edition 9.0 2006Q1 Release Notes</i></A></i>.
For configurations of supported and other drivers, see <A HREF="http://docs.sun.com/app/docs/doc/819-3658">"Configurations for Specific JDBC Drivers" in <i>Sun Java System Application Server Platform Edition 9.0 Administration Guide</i></A>.</p>
<p>To change the database used by the EJB Timer Service, set the EJB Timer Service's
Timer DataSource setting to a valid JDBC resource. You must also create the timer
database table. DDL files are located in <i>install-dir</i><tt>/lib/install/databases</tt>.</p>
<p>Using the EJB Timer Service is equivalent to interacting with a single JDBC
resource manager. If an EJB component or application accesses a database either directly
through JDBC or indirectly (for example, through an entity bean's persistence
mechanism), and also interacts with the EJB Timer Service, its data source must be
configured with an XA JDBC driver.</p>
<p>You can change the following EJB Timer Service settings. You must restart the
server for the changes to take effect.</p>
<ul><li><p>Minimum Delivery Interval - Specifies the minimum time in milliseconds
before an expiration for a particular timer can occur. This guards against extremely
small timer increments that can overload the server. The default is <tt>7000</tt>.</p>
</li>
<li><p>Maximum Redeliveries - Specifies the maximum number of times the EJB
timer service attempts to redeliver a timer expiration due for exception or rollback.
The default is 1.</p>
</li>
<li><p>Redelivery Interval - Specifies how long in milliseconds the EJB timer
service waits after a failed <tt>ejbTimeout</tt> delivery before attempting
a redelivery. The default is <tt>5000</tt>.</p>
</li>
<li><p>Timer DataSource - Specifies the database used by the EJB Timer Service. The
default is <tt>jdbc/__TimerPool</tt>.</p>
</li>
</ul>
<p>For information about configuring EJB Timer Service settings, see the <i><A HREF="http://docs.sun.com/app/docs/doc/819-3658"><i>Sun Java System Application Server Platform Edition 9.0 Administration Guide</i></A></i>. For information
about the <tt>asadmin list-timers</tt> command, see the <i><A HREF="http://docs.sun.com/app/docs/doc/819-3662"><i>Sun Java System Application Server Platform Edition 9.0 2006Q1 Reference Manual</i></A></i>.</p>
<A NAME="beahx"></A><h2>Using Session Beans</h2>
<p>This section provides guidelines for creating <A NAME="indexterm-389"></A>session beans in the Application Server environment. This section addresses
the following topics:</p>
<ul><li><p><A HREF="beahl.html#beahy">About the Session Bean Containers</A></p>
</li>
<li><p><A HREF="beahl.html#beaii">Restrictions and Optimizations</A></p>
</li>
</ul>
<p>Extensive information on session beans is contained in the chapters 6, 7, and
8 of the Enterprise JavaBeans Specification, v2.1.</p>
<A NAME="beahy"></A><h3>About the Session Bean Containers</h3>
<p>Like an entity bean, a <A NAME="indexterm-390"></A>session bean can access a database through Java Database Connectivity
(JDBC) calls. A session bean can also provide transaction settings. These transaction
settings and JDBC calls are referenced by the session bean's container, allowing
it to participate in transactions managed by the container.</p>
<p>A container managing stateless session beans has a different charter from a
container managing stateful session beans.</p>
<A NAME="beahz"></A><h4>Stateless Container</h4>
<p>The <i>stateless container</i> manages <A NAME="indexterm-391"></A>stateless session beans, which, by definition, do not carry client-specific
states. All session beans (of a particular type) are considered equal.</p>
<p>A stateless session bean container uses a bean <A NAME="indexterm-392"></A>pool to service requests. The Application Server specific deployment descriptor
file, <tt>sun-ejb-jar.xml</tt>, contains the properties that define the
pool:</p>
<ul><li><p><tt>steady-pool-size</tt></p>
</li>
<li><p><tt>resize-quantity</tt></p>
</li>
<li><p><tt>max-pool-size</tt></p>
</li>
<li><p><tt>pool-idle-timeout-in-seconds</tt></p>
</li>
</ul>
<p>For more information about <tt>sun-ejb-jar.xml</tt>, see <A HREF="http://docs.sun.com/app/docs/doc/819-3660">"The sun-ejb-jar.xml File" in <i>Sun Java System Application Server Platform Edition 9.0 Application Deployment Guide</i></A>.</p>
<p>The Application Server provides the <tt>wscompile</tt> and <tt>wsdeploy</tt> tools to help you implement a web service endpoint as a stateless session
bean. For more information about these tools, see the <i><A HREF="http://docs.sun.com/app/docs/doc/819-3662"><i>Sun Java System Application Server Platform Edition 9.0 2006Q1 Reference Manual</i></A></i>.</p>
<A NAME="beaia"></A><h4>Stateful Container</h4>
<p>The <i>stateful container</i> manages the stateful session beans,
which, by definition, carry the client-specific state. There is a one-to-one relationship
between the client and the <A NAME="indexterm-393"></A>stateful session beans. At creation, each stateful session bean (SFSB)
is given a unique session ID that is used to access the session bean so that an instance
of a stateful session bean is accessed by a single client only.</p>
<p>Stateful session beans are managed using cache. The size and behavior of stateful
session beans cache are controlled by specifying the following <tt>sun-ejb-jar.xml</tt> parameters:</p>
<ul><li><p><tt>max-cache-size</tt></p>
</li>
<li><p><tt>resize-quantity</tt></p>
</li>
<li><p><tt>cache-idle-timeout-in-seconds</tt></p>
</li>
<li><p><tt>removal-timeout-in-seconds</tt></p>
</li>
<li><p><tt>victim-selection-policy</tt></p>
</li>
</ul>
<p>The <tt>max-cache-size</tt> element specifies the maximum number of
session beans that are held in cache. If the cache overflows (when the number of beans
exceeds <tt>max-cache-size</tt>), the container then passivates some beans
or writes out the serialized state of the bean into a file. The directory in which
the file is created is obtained from the EJB container using the configuration APIs.</p>
<p>For more information about <tt>sun-ejb-jar.xml</tt>, see <A HREF="http://docs.sun.com/app/docs/doc/819-3660">"The sun-ejb-jar.xml File" in <i>Sun Java System Application Server Platform Edition 9.0 Application Deployment Guide</i></A>.</p>
<p>The passivated beans are stored on the file system. The Session Store Location
setting in the EJB container allows the administrator to specify the directory where
passivated beans are stored. By default, passivated stateful session beans are stored
in application-specific subdirectories created under <i>domain-dir</i><tt>/session-store</tt>.</p>
<p><hr size="1" noshade><p><b>Note - </b>Make sure the <tt>delete</tt> option is set in the <tt>server.policy</tt> file, or expired file-based sessions might not be deleted
properly. For more information about <tt>server.policy</tt>, see <A HREF="beabg.html#beabx">The server.policy File</A>.</p>
<hr size="1" noshade></p><A NAME="beaii"></A><h3>Restrictions and Optimizations</h3>
<p>This section discusses restrictions on developing session beans and provides
some optimization guidelines:</p>
<ul><li><p><A HREF="beahl.html#beaij">Optimizing Session Bean Performance</A></p>
</li>
<li><p><A HREF="beahl.html#beaik">Restricting Transactions</A></p>
</li>
</ul>
<A NAME="beaij"></A><h4>Optimizing Session Bean Performance</h4>
<p>For stateful session <A NAME="indexterm-394"></A>beans, colocating the stateful beans with their clients so that the client
and bean are executing in the same process address space improves performance.</p>
<A NAME="beaik"></A><h4>Restricting Transactions</h4>
<p>The following <A NAME="indexterm-395"></A>restrictions on transactions are enforced by the container and must be
observed as session beans are developed:</p>
<ul><li><p>A session bean can participate in, at most, a single transaction at
a time.</p>
</li>
<li><p>If a session bean is participating in a transaction, a client cannot
invoke a method on the bean such that the <tt>trans-attribute</tt> element
in the <tt>ejb-jar.xml</tt> file would cause the container to execute the
method in a different or unspecified transaction context or an exception is thrown.</p>
</li>
<li><p>If a session bean instance is participating in a transaction, a client
cannot invoke the <tt>remove</tt> method on the session object's home
or component interface object or an exception is thrown.</p>
</li>
</ul>
<A NAME="beail"></A><h2>Using Read-Only Beans</h2>
<p>A <A NAME="indexterm-396"></A><i>read-only bean</i> is an entity bean that is never modified
by an EJB client. The data that a read-only bean represents can be updated externally
by other enterprise beans, or by other means, such as direct database updates.</p>
<p><hr size="1" noshade><p><b>Note - </b>Read-only beans are specific to Application Server and are not part of the
Enterprise JavaBeans Specification, v2.1. Use of this feature results in a non-portable
application.</p>
<hr size="1" noshade></p><p>Read-only beans are best suited for situations where the underlying data never
changes, or changes infrequently. The following topics are addressed in this section:</p>
<ul><li><p><A HREF="beahl.html#beaim">Read-Only Bean Characteristics and Life Cycle</A></p>
</li>
<li><p><A HREF="beahl.html#beain">Read-Only Bean Good Practices</A></p>
</li>
<li><p><A HREF="beahl.html#beaio">Refreshing Read-Only Beans</A></p>
</li>
<li><p><A HREF="beahl.html#beais">Deploying Read Only Beans</A></p>
</li>
</ul>
<A NAME="beaim"></A><h3>Read-Only Bean Characteristics and Life Cycle</h3>
<p>Read-only beans are best suited for situations where the underlying data never
changes, or changes infrequently. For example, a read-only bean can be used to represent
a stock quote for a particular company, which is updated externally. In such a case,
using a regular entity bean might incur the burden of calling <tt>ejbStore</tt>,
which can be avoided by using a read-only bean.</p>
<p>Read-only beans have the following characteristics:</p>
<ul><li><p>Only entity beans can be read-only beans.</p>
</li>
<li><p>Either bean-managed persistence (BMP) or container-managed persistence
(CMP) is allowed. If CMP is used, do not create the database schema during deployment.
Instead, work with your database administrator to populate the data into the tables.
See <A HREF="beajj.html#beajj">Chapter&nbsp;9, Using Container-Managed Persistence for Entity Beans</A>.</p>
</li>
<li><p>Only container-managed transactions are allowed; read-only beans cannot
start their own transactions.</p>
</li>
<li><p>Read-only beans don't update any bean state.</p>
</li>
<li><p><tt>ejbStore</tt> is never called by the container.</p>
</li>
<li><p><tt>ejbLoad</tt> is called only when a transactional method
is called or when the bean is initially created (in the cache), or at regular intervals
controlled by the bean's <tt>refresh-period-in-seconds</tt> element
in the <tt>sun-ejb-jar.xml</tt> file.</p>
</li>
<li><p>The home interface can have any number of find methods. The return
type of the find methods must be the primary key for the same bean type (or a collection
of primary keys).</p>
</li>
<li><p>If the data that the bean represents can change, then <A NAME="indexterm-397"></A><tt>refresh-period-in-seconds</tt> must be set to refresh the
beans at regular intervals. <tt>ejbLoad</tt> is called at this regular interval.</p>
</li>
</ul>
<p>A read-only bean comes into existence using the appropriate find methods.</p>
<p>Read-only beans are cached and have the same cache properties as entity beans.
When a read-only bean is selected as a victim to make room in the cache, <A NAME="indexterm-398"></A><tt>ejbPassivate</tt> is called and the bean is returned to
the free <A NAME="indexterm-399"></A>pool. When in the free pool, the bean has no identity and is used only
to serve any finder requests.</p>
<p>Read-only beans are bound to the naming service like regular read-write entity
beans, and clients can look up read-only beans the same way read-write entity beans
are looked up.</p>
<A NAME="beain"></A><h3>Read-Only Bean Good Practices</h3>
<p>For best results, follow these guidelines when developing read-only beans:</p>
<ul><li><p>Avoid having any <tt>create</tt> or <tt>remove</tt> methods
in the home interface.</p>
</li>
<li><p>Use any of the valid EJB 2.1 transaction attributes for the <tt>trans-attribute</tt> element.</p>
<p>The reason for having <tt>TX_SUPPORTED</tt> is to allow reading uncommitted data in the same transaction. Also, the
transaction attributes can be used to force <tt>ejbLoad</tt>.</p>
</li>
</ul>
<A NAME="beaio"></A><h3>Refreshing Read-Only Beans</h3>
<p>There are several ways of refreshing<A NAME="indexterm-400"></A> read-only beans as addressed in the following sections:</p>
<ul><li><p><A HREF="beahl.html#beaip">Invoking a Transactional Method</A></p>
</li>
<li><p><A HREF="beahl.html#beaiq">Refreshing Periodically</A></p>
</li>
<li><p><A HREF="beahl.html#beair">Refreshing Programmatically</A></p>
</li>
</ul>
<A NAME="beaip"></A><h4>Invoking a Transactional Method</h4>
<p>Invoking any transactional method invokes <tt>ejbLoad</tt>.</p>
<A NAME="beaiq"></A><h4>Refreshing Periodically</h4>
<p>Use the <tt>refresh-period-in-seconds</tt> element in the <tt>sun-ejb-jar.xml</tt> file to refresh a read-only bean periodically.</p>
<ul><li><p>If the value specified in <tt>refresh-period-in-seconds</tt> is
zero or not specified, which is the default, the bean is never refreshed (unless a
transactional method is accessed).</p>
</li>
<li><p>If the value is greater than zero, the bean is refreshed at the rate
specified.</p>
</li>
</ul>
<p><hr size="1" noshade><p><b>Note - </b>This is the only way to refresh the bean state if the data can be modified
external to the Application Server.</p>
<hr size="1" noshade></p><A NAME="beair"></A><h4>Refreshing Programmatically</h4>
<p>Typically, beans that update any data that is cached by read-only beans need
to notify the read-only beans to refresh their state. Use <A NAME="indexterm-401"></A><tt>ReadOnlyBeanNotifier</tt> to force the refresh of read-only
beans.</p>
<p>To do this, invoke the following methods on the <tt>ReadOnlyBeanNotifier</tt> bean:</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>public interface ReadOnlyBeanNotifier extends java.rmi.Remote {
   refresh(Object PrimaryKey) throws RemoteException;
 }</pre>
</td></table><br><p>The implementation of the <tt>ReadOnlyBeanNotifier</tt> interface
is provided by the container. The bean looks up <tt>ReadOnlyBeanNotifier</tt> using
a fragment of code such as the following example:</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>com.sun.appserv.ejb.ReadOnlyBeanHelper helper = 
  new com.sun.appserv.ejb.ReadOnlyBeanHelper();
com.sun.appserv.ejb.ReadOnlyBeanNotifier notifier = 
  helper.getReadOnlyBeanNotifier("java:comp/env/ejb/ReadOnlyCustomer");
notifier.refresh(PrimaryKey);</pre>
</td></table><br><p>For a local read-only bean notifier, the lookup has this modification:</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>helper.getReadOnlyBeanLocalNotifier("java:comp/env/ejb/LocalReadOnlyCustomer");</pre>
</td></table><br><p>Beans that update any data that is cached by read-only beans need to call the <tt>refresh</tt> methods. The next (non-transactional) call to the read-only bean
invokes <tt>ejbLoad</tt>.</p>
<p><hr size="1" noshade><p><b>Note - </b>Programmatic refresh of read-only beans is not supported in a clustered
environment.</p>
<hr size="1" noshade></p><A NAME="beais"></A><h3>Deploying Read Only Beans</h3>
<p><A NAME="indexterm-402"></A>Read-only beans are deployed in the same manner as other entity beans.
However, in the entry for the bean in the <tt>sun-ejb-jar.xml</tt> file,
the <tt>is-read-only-bean</tt> element must be set to true. That is:</p>
<p><A NAME="indexterm-403"></A><tt>&lt;is-read-only-bean>true&lt;/is-read-only-bean></tt></p>
<p>Also, the <tt>refresh-period-in-seconds</tt> element in the <tt>sun-ejb-jar.xml</tt> file can be set to some value that specifies the rate at
which the bean is refreshed. If this element is missing, no refresh occurs.</p>
<p>All requests in the same transaction context are routed <A NAME="indexterm-404"></A>to the same read-only bean instance. Set the <A NAME="indexterm-405"></A><tt>allow-concurrent-access</tt> element to either <tt>true</tt> (to allow concurrent accesses) or <tt>false</tt> (to serialize
concurrent access to the same read-only bean). The default is <tt>false</tt>.</p>
<p>For further information on these elements, refer to <A HREF="http://docs.sun.com/app/docs/doc/819-3660">"The sun-ejb-jar.xml File" in <i>Sun Java System Application Server Platform Edition 9.0 Application Deployment Guide</i></A>.</p>
<A NAME="beait"></A><h2>Using Message-Driven Beans</h2>
<p>This section describes message-driven beans <A NAME="indexterm-406"></A>and explains the requirements for creating them in the Application Server environment.
This section contains the following topics:</p>
<ul><li><p><A HREF="beahl.html#beaiu">Message-Driven Bean Configuration</A></p>
</li>
<li><p><A HREF="beahl.html#beaiy">Restrictions and Optimizations</A></p>
</li>
<li><p><A HREF="beahl.html#beajb">Sample Message-Driven Bean XML Files</A></p>
</li>
</ul>
<A NAME="beaiu"></A><h3>Message-Driven Bean Configuration</h3>
<p>This section addresses the following configuration topics:</p>
<ul><li><p><A HREF="beahl.html#beahx">Using Session Beans</A></p>
</li>
<li><p><A HREF="beahl.html#beaiw">Message-Driven Bean Pool</A></p>
</li>
<li><p><A HREF="beahl.html#beaix">Domain-Level Settings</A></p>
</li>
</ul>
<A NAME="beaiv"></A><h4>Connection Factory and Destination</h4>
<p>A <A NAME="indexterm-407"></A><A NAME="indexterm-408"></A><A NAME="indexterm-409"></A>message-driven bean is a client to a Connector 1.5 inbound resource adapter.
The message-driven bean container uses the JMS service integrated into the Application Server for
message-driven beans that are JMS clients. JMS clients use JMS Connection Factory-
and Destination-administered objects. A JMS Connection Factory administered object
is a resource manager Connection Factory object that is used to create connections
to the JMS provider.</p>
<p>The <A NAME="indexterm-410"></A><tt>mdb-connection-factory</tt> element in the <tt>sun-ejb-jar.xml</tt>file for a message-driven bean specifies the connection factory that creates
the container connection to the JMS provider.</p>
<p>The <tt>jndi-name</tt> element of the <tt>ejb</tt> element
in the <tt>sun-ejb-jar.xml</tt> file specifies the <A NAME="indexterm-411"></A>JNDI name of the administered object for the JMS <tt>Queue</tt> or <tt>Topic</tt> destination that is associated with the message-driven bean.</p>
<A NAME="beaiw"></A><h4>Message-Driven Bean Pool</h4>
<p><A NAME="indexterm-412"></A>The container manages a pool of message-driven beans for the concurrent
processing of a stream of messages. The <tt>sun-ejb-jar.xml</tt> file contains
the elements that define the pool (that is, the <tt>bean-pool</tt> element):</p>
<ul><li><p><tt>steady-pool-size</tt></p>
</li>
<li><p><tt>resize-quantity</tt></p>
</li>
<li><p><tt>max-pool-size</tt></p>
</li>
<li><p><tt>pool-idle-timeout-in-seconds</tt></p>
</li>
</ul>
<p>For more information about <tt>sun-ejb-jar.xml</tt>, see <A HREF="http://docs.sun.com/app/docs/doc/819-3660">"The sun-ejb-jar.xml File" in <i>Sun Java System Application Server Platform Edition 9.0 Application Deployment Guide</i></A>.</p>
<A NAME="beaix"></A><h4>Domain-Level Settings</h4>
<p>You can control the following domain-level message-driven bean <A NAME="indexterm-413"></A>settings in the EJB container:</p>
<ul><li><p>Initial and Minimum Pool Size - Specifies the initial and minimum
number of beans maintained in the pool. The default is <tt>0</tt>.</p>
</li>
<li><p>Maximum Pool Size - Specifies the maximum number of beans that can
be created to satisfy client requests. The default is 3<tt>2</tt>.</p>
</li>
<li><p>Pool Resize Quantity - Specifies the number of beans to be created
if a request arrives when the pool is empty (subject to the Initial and Minimum Pool
Size), or the number of beans to remove if idle for more than the Idle Timeout. The
default is <tt>8</tt>.</p>
</li>
<li><p>Idle Timeout - Specifies the maximum time in seconds that a bean can
remain idle in the pool. After this amount of time, the bean is destroyed. The default
is <tt>600</tt> (10 minutes). A value of <tt>0</tt> means a bean
can remain idle indefinitely.</p>
</li>
</ul>
<p>For information on <A NAME="indexterm-414"></A>monitoring message-driven beans, see the Application Server Admin Console online
help and the <i><A HREF="http://docs.sun.com/app/docs/doc/819-3658"><i>Sun Java System Application Server Platform Edition 9.0 Administration Guide</i></A></i>.</p>
<p><hr size="1" noshade><p><b>Note - </b>Running monitoring when it is not needed might impact performance, so
you might choose to turn monitoring off when it is not in use. For details, see the <i><A HREF="http://docs.sun.com/app/docs/doc/819-3658"><i>Sun Java System Application Server Platform Edition 9.0 Administration Guide</i></A></i>.</p>
<hr size="1" noshade></p><A NAME="beaiy"></A><h3>Restrictions and Optimizations</h3>
<p>This section discusses the following <A NAME="indexterm-415"></A>restrictions and performance optimizations that pertain to developing
message-driven beans:</p>
<ul><li><p><A HREF="beahl.html#beaiz">Pool Tuning and Monitoring</A></p>
</li>
<li><p><A HREF="beahl.html#beaja">onMessage Runtime Exception</A></p>
</li>
</ul>
<A NAME="beaiz"></A><h4>Pool Tuning and Monitoring</h4>
<p>The <A NAME="indexterm-416"></A><A NAME="indexterm-417"></A>message-driven bean pool is also a pool of threads, with each message-driven
bean instance in the pool associating with a server session, and each server session
associating with a thread. Therefore, a large pool size also means a high number of
threads, which impacts performance and server resources.</p>
<p>When configuring message-driven bean pool properties, make sure to consider
factors such as message arrival rate and pattern, <tt>onMessage</tt> method
processing time, overall server resources (threads, memory, and so on), and any concurrency
requirements and limitations from other resources that the message-driven bean accesses.</p>
<p>When tuning performance and resource usage, make sure to consider potential
JMS provider properties for the connection factory used by the container (the <A NAME="indexterm-418"></A><tt>mdb-connection-factory</tt> element in the <tt>sun-ejb-jar.xml</tt> file). For example, you can tune the Sun Java System Message Queue flow
control related properties for connection factory in situations where the message
incoming rate is much higher than <tt>max-pool-size</tt> can handle.</p>
<p>Refer to the <i><A HREF="http://docs.sun.com/app/docs/doc/819-3658"><i>Sun Java System Application Server Platform Edition 9.0 Administration Guide</i></A></i> for information on how to get message-driven bean
pool statistics.</p>
<A NAME="beaja"></A><h4>onMessage Runtime Exception</h4>
<p>Message-driven beans, like other well-behaved MessageListeners, should not,
in general, throw runtime exceptions. If a message-driven bean's <A NAME="indexterm-419"></A><A NAME="indexterm-420"></A><tt>onMessage</tt> method encounters a system-level exception
or error that does not allow the method to successfully complete, the Enterprise JavaBeans
Specification, v2.1 provides the following guidelines:</p>
<ul><li><p>If the bean method encounters a runtime exception or error, it should
simply propagate the error from the bean method to the container.</p>
</li>
<li><p>If the bean method performs an operation that results in a checked
exception that the bean method cannot recover, the bean method should throw the <tt>javax.ejb.EJBException</tt> that wraps the original exception.</p>
</li>
<li><p>Any other unexpected error conditions should be reported using <tt>javax.ejb.EJBException</tt> (<tt>javax.ejb.EJBException</tt> is a subclass
of <tt>java.lang.RuntimeException</tt>).</p>
</li>
</ul>
<p>Under container-managed transaction demarcation, upon receiving a runtime exception
from a message-driven bean's <tt>onMessage</tt> method, the container
rolls back the container-started transaction and the message is redelivered. This
is because the message delivery itself is part of the container-started transaction.
By default, the Application Server container closes the container's connection to
the JMS provider when the first runtime exception is received from a message-driven
bean instance's <tt>onMessage</tt> method. This avoids potential message
redelivery looping and protects server resources if the message-driven bean's <tt>onMessage</tt> method continues misbehaving. To change this default container
behavior, use the <tt>cmt-max-runtime-exceptions</tt> property of the <tt>mdb-container</tt> element in the <tt>domain.xml</tt> file.</p>
<p>The <A NAME="indexterm-421"></A><tt>cmt-max-runtime-exceptions</tt> property specifies the maximum
number of runtime exceptions allowed from a message-driven bean's <tt>onMessage</tt> method before the container starts to close the container's
connection to the message source. By default this value is 1; -1 disables this container
protection.</p>
<p>A message-driven bean's <tt>onMessage</tt> method can use the <tt>javax.jms.Message</tt> <tt>getJMSRedelivered</tt> method to check whether
a received message is a redelivered message.</p>
<p><hr size="1" noshade><p><b>Note - </b>The <tt>cmt-max-runtime-exceptions</tt> property might be deprecated
in the future.</p>
<hr size="1" noshade></p><A NAME="beajb"></A><h3>Sample Message-Driven Bean XML Files</h3>
<p><A NAME="indexterm-422"></A>This section includes the following sample <A NAME="indexterm-423"></A><A NAME="indexterm-424"></A><A NAME="indexterm-425"></A>files:</p>
<ul><li><p><A HREF="beahl.html#beajc">Sample ejb-jar.xml File</A></p>
</li>
<li><p><A HREF="beahl.html#beajd">Sample sun-ejb-jar.xml File</A></p>
</li>
</ul>
<p>For general information on the <tt>sun-ejb-jar.xml</tt> file, see <A HREF="http://docs.sun.com/app/docs/doc/819-3660">"The sun-ejb-jar.xml File" in <i>Sun Java System Application Server Platform Edition 9.0 Application Deployment Guide</i></A>.</p>
<A NAME="beajc"></A><h4>Sample ejb-jar.xml File</h4>
<A NAME="indexterm-426"></A><table cellpadding="4" border="1" cols="1" width="100%"><td><pre>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;!DOCTYPE ejb-jar PUBLIC '-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 
2.0//EN' 'http://java.sun.com/dtd/ejb-jar_2_0.dtd'>
&lt;ejb-jar>
&lt;enterprise-beans>
	&lt;message-driven>
		&lt;ejb-name>MessageBean&lt;/ejb-name>
		&lt;ejb-class>samples.mdb.ejb.MessageBean&lt;/ejb-class>
		&lt;transaction-type>Container&lt;/transaction-type>
		&lt;message-driven-destination>
			&lt;destination-type>javax.jms.Queue&lt;/destination-type>
		&lt;/message-driven-destination>
		&lt;resource-ref>
			&lt;res-ref-name>jms/QueueConnectionFactory&lt;/res-ref-name>
			&lt;res-type>javax.jms.QueueConnectionFactory&lt;/res-type>
			&lt;res-auth>Container&lt;/res-auth>
		&lt;/resource-ref>
	&lt;/message-driven>
&lt;/enterprise-beans>
	&lt;assembly-descriptor>
		&lt;container-transaction>
			&lt;method>
				&lt;ejb-name>MessageBean&lt;/ejb-name>
				&lt;method-intf>Bean&lt;/method-intf>
				&lt;method-name>onMessage&lt;/method-name>
				&lt;method-params>
					&lt;method-param>javax.jms.Message&lt;/method-param>
				&lt;/method-params>
			&lt;/method>
		&lt;trans-attribute>NotSupported&lt;/trans-attribute>
	&lt;/container-transaction>
&lt;/assembly-descriptor
&lt;/ejb-jar></pre>
</td></table><br><A NAME="beajd"></A><h4>Sample sun-ejb-jar.xml File</h4>
<A NAME="indexterm-427"></A><table cellpadding="4" border="1" cols="1" width="100%"><td><pre>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;!DOCTYPE sun-ejb-jar PUBLIC '-//Sun Microsystems, Inc.//DTD 
Application Server 9.0 EJB 3.0//EN' 
'http://www.sun.com/software/appserver/dtds/sun-ejb-jar_3_0-0.dtd'>
&lt;sun-ejb-jar>
&lt;enterprise-beans>
	&lt;ejb>
		&lt;ejb-name>MessageBean&lt;/ejb-name>
		&lt;jndi-name>jms/sample/Queue&lt;/jndi-name>
		&lt;resource-ref>
			&lt;res-ref-name>jms/QueueConnectionFactory&lt;/res-ref-name>
			&lt;jndi-name>jms/sample/QueueConnectionFactory&lt;/jndi-name>
			&lt;default-resource-principal>
				&lt;name>guest&lt;/name>
				&lt;password>guest&lt;/password>
			&lt;/default-resource-principal>
		&lt;/resource-ref>
		&lt;mdb-connection-factory>
			&lt;jndi-name>jms/sample/QueueConnectionFactory&lt;/jndi-name>
			&lt;default-resource-principal>
				&lt;name>guest&lt;/name>
				&lt;password>guest&lt;/password>
			&lt;/default-resource-principal>
		&lt;/mdb-connection-factory>
	&lt;/ejb>
&lt;/enterprise-beans>
&lt;/sun-ejb-jar></pre>
</td></table><br><A NAME="beaje"></A><h2>Handling Transactions with Enterprise Beans</h2>
<p>This section describes the <A NAME="indexterm-428"></A>transaction support built into the Enterprise JavaBeans programming model
for the Application Server.</p>
<p>As a developer, you can write an application that updates data in multiple databases
distributed across multiple sites. The site might use EJB servers from different vendors.
This section provides overview information on the following topics:</p>
<ul><li><p><A HREF="beahl.html#beajf">Flat Transactions</A></p>
</li>
<li><p><A HREF="beahl.html#beajg">Global and Local Transactions</A></p>
</li>
<li><p><A HREF="beahl.html#beajh">Commit Options</A></p>
</li>
<li><p><A HREF="beahl.html#beaji">Administration and Monitoring</A></p>
</li>
</ul>
<A NAME="beajf"></A><h3>Flat Transactions</h3>
<p>The Enterprise JavaBeans Specification, v2.1 requires support for <A NAME="indexterm-429"></A><A NAME="indexterm-430"></A>flat (as opposed to nested) <A NAME="indexterm-431"></A><A NAME="indexterm-432"></A>transactions. In a flat transaction, each transaction is decoupled from
and independent of other transactions in the system. Another transaction cannot start
in the same thread until the current transaction ends.</p>
<p>Flat transactions are the most prevalent model and are supported by most commercial
database systems. Although nested transactions offer a finer granularity of control
over transactions, they are supported by far fewer commercial database systems.</p>
<A NAME="beajg"></A><h3>Global and Local Transactions</h3>
<A NAME="indexterm-433"></A><A NAME="indexterm-434"></A><p>Understanding the distinction between global and local transactions is crucial
in understanding the Application Server support for transactions. See <A HREF="beanm.html#beano">Transaction Scope</A>.</p>
<p>Both local and global transactions are demarcated using the <tt>javax.transaction.UserTransaction</tt> interface, which the client must use. Local transactions bypass the transaction
manager and are faster. For more information, see <A HREF="beanr.html#beant">Naming Environment for Java EE Application Components</A>.</p>
<A NAME="beajh"></A><h3>Commit Options</h3>
<p>The EJB protocol is designed to give the container the flexibility to select
the disposition of the instance state at the time a transaction is committed. This
allows the container to best manage caching an entity object's state and associating
an entity object identity with the EJB instances.</p>
<p>There are three <A NAME="indexterm-435"></A><A NAME="indexterm-436"></A>commit-time options:</p>
<ul><li><p><b>Option A:</b> The container caches
a ready instance between transactions. The container ensures that the instance has
exclusive access to the state of the object in persistent storage.</p>
<p>In
this case, the container does <i>not</i> have to synchronize the instance's
state from the persistent storage at the beginning of the next transaction.</p>
<p><hr size="1" noshade><p><b>Note - </b>Commit option A is not supported for this Application Server release.</p>
<hr size="1" noshade></p></li>
<li><p><b>Option B:</b> The container caches
a ready instance between transactions, but the container does <i>not</i> ensure
that the instance has exclusive access to the state of the object in persistent storage.
This is the default.</p>
<p>In this case, the container must synchronize the
instance's state by invoking <tt>ejbLoad</tt> from persistent storage
at the beginning of the next transaction.</p>
</li>
<li><p><A NAME="indexterm-437"></A><b>Option C:</b> The container does <i>not</i> cache a ready instance between transactions, but instead returns the
instance to the pool of available instances after a transaction has completed.</p>
<p>The life cycle for every business method invocation under commit option C looks
like this:</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>ejbActivate -> ejbLoad -> business method -> ejbStore -> ejbPassivate</pre>
</td></table><br><p>If there is more than one transactional client concurrently accessing the same
entity <tt>EJBObject</tt>, the first client gets the ready instance and
subsequent concurrent clients get new instances from the pool.</p>
</li>
</ul>
<p>The Application Server deployment descriptor has an element, <tt>commit-option</tt>, that specifies the commit option to be used. Based on the specified commit
option, the appropriate handler is instantiated.</p>
<A NAME="beaji"></A><h3>Administration and Monitoring</h3>
<p>An <A NAME="indexterm-438"></A>administrator can control a number of domain-level <A NAME="indexterm-439"></A>Transaction Service settings. For details, see <A HREF="beanm.html#beanp">Configuring the Transaction Service</A>.</p>
<p>The Transaction Timeout setting can be overridden by a bean. See <A HREF="beahl.html#beaht">Bean-Level Container-Managed Transaction Timeouts</A>.</p>
<p>In addition, the administrator can <A NAME="indexterm-440"></A>monitor transactions using statistics from the transaction manager that
provide information on such activities as the number of transactions completed, rolled
back, or recovered since server startup, and transactions presently being processed.</p>
<p>For information on administering and monitoring transactions, see the Application Server Admin Console online
help and the <i><A HREF="http://docs.sun.com/app/docs/doc/819-3658"><i>Sun Java System Application Server Platform Edition 9.0 Administration Guide</i></A></i>.</p>

            <!--stopindex-->
<br>
<A HREF="beafs.html">Previous</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="toc.html">Contents</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="idx.html">Index</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="beajj.html">Next</A>
</body>
</html>
