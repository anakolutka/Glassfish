#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2012 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#
#
# This file incorporates work covered by the following copyright and
# permission notice:
#
# Copyright 2004 The Apache Software Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# Message IDs reserved for this file: PWC6600-PWC6624
#
object.invalidScope=PWC6600 Impossibile usare questo oggetto al di fuori del metodo di servizio di un servlet o del metodo doFilter di un filtro

#
# Message IDs reserved for this file: PWC3980-PWC4209
#
coyoteConnector.alreadyInitialized=PWC3980 Il connettore \u00E8 gi\u00E0 stato inizializzato
coyoteConnector.alreadyStarted=PWC3981 Il connettore \u00E8 gi\u00E0 stato avviato
coyoteConnector.cannotRegisterProtocol=PWC3982 Impossibile registrare l'MBean per il protocollo
coyoteConnector.notStarted=PWC3983 Il connettore Coyote non \u00E8 stato avviato
coyoteConnector.protocolHandlerDestroyFailed=PWC3984 Eliminazione dell''handler di protocollo non riuscita: {0}
coyoteConnector.protocolHandlerInitializationFailed=PWC3985 Inizializzazione dell''handler di protocollo non riuscita: {0}
coyoteConnector.protocolHandlerInstantiationFailed=PWC3986 Creazione di un''istanza dell''handler di protocollo non riuscita: {0}
coyoteConnector.protocolHandlerStartFailed=PWC3987 Avvio dell''handler di protocollo non riuscito: {0}
coyoteConnector.protocolRegistrationFailed=PWC3988 Registrazione JMX del protocollo non riuscita
coyoteConnector.illegalAdapter=PWC4015 Implementazione dell''adattatore non valido di mod_jk: {0} 
coyoteAdapter.service=PWC3989 Si \u00E8 verificata un'eccezione o un errore nel contenitore durante l'elaborazione della richiesta
coyoteResponse.getOutputStream.ise=PWC3990 getWriter() \u00E8 gi\u00E0 stato chiamato per questa risposta
coyoteResponse.getWriter.ise=PWC3991 getOutputStream() \u00E8 gi\u00E0 stato chiamato per questa risposta
coyoteResponse.resetBuffer.ise=PWC3992 Impossibile reimpostare il buffer dopo l'esecuzione del commit della risposta
coyoteResponse.sendError.ise=PWC3993 Impossibile chiamare sendError() dopo l'esecuzione del commit della risposta
coyoteResponse.sendRedirect.ise=PWC3994 Impossibile chiamare sendRedirect()dopo l'esecuzione del commit della risposta
coyoteResponse.setBufferSize.ise=PWC3995 Impossibile modificare la dimensione del buffer dopo la scrittura dei dati
responseFacade.nullResponse=PWC3996 Oggetto risposta nullo
coyoteRequest.getInputStream.ise=PWC3997 getReader() \u00E8 gi\u00E0 stato chiamato per questa risposta
coyoteRequest.getReader.ise=PWC3998 getInputStream() \u00E8 gi\u00E0 stato chiamato per questa risposta
coyoteRequest.sessionCreateCommitted=PWC3999 Impossibile creare una sessione dopo l'esecuzione del commit della risposta
coyoteRequest.setAttribute.namenull=PWC4000 Impossibile chiamare setAttribute con un nome nullo
coyoteRequest.listenerStart=PWC4001 Eccezione durante l''invio dell''evento inizializzato del contesto all''istanza del listener della classe {0}
coyoteRequest.listenerStop=PWC4002 Eccezione durante l''invio dell''evento eliminato del contesto all''istanza del listener della classe {0}
coyoteRequest.attributeEvent=PWC4003 Eccezione restituita dal listener di eventi dell'attributo
coyoteRequest.postTooLarge=PWC4004 I parametri non sono stati analizzati poich\u00E9 la dimensione dei dati inviati era troppo grande. Usare l'attributo maxPostSize del connettore per risolvere il problema se l'applicazione deve accettare POST di grandi dimensioni.
requestFacade.nullRequest=PWC4005 L'oggetto richiesta non deve essere usato al di fuori dell'ambito di servizio di un servlet o del metodo doFilter di un filtro
coyoteAdapter.proxyAuthCertError=PWC4009 Errore durante l'analisi della catena di certificati del client nell'array delle istanze java.security.cert.X509Certificate
coyoteAdapter.listenerOff=PWC4010 Il listener HTTP sulla porta {0} \u00E8 stato disabilitato
#no ID on coyoteAdapter.noHost as it is sent to client
coyoteAdapter.noHost=Nessun host corrispondente al nome server {0}
coyoteRequest.setCharacterEncoding.ise=PWC4011 Impossibile impostare la codifica dei caratteri della richiesta su {0} dal contesto {1} poich\u00E9 i parametri della richiesta sono gi\u00E0 stati letti oppure servletRequest.getReader() \u00E8 gi\u00E0 stato chiamato
coyoteRequest.unknownHost=PWC4012 Impossibile risolvere l''indirizzo IP {0} in nome host
coyoteRequest.nullRemoteAddressFromProxy=PWC4013 Impossibile determinare l'indirizzo remoto del client dal proxy (restituisce un valore nullo)
object.invalidScope=PWC4014 Impossibile usare questo oggetto al di fuori del metodo di servizio di un servlet o del metodo doFilter di un filtro
inputBuffer.streamClosed=PWC4015 Flusso chiuso
coyoteRequest.sendfileNotCanonical=PWC4016 Impossibile determinare il nome canonico del file [{0}] specificato per l''uso con sendfile
coyoteRequest.multipart.not.configured=PWC4017 Request.{0} chiamato senza la configurazione multiparte. Aggiungere un @MultipartConfig al servlet o un elemento multipart-config a web.xml.
inputBuffer.alreadysetReadListener=PWC4018 Il ReadListener \u00E8 gi\u00E0 stato impostato.
outputBuffer.alreadysetWriteListener=PWC4019 Il WriteListener \u00E8 gi\u00E0 stato impostato.
coyoteRequest.changeSessionId.ise=PWC4020 changeSessionId \u00E8 stato chiamato senza una sessione
coyoteReader.readline.skipFailure=PWC4021 Salto di {0} caratteri non riuscito nel buffer di base di CoyoteReader su readLine().

#
# Messages related to async processing mode
#
async.dispatchInProgress=La consegna asincrona \u00E8 gi\u00E0 in corso. \u00C8 necessario chiamare prima ServletRequest.startAsync.
async.addListenerIllegalState=AsyncContext.addListener non deve essere chiamato dopo che la consegna avviata dal contenitore, durante la quale \u00E8 stato chiamato ServletRequest.startAsync, viene restituita al contenitore
async.setTimeoutIllegalState=AsyncContext.setTimeout non deve essere chiamato dopo che la consegna avviata dal contenitore, durante la quale \u00E8 stato chiamato ServletRequest.startAsync, viene restituita al contenitore
async.listenerInvocationError=Errore durante il richiamo di AsyncListener
request.notInAsyncMode=La modalit\u00E0 asincrona non \u00E8 stata attivata per la richiesta. \u00C8 necessario chiamare prima ServletRequest.startAsync.
request.startAsync.notSupported=La richiesta rientra nell'ambito di un filtro o servlet che non supporta operazioni asincrone
request.startAsync.alreadyCalled=ServletRequest.startAsync \u00E8 stato richiamato senza una consegna asincrona o al di fuori dell'ambito di tale tipo di consegna o nell'ambito della stessa consegna
request.startAsync.alreadyComplete=Risposta gi\u00E0 chiusa
request.startAsync.notInScope=ServletRequest.startAsync \u00E8 stato chiamato al di fuori dell'ambito di una consegna asincrona
request.asyncComplete.alreadyComplete=Richiesta gi\u00E0 rilasciata dalla modalit\u00E0 asincrona
