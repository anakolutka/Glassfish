# Language pt-BR translations for Introduction_to_Web_Beans package.
# Automatically generated, 2009.
# 
# Bruno Leonardo Gonçalves <brunolmfg@gmail.com>, 2011. #zanata
# Bruno Leonardo Gonçalves <brunolmfg@gmail.com>, 2012. #zanata
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2012-01-16T16:07:16\n"
"PO-Revision-Date: 2009-12-19 18:11-0300\n"
"Last-Translator: João Paulo Viragine <joao.viragine@redhat.com>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: \n"

#. Tag: title
#, no-c-format
msgid "Java EE integration"
msgstr "Integração com o Java EE"

#. Tag: para
#, no-c-format
msgid ""
"CDI is fully integrated into the Java EE environment. Beans have access to "
"Java EE resources and JPA persistence contexts. They may be used in Unified "
"EL expressions in JSF and JSP pages. They may even be injected into other "
"platform components, such as servlets and message-driven Beans, which are "
"not beans themselves."
msgstr ""
"CDI está plenamente integrada ao ambiente Java EE. Os beans possuem acesso "
"aos recursos Java EE e aos contextos de persistência JPA. Eles podem ser "
"utilizados em expressões EL Unificadas (Unified EL) e em páginas JSF e JSP. "
"Podem até ser injetados em outros componentes da plataforma, tais como "
"servlets e message-driven Beans, que não são bens por si só."

#. Tag: title
#, no-c-format
msgid "Built-in beans"
msgstr "Beans embutidos"

#. Tag: para
#, no-c-format
msgid ""
"In the Java EE environment, the container provides the following built-in "
"beans, all with the qualifier <literal>@Default</literal>:"
msgstr ""
"No ambiente Java EE, o contêiner fornece os seguintes beans embutidos, todos"
" com o qualificador <literal>@Default</literal>:"

#. Tag: para
#, no-c-format
msgid "the current JTA <literal>UserTransaction</literal>,"
msgstr "o <literal>UserTransaction</literal> JTA corrente,"

#. Tag: para
#, no-c-format
msgid ""
"a <literal>Principal</literal> representing the current caller identity,"
msgstr ""
"um <literal>Principal</literal> representando a identidade do requisitante "
"corrente,"

#. Tag: para
#, no-c-format
msgid ""
"the default <ulink url=\"http://jcp.org/en/jsr/detail?id=303\">Bean "
"Validation</ulink> <literal>ValidationFactory</literal>, and"
msgstr ""
"a <literal>ValidationFactory</literal> padrão da <ulink "
"url=\"http://jcp.org/en/jsr/detail?id=303\">Bean Validation</ulink>, e"

#. Tag: para
#, no-c-format
msgid ""
"a <literal>Validator</literal> for the default "
"<literal>ValidationFactory</literal>."
msgstr ""
"um <literal>Validator</literal> para a <literal>ValidationFactory</literal> "
"padrão."

#. Tag: para
#, no-c-format
msgid ""
"The CDI specification does not require the servlet context objects, "
"<literal>HttpServletRequest</literal>, <literal>HttpSession</literal> and "
"<literal>ServletContext</literal> to be exposed as injectable beans. If you "
"really want to be able to inject these objects, it's easy to create a "
"portable extension to expose them as beans. However, we recommend that "
"direct access to these objects be limited to servlets, servlet filters and "
"servlet event listeners, where they may be obtained in the usual way as "
"defined by the Java Servlets spec. The <literal>FacesContext</literal> is "
"also not injectable. You can get at it by calling "
"<literal>FacesContext.getCurrentInstance()</literal>."
msgstr ""
"A especificação CDI não requer que os objetos de contexto de servlet "
"<literal>HttpServletRequest</literal>, <literal>HttpSession</literal> e "
"<literal>ServletContext</literal> sejam expostos como beans injetáveis. Se "
"você realmente quer ser capaz de injetar estes objetos, é fácil criar uma "
"extensão portável para expô-los como beans. No entanto, recomendamos que o "
"acesso direto a estes objetos estejam limitados a servlets, servlet filters "
"e servlet event listeners, onde podem ser obtidos da maneira usual, tal como"
" definido pela especificação Java Servlets. O objeto "
"<literal>FacesContext</literal> também não é injetável. Você pode obtê-lo "
"chamando <literal>FacesContext.getCurrentInstance()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Oh, you <emphasis>really</emphasis> want to inject the "
"<literal>FacesContext</literal>? Alright then, try this producer method:"
msgstr ""
"Oh, você <emphasis>realmente</emphasis> quer injetar o "
"<literal>FacesContext</literal>? Tudo bem então, tente este método produtor:"

#. Tag: programlisting
#, no-c-format
msgid ""
"class FacesContextProducer {\n"
"   @Produces @RequestScoped FacesContext getFacesContext() {\n"
"      return FacesContext.getCurrentInstance();\n"
"   }\n"
"}"
msgstr ""
"class FacesContextProducer {\n"
"   @Produces @RequestScoped FacesContext getFacesContext() {\n"
"      return FacesContext.getCurrentInstance();\n"
"   }\n"
"}"

#. Tag: title
#, no-c-format
msgid "Injecting Java EE resources into a bean"
msgstr "Injetando recursos Java EE em um bean"

#. Tag: para
#, no-c-format
msgid ""
"All managed beans may take advantage of Java EE component environment "
"injection using <literal>@Resource</literal>, <literal>@EJB</literal>, "
"<literal>@PersistenceContext</literal>, <literal>@PeristenceUnit</literal> "
"and <literal>@WebServiceRef</literal>. We've already seen a couple of "
"examples of this, though we didn't pay much attention at the time:"
msgstr ""
"Todos os beans gerenciados poder tirar vantagem da injeção de componentes do"
" ambiente Java EE usando <literal>@Resource</literal>, "
"<literal>@EJB</literal>, <literal>@PersistenceContext</literal>, "
"<literal>@PeristenceUnit</literal> e <literal>@WebServiceRef</literal>. Nós "
"já vimos uma porção de exemplos disto, embora não tenhamos prestado muita "
"atenção no momento:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Transactional @Interceptor\n"
"public class TransactionInterceptor {\n"
"   @Resource UserTransaction transaction;\n"
"\n"
"   @AroundInvoke public Object manageTransaction(InvocationContext ctx) throws Exception { ... }\n"
"}"
msgstr ""
"@Transactional @Interceptor\n"
"public class TransactionInterceptor {\n"
"   @Resource UserTransaction transaction;\n"
"\n"
"   @AroundInvoke public Object manageTransaction(InvocationContext ctx) throws Exception { ... }\n"
"}"

#. Tag: programlisting
#, no-c-format
msgid ""
"@SessionScoped\n"
"public class Login implements Serializable {\n"
"   @Inject Credentials credentials;\n"
"   @PersistenceContext EntityManager userDatabase;\n"
"    ...\n"
"}"
msgstr ""
"@SessionScoped\n"
"public class Login implements Serializable {\n"
"   @Inject Credentials credentials;\n"
"   @PersistenceContext EntityManager userDatabase;\n"
"    ...\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"The Java EE <literal>@PostConstruct</literal> and "
"<literal>@PreDestroy</literal> callbacks are also supported for all managed "
"beans. The <literal>@PostConstruct</literal> method is called after "
"<emphasis>all</emphasis> injection has been performed."
msgstr ""
"As chamadas Java EE <literal>@PostConstruct</literal> e "
"<literal>@PreDestroy</literal> também são suportadas em todos os beans "
"controlados. O método anotado com <literal>@PostConstruct</literal> é "
"invocado após <emphasis>todas</emphasis> injeções serem realizadas."

#. Tag: para
#, no-c-format
msgid ""
"Of course, we advise that component environment injection be used to define "
"CDI resources, and that typesafe injection be used in application code."
msgstr ""
"Certamente, aconselhamos que a injeção de componentes do ambiente seja usada"
" para definir recursos CDI, e que injeção typesafe seja usada no código da "
"aplicação."

#. Tag: title
#, no-c-format
msgid "Calling a bean from a servlet"
msgstr "Invocando um bean a partir de um Servlet"

#. Tag: para
#, no-c-format
msgid ""
"It's easy to use a bean from a servlet in Java EE 6. Simply inject the bean "
"using field or initializer method injection."
msgstr ""
"É fácil usar um bean a partir de uma servlet no Java EE 6. Simplesmente "
"injete o bean usando um campo ou injeção por um método inicializador."

#. Tag: programlisting
#, no-c-format
msgid ""
"public class Login extends HttpServlet {\n"
"   @Inject Credentials credentials;\n"
"   @Inject Login login;\n"
"\n"
"   @Override\n"
"   public void service(HttpServletRequest request, HttpServletResponse response)\n"
"      throws ServletException, IOException {\n"
"      credentials.setUsername(request.getParameter(\"username\")):\n"
"      credentials.setPassword(request.getParameter(\"password\")):\n"
"      login.login();\n"
"      if ( login.isLoggedIn() ) {\n"
"         response.sendRedirect(\"/home.jsp\");\n"
"      }\n"
"      else {\n"
"         response.sendRedirect(\"/loginError.jsp\");\n"
"      }\n"
"   }\n"
"            \n"
"}"
msgstr ""
"public class Login extends HttpServlet {\n"
"   @Inject Credentials credentials;\n"
"   @Inject Login login;\n"
"\n"
"   @Override\n"
"   public void service(HttpServletRequest request, HttpServletResponse response)\n"
"      throws ServletException, IOException {\n"
"      credentials.setUsername(request.getParameter(\"username\")):\n"
"      credentials.setPassword(request.getParameter(\"password\")):\n"
"      login.login();\n"
"      if ( login.isLoggedIn() ) {\n"
"         response.sendRedirect(\"/home.jsp\");\n"
"      }\n"
"      else {\n"
"         response.sendRedirect(\"/loginError.jsp\");\n"
"      }\n"
"   }\n"
"            \n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"Since instances of servlets are shared across all incoming threads, the bean"
" client proxy takes care of routing method invocations from the servlet to "
"the correct instances of <literal>Credentials</literal> and "
"<literal>Login</literal> for the current request and HTTP session."
msgstr ""
"Uma vez que instâncias de servlets são compartilhadas através de todas "
"threads entrantes, o proxy cliente cuida do encaminhamento das invocações "
"dos métodos do servlet para as instâncias corretas de "
"<literal>Credentials</literal> e <literal>Login</literal> para a requisição "
"e sessão HTTP atuais."

#. Tag: title
#, no-c-format
msgid "Calling a bean from a message-driven bean"
msgstr "Invocando um bean a partir de um message-driven bean"

#. Tag: para
#, no-c-format
msgid ""
"CDI injection applies to all EJBs, even when they aren't managed beans. In "
"particular, you can use CDI injection in message-driven beans, which are by "
"nature not contextual objects."
msgstr ""
"A injeção CDI se aplica a todos EJBs, mesmo quando eles não são beans "
"gerenciados. Em especial, você pode usar injeção CDI em message-driven "
"beans, os quais são por natureza objetos não contextuais."

#. Tag: para
#, no-c-format
msgid "You can even use CDI interceptor bindings for message-driven Beans."
msgstr ""
"Você ainda pode usar bindings de interceptação da CDI em message-driven "
"Beans."

#. Tag: programlisting
#, no-c-format
msgid ""
"@Transactional @MessageDriven\n"
"public class ProcessOrder implements MessageListener {\n"
"   @Inject Inventory inventory;\n"
"   @PersistenceContext EntityManager em;\n"
"\n"
"   public void onMessage(Message message) {\n"
"      ...\n"
"   }\n"
"}"
msgstr ""
"@Transactional @MessageDriven\n"
"public class ProcessOrder implements MessageListener {\n"
"   @Inject Inventory inventory;\n"
"   @PersistenceContext EntityManager em;\n"
"\n"
"   public void onMessage(Message message) {\n"
"      ...\n"
"   }\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"Please note that there is no session or conversation context available when "
"a message is delivered to a message-driven bean. Only "
"<literal>@RequestScoped</literal> and <literal>@ApplicationScoped</literal> "
"beans are available."
msgstr ""
"Note que existe nenhuma sessão ou contexto de conversação disponível quando "
"uma mensagem é entregue a um message-driven bean. Apenas benas "
"<literal>@RequestScoped</literal> e <literal>@ApplicationScoped</literal> "
"estão disponíveis."

#. Tag: para
#, no-c-format
msgid "But how about beans which <emphasis>send</emphasis> JMS messages?"
msgstr "Mas como que beans <emphasis>enviam</emphasis> mensagens JMS?"

#. Tag: title
#, no-c-format
msgid "JMS endpoints"
msgstr "Endpoints JMS"

#. Tag: para
#, no-c-format
msgid ""
"Sending messages using JMS can be quite complex, because of the number of "
"different objects you need to deal with. For queues we have "
"<literal>Queue</literal>, <literal>QueueConnectionFactory</literal>, "
"<literal>QueueConnection</literal>, <literal>QueueSession</literal> and "
"<literal>QueueSender</literal>. For topics we have <literal>Topic</literal>,"
" <literal>TopicConnectionFactory</literal>, "
"<literal>TopicConnection</literal>, <literal>TopicSession</literal> and "
"<literal>TopicPublisher</literal>. Each of these objects has its own "
"lifecycle and threading model that we need to worry about."
msgstr ""
"O envio de mensagens usando JMS pode ser bastante complexo, devido à "
"quantidade de objetos diferentes que precisamos utilizar. Para filas, temos "
"<literal>Queue</literal>, <literal>QueueConnectionFactory</literal>, "
"<literal>QueueConnection</literal>, <literal>QueueSession</literal> e "
"<literal>QueueSender</literal>. Para os tópicos, temos "
"<literal>Topic</literal>, <literal>TopicConnectionFactory</literal>, "
"<literal>TopicConnection</literal>, <literal>TopicSession</literal> e "
"<literal>TopicPublisher</literal>. Cada um desses objetos tem seu  próprio "
"ciclo de vida e modelo de threads, com que temos de nos preocupar."

#. Tag: para
#, no-c-format
msgid ""
"You can use producer fields and methods to prepare all of these resources "
"for injection into a bean:"
msgstr ""
"Você pode usar campos e métodos produtores para preparar todos estes "
"recursos para injeção em um bean:"

#. Tag: programlisting
#, no-c-format
msgid ""
"public class OrderResources {\n"
"   @Resource(name=\"jms/ConnectionFactory\")\n"
"   private ConnectionFactory connectionFactory;\n"
"  \n"
"   @Resource(name=\"jms/OrderQueue\")\n"
"   private Queue orderQueue;\n"
"  \n"
"   @Produces @OrderConnection\n"
"   public Connection createOrderConnection() throws JMSException {\n"
"    return connectionFactory.createConnection();\n"
"   }\n"
"  \n"
"   public void closeOrderConnection(@Disposes @OrderConnection Connection connection)\n"
"         throws JMSException {\n"
"      connection.close();\n"
"   }\n"
"  \n"
"   @Produces @OrderSession\n"
"   public Session createOrderSession(@OrderConnection Connection connection)\n"
"         throws JMSException {\n"
"      return connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n"
"   }\n"
"  \n"
"   public void closeOrderSession(@Disposes @OrderSession Session session)\n"
"         throws JMSException {\n"
"      session.close();\n"
"   }\n"
"  \n"
"   @Produces @OrderMessageProducer\n"
"   public MessageProducer createOrderMessageProducer(@OrderSession Session session)\n"
"         throws JMSException {\n"
"      return session.createProducer(orderQueue);\n"
"   }\n"
"  \n"
"   public void closeOrderMessageProducer(@Disposes @OrderMessageProducer MessageProducer producer)\n"
"         throws JMSException {\n"
"      producer.close();\n"
"   }\n"
"}"
msgstr ""
"public class OrderResources {\n"
"   @Resource(name=\"jms/ConnectionFactory\")\n"
"   private ConnectionFactory connectionFactory;\n"
"  \n"
"   @Resource(name=\"jms/OrderQueue\")\n"
"   private Queue orderQueue;\n"
"  \n"
"   @Produces @OrderConnection\n"
"   public Connection createOrderConnection() throws JMSException {\n"
"    return connectionFactory.createConnection();\n"
"   }\n"
"  \n"
"   public void closeOrderConnection(@Disposes @OrderConnection Connection connection)\n"
"         throws JMSException {\n"
"      connection.close();\n"
"   }\n"
"  \n"
"   @Produces @OrderSession\n"
"   public Session createOrderSession(@OrderConnection Connection connection)\n"
"         throws JMSException {\n"
"      return connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n"
"   }\n"
"  \n"
"   public void closeOrderSession(@Disposes @OrderSession Session session)\n"
"         throws JMSException {\n"
"      session.close();\n"
"   }\n"
"  \n"
"   @Produces @OrderMessageProducer\n"
"   public MessageProducer createOrderMessageProducer(@OrderSession Session session)\n"
"         throws JMSException {\n"
"      return session.createProducer(orderQueue);\n"
"   }\n"
"  \n"
"   public void closeOrderMessageProducer(@Disposes @OrderMessageProducer MessageProducer producer)\n"
"         throws JMSException {\n"
"      producer.close();\n"
"   }\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"In this example, we can just inject the prepared "
"<literal>MessageProducer</literal>, <literal>Connection</literal> or "
"<literal>QueueSession</literal>:"
msgstr ""
"Neste exemplo, podemos injetar apenas <literal>MessageProducer</literal>, "
"<literal>Connection</literal> ou <literal>QueueSession</literal>:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Inject Order order;\n"
"@Inject @OrderMessageProducer MessageProducer producer;\n"
"@Inject @OrderSession QueueSession orderSession;\n"
"\n"
"public void sendMessage() {\n"
"   MapMessage msg = orderSession.createMapMessage();\n"
"   msg.setLong(\"orderId\", order.getId());\n"
"   ...\n"
"   producer.send(msg);\n"
"}"
msgstr ""
"@Inject Order order;\n"
"@Inject @OrderMessageProducer MessageProducer producer;\n"
"@Inject @OrderSession QueueSession orderSession;\n"
"\n"
"public void sendMessage() {\n"
"   MapMessage msg = orderSession.createMapMessage();\n"
"   msg.setLong(\"orderId\", order.getId());\n"
"   ...\n"
"   producer.send(msg);\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"The lifecycle of the injected JMS objects is completely controlled by the "
"container."
msgstr ""
"O ciclo de vida dos objetos JMS injetados são completamente controlados pelo"
" contêiner."

#. Tag: title
#, no-c-format
msgid "Packaging and deployment"
msgstr "Empacotamento e implantação"

#. Tag: para
#, no-c-format
msgid ""
"CDI doesn't define any special deployment archive. You can package beans in "
"jars, ejb jars or wars&mdash;any deployment location in the application "
"classpath. However, the archive must be a \"bean archive\". That means each "
"archive that contains beans <emphasis>must</emphasis> include a file named "
"<literal>beans.xml</literal> in the <literal>META-INF</literal> directory of"
" the classpath or <literal>WEB-INF</literal> directory of the web root (for "
"war archives). The file may be empty. Beans deployed in archives that do not"
" have a <literal>beans.xml</literal> file will not be available for use in "
"the application."
msgstr ""
"CDI não define qualquer arquivo de implantação especial. Você pode empacotar"
" beans em jars, ejb jars ou wars&mdash;qualquer local no classpath da "
"aplicação em implantação. Entretanto, o arquivo deve ser um \"arquivo de "
"beans\". Isto significa que arquivos contendo beans "
"<emphasis>deve</emphasis> incluir um arquivo nomeado como "
"<literal>beans.xml</literal> no diretório <literal>META-INF</literal> do "
"classpath ou no diretório <literal>WEB-INF</literal> (para arquivos war). O "
"arquivo pode ser vazio. Os beans implantados em arquivos que não possuam um "
"<literal>beans.xml</literal> não estarão disponíveis para uso na aplicação."

#. Tag: para
#, no-c-format
msgid ""
"In an embeddable EJB container, beans may be deployed in any location in "
"which EJBs may be deployed. Again, each location must contain a "
"<literal>beans.xml</literal> file."
msgstr ""
"Em um contêiner EJB embutido, os beans podem ser implantados em qualquer "
"local em que EJBs podem ser implantados. Novamente, cada local deve conter "
"um arquivo <literal>beans.xml</literal>."
