<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id: usingvalidator.xml 17842 2009-10-26 16:45:45Z hardy.ferentschik $ -->
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ Copyright (c) 2009, Red Hat, Inc. and/or its affiliates  or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat, Inc.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="validator-usingvalidator">
  <title>Validation step by step</title>

  <para>In this chapter we will see in more detail how to use Hibernate
  Validator to validate constraints for a given entity model. We will also
  learn which default constraints the Bean Validation specification provides
  and which additional constraints are only provided by Hibernate Validator.
  Let's start with how to add constraints to an entity.</para>

  <section id="validator-usingvalidator-annotate" revision="1">
    <title>Defining constraints</title>

    <para>Constraints in Bean Validation are expressed via Java annotations.
    In this section we show how to annotate an object model with these
    annotations. We have to differentiate between three different type of
    constraint annotations - field-, property-, and class-level
    annotations.</para>

    <note>
      <para>Not all constraints can be placed on all of these levels. In fact,
      none of the default constraints defined by Bean Validation can be placed
      at class level. The <classname>java.lang.annotation.Target</classname>
      annotation in the constraint annotation itself determines on which
      elements a constraint can be placed. See <xref
      linkend="validator-customconstraints" /> for more information.</para>
    </note>

    <section>
      <title>Field-level constraints</title>

      <para>Constraints can be expressed by annotating a field of a class.
      <xref linkend="example-field-level" /> shows a field level configuration
      example:</para>

      <example id="example-field-level">
        <title>Field level constraint</title>

        <programlisting>package com.mycompany;

import javax.validation.constraints.NotNull;

public class Car {

    <emphasis role="bold">@NotNull</emphasis>
    private String manufacturer;

    <emphasis role="bold">@AssertTrue</emphasis>
    private boolean isRegistered;

    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }
}</programlisting>
      </example>

      <para>When using field level constraints field access strategy is used
      to access the value to be validated. This means the instance variable
      directly independed of the access type.</para>

      <note>
        <para>The access type (private, protected or public) does not
        matter.</para>
      </note>

      <note>
        <para>Static fields and properties cannot be validated.</para>
      </note>
    </section>

    <section>
      <title>Property-level constraints</title>

      <para>If your model class adheres to the <ulink type=""
      url="http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp">JavaBeans</ulink>
      standard, it is also possible to annotate the properties of a bean class
      instead of its fields. <xref linkend="example-property-level" /> uses
      the same entity as in <xref linkend="example-field-level" />, however,
      property level constraints are used.<note>
          <para>The property's getter method has to be annotated, not its
          setter.</para>
        </note></para>

      <example id="example-property-level">
        <title>Property level constraint</title>

        <programlisting>package com.mycompany;

import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.NotNull;

public class Car {

    private String manufacturer;

    private boolean isRegistered;
      
    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    <emphasis role="bold">@NotNull</emphasis>
    public String getManufacturer() {
        return manufacturer;
    }

    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    <emphasis role="bold">@AssertTrue</emphasis>
    public boolean isRegistered() {
        return isRegistered;
    }

    public void setRegistered(boolean isRegistered) {
        this.isRegistered = isRegistered;
    }
}</programlisting>
      </example>

      <para>When using property level constraints property access strategy is
      used to access the value to be validated. This means the bean validation
      provider accesses the state via the property accessor method.</para>

      <tip>
        <para>It is recommended to stick either to field
        <emphasis>or</emphasis> property annotation within one class. It is
        not recommended to annotate a field <emphasis>and</emphasis> the
        accompanying getter method as this would cause the field to be
        validated twice.</para>
      </tip>
    </section>

    <section>
      <title id="validator-usingvalidator-classlevel">Class-level
      constraints</title>

      <para>Last but not least, a constraint can also be placed on class
      level. When a constraint annotation is placed on this level the class
      instance itself passed to the
      <classname>ConstraintValidator</classname>. Class level constraints are
      useful if it is necessary to inspect more than a single property of the
      class to validate it or if a correlation between different state
      variables has to be evaluated. In <xref linkend="example-class-level" />
      we add the property <property>passengers</property> to the class
      <classname>Car</classname>. We also add the constraint
      <classname>PassengerCount</classname> on the class level. We will later
      see how we can actually create this custom constraint (see <xref
      linkend="validator-customconstraints" />). For now we it is enough to
      know that <classname>PassengerCount</classname> will ensure that there
      cannot be more passengers in a car than there are seats.</para>

      <para><example id="example-class-level">
          <title>Class level constraint</title>

          <programlisting language="Java">package com.mycompany;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

<emphasis role="bold">@PassengerCount</emphasis>
public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;
    
    private List&lt;Person&gt; passengers;
    
    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}</programlisting>
        </example></para>
    </section>

    <section>
      <title>Constraint inheritance</title>

      <para>When validating an object that implements an interface or extends
      another class, all constraint annotations on the implemented interface
      and parent class apply in the same manner as the constraints specified
      on the validated object itself. To make things clearer let's have a look
      at the following example:</para>

      <example>
        <title>Constraint inheritance using RentalCar</title>

        <programlisting>package com.mycompany;

import javax.validation.constraints.NotNull;

public class RentalCar extends Car {

    private String rentalStation;
    
    public RentalCar(String manufacturer, String rentalStation) {
        super(manufacturer);
        this.rentalStation = rentalStation;
    }
    
    <emphasis role="bold">@NotNull</emphasis>
    public String getRentalStation() {
        return rentalStation;
    }

    public void setRentalStation(String rentalStation) {
        this.rentalStation = rentalStation;
    }
}</programlisting>
      </example>

      <para>Our well-known class <classname>Car</classname> from <xref
      linkend="Car-example" /> is now extended by
      <classname>RentalCar</classname> with the additional property
      <property>rentalStation</property>. If an instance of
      <classname>RentalCar</classname> is validated, not only the
      <classname>@NotNull</classname> constraint on
      <property>rentalStation</property> is validated, but also the constraint
      on <property>manufacturer</property> from the parent class.</para>

      <para>The same would hold true, if <classname>Car</classname> were an
      interface implemented by <classname>RentalCar</classname>.</para>

      <para>Constraint annotations are aggregated if methods are overridden.
      If <classname>RentalCar</classname> would override the
      <methodname>getManufacturer()</methodname> method from
      <classname>Car</classname> any constraints annotated at the overriding
      method would be evaluated in addition to the
      <classname>@NotNull</classname> constraint from the super-class.</para>
    </section>

    <section>
      <title>Object graphs</title>

      <para>The Bean Validation API does not only allow to validate single
      class instances but also complete object graphs. To do so, just annotate
      a field or property representing a reference to another object with
      <classname>@Valid</classname>. If the parent object is validated, all
      referenced objects annotated with <classname>@Valid</classname> will be
      validated as well (as will be their children etc.). See <xref
      linkend="example-car-with-driver" />.</para>

      <example>
        <title>Class Person</title>

        <programlisting>package com.mycompany;

import javax.validation.constraints.NotNull;

public class Person {

    <emphasis role="bold">@NotNull</emphasis>
    private String name;
    
    public Person(String name) {
        super();
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</programlisting>
      </example>

      <example id="example-car-with-driver">
        <title>Adding a driver to the car</title>

        <programlisting>package com.mycompany;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    <emphasis role="bold">@NotNull</emphasis>
    <emphasis role="bold">@Valid</emphasis>
    private Person driver;
    
    public Car(Person driver) {
        this.driver = driver;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If an instance of <classname>Car</classname> is validated, the
      referenced <classname>Person</classname> object will be validated as
      well, as the <property>driver</property> field is annotated with
      <classname>@Valid</classname>. Therefore the validation of a
      <classname>Car</classname> will fail if the <property>name</property>
      field of the referenced <classname>Person</classname> instance is
      <code>null</code>.</para>

      <para>Object graph validation also works for collection-typed fields.
      That means any attributes that are</para>

      <itemizedlist>
        <listitem>
          <para>arrays</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.lang.Iterable</classname>
          (especially <classname>Collection</classname>,
          <classname>List</classname> and <classname>Set</classname>)</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.util.Map</classname></para>
        </listitem>
      </itemizedlist>

      <para>can be annotated with <classname>@Valid</classname>, which will
      cause each contained element to be validated, when the parent object is
      validated.</para>

      <example>
        <title>Car with a list of passengers</title>

        <programlisting>package com.mycompany;

import java.util.ArrayList;
import java.util.List;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    <emphasis role="bold">@Valid
    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();</emphasis>

    public Car(List&lt;Person&gt; passengers) {
        this.passengers = passengers;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If a <classname>Car</classname> instance is validated, a
      <classname>ConstraintValidation</classname> will be created, if any of
      the <classname>Person</classname> objects contained in the
      <property>passengers</property> list has a <code>null</code> name.<note>
          <para><classname>null</classname> values are getting ignored when
          validating object graphs.</para>
        </note></para>
    </section>
  </section>

  <section id="validator-usingvalidator-validate" revision="1">
    <title>Validating constraints</title>

    <para>The <classname>Validator</classname> interface is the main entry
    point to Bean Validation. In <xref linkend="section-validator-instance" />
    we will first show how to obtain an <classname>Validator</classname>
    instance. Afterwards we will learn how to use the different methods of the
    <classname>Validator</classname> interface.</para>

    <section id="section-obtaining-validator">
      <title>Obtaining a <classname>Validator</classname> instance</title>

      <para>The first step towards validating an entity instance is to get
      hold of a <classname>Validator</classname> instance. The road to this
      instance leads via the <classname>Validation</classname> class and a
      <classname>ValidatorFactory</classname>. The easiest way is to use the
      static
      <methodname>Validation.buildDefaultValidatorFactory()</methodname>
      method:<example>
          <title>Validation.buildDefaultValidatorFactory()</title>

          <programlisting>ValidatorFactory factory = <emphasis role="bold">Validation.buildDefaultValidatorFactory()</emphasis>;
Validator validator = factory.getValidator();</programlisting>
        </example>For other ways of obtaining a Validator instance see <xref
      linkend="validator-bootstrapping" />. For now we just want to see how we
      can use the <classname>Validator</classname> instance to validate entity
      instances.</para>
    </section>

    <section>
      <title>Validator methods</title>

      <para>The <classname>Validator</classname> interface contains three
      methods that can be used to either validate entire entities or just a
      single properties of the entity.</para>

      <para>All three methods return a
      <classname>Set&lt;ConstraintViolation&gt;</classname>. The set is empty,
      if the validation succeeds. Otherwise a
      <classname>ConstraintViolation</classname> instance is added for each
      violated constraint.</para>

      <para>All the validation methods have a var-args parameter which can be
      used to specify, which validation groups shall be considered when
      performing the validation. If the parameter is not specified the default
      validation group (<classname>javax.validation.Default</classname>) will
      be used. We will go into more detail on the topic of validation groups
      in <xref linkend="validator-usingvalidator-validationgroups" /></para>

      <section>
        <title><methodname>validate</methodname></title>

        <para>Use the <methodname>validate()</methodname> method to perform
        validation of all constraints of a given entity instance (see <xref
        linkend="example-validator-validate" /> ).</para>

        <example id="example-validator-validate">
          <title>Usage of
          <methodname>Validator.validate()</methodname></title>

          <programlisting>ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = <emphasis
              role="bold">validator.validate(car)</emphasis>;

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>
      </section>

      <section>
        <title><methodname>validateProperty</methodname></title>

        <para>With help of the <methodname>validateProperty()</methodname> a
        single named property of a given object can be validated. The property
        name is the JavaBeans property name.</para>

        <example>
          <title>Usage of
          <methodname>Validator.validateProperty()</methodname></title>

          <programlisting>Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = <emphasis
              role="bold">validator.validateProperty(car, "manufacturer")</emphasis>;

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>

        <para><methodname>Validator.validateProperty</methodname> is for
        example used in the integration of Bean Validation into JSF 2 (see
        <xref linkend="section-presentation-layer" />).</para>
      </section>

      <section>
        <title><methodname>validateValue</methodname></title>

        <para>Using the <methodname>validateValue() </methodname>method you
        can check, whether a single property of a given class can be validated
        successfully, if the property had the specified value:</para>

        <example>
          <title>Usage of
          <methodname>Validator.validateValue()</methodname></title>

          <programlisting>Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = <emphasis
              role="bold">validator.validateValue(Car.class, "manufacturer", null)</emphasis>;

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>

        <note>
          <para><classname>@Valid</classname> is not honored by
          <methodname>validateProperty()</methodname> or
          <methodname>validateValue()</methodname>.</para>
        </note>
      </section>
    </section>

    <section>
      <title><classname>ConstraintViolation</classname> methods</title>

      <para>Now it is time to have a closer look at what a
      <classname>ConstraintViolation</classname>. Using the different methods
      of <classname>ConstraintViolation</classname> a lot of useful
      information about the cause of the validation failure can be determined.
      <xref linkend="table-constraint-violation" /> gives an overview of these
      methods:</para>

      <table id="table-constraint-violation">
        <title>The various <classname>ConstraintViolation</classname>
        methods</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry>Method</entry>

              <entry>Usage</entry>

              <entry>Example (refering to <xref
              linkend="example-validator-validate" />)</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><methodname>getMessage()</methodname></entry>

              <entry>The interpolated error message.</entry>

              <entry>may not be null</entry>
            </row>

            <row>
              <entry><methodname>getMessageTemplate()</methodname></entry>

              <entry>The non-interpolated error message.</entry>

              <entry>{javax.validation.constraints.NotNull.message}</entry>
            </row>

            <row>
              <entry><methodname>getRootBean()</methodname></entry>

              <entry>The root bean being validated.</entry>

              <entry>car</entry>
            </row>

            <row>
              <entry><methodname>getRootBeanClass()</methodname></entry>

              <entry>The class of the root bean being validated.</entry>

              <entry>Car.class</entry>
            </row>

            <row>
              <entry><methodname>getLeafBean()</methodname></entry>

              <entry>If a bean constraint, the bean instance the constraint is
              applied on. If a property constraint, the bean instance hosting
              the property the constraint is applied on.</entry>

              <entry>car</entry>
            </row>

            <row>
              <entry><methodname>getPropertyPath()</methodname></entry>

              <entry>The property path to the value from root bean.</entry>

              <entry></entry>
            </row>

            <row>
              <entry><methodname>getInvalidValue()</methodname></entry>

              <entry>The value failing to pass the constraint.</entry>

              <entry>passengers</entry>
            </row>

            <row>
              <entry><methodname>getConstraintDescriptor()</methodname></entry>

              <entry>Constraint metadata reported to fail.</entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="section-message-interpolation">
      <title>Message interpolation</title>

      <para>As we will see in <xref linkend="validator-customconstraints" />
      each constraint definition must define a default message descriptor.
      This message can be overridden at declaration time using the
      <methodname>message</methodname> attribute of the constraint. You can
      see this in <xref linkend="example-driver" />. This message descriptors
      get interpolated when a constraint validation fails using the configured
      <classname>MessageInterpolator</classname>. The interpolator will try to
      resolve any message parameters, meaning string literals enclosed in
      braces. In order to resolve these parameters Hibernate Validator's
      default <classname>MessageInterpolator</classname> first recursively
      resolves parameters against a custom
      <classname>ResourceBundle</classname> called
      <filename>ValidationMessages.properties</filename> at the root of the
      classpath (It is up to you to create this file). If no further
      replacements are possible against the custom bundle the default
      <classname>ResourceBundle</classname> under
      <filename>/org/hibernate/validator/ValidationMessages.properties</filename>
      gets evaluated. If a replacement occurs against the default bundle the
      algorithm looks again at the custom bundle (and so on). Once no further
      replacements against these two resource bundles are possible remaining
      parameters are getting resolved against the attributes of the constraint
      to be validated.</para>

      <para>Since the braces { and } have special meaning in the messages they
      need to be escaped if they are used literally. The following The
      following rules apply:<itemizedlist>
          <listitem>
            <para>\{ is considered as the literal {</para>
          </listitem>

          <listitem>
            <para>\} is considered as the literal }</para>
          </listitem>

          <listitem>
            <para>\\ is considered as the literal \</para>
          </listitem>
        </itemizedlist></para>

      <para>If the default message interpolator does not fit your requirements
      it is possible to plug a custom
      <classname>MessageInterpolator</classname> when the
      <classname>ValidatorFactory</classname> gets created. This can be seen
      in <xref linkend="validator-bootstrapping" />.</para>
    </section>
  </section>

  <section id="validator-usingvalidator-validationgroups" revision="1">
    <title>Validating groups</title>

    <para>Groups allow you to restrict the set of constraints applied during
    validation. This makes for example wizard like validation possible where
    in each step only a specified subset of constraints get validated. The
    groups targeted are passed as var-args parameters to
    <methodname>validate</methodname>,
    <methodname>validateProperty</methodname> and
    <methodname>validateValue</methodname>. Let's have a look at an extended
    <classname>Car</classname> with <classname>Driver</classname> example.
    First we have the class <classname>Person</classname> (<xref
    linkend="example-person" />) which has a <classname>@NotNull
    </classname>constraint on <property>name</property>. Since no group is
    specified for this annotation its default group is
    <classname>javax.validation.Default</classname>.</para>

    <note>
      <para>When more than one group is requested, the order in which the
      groups are evaluated is not deterministic. If no group is specified the
      default group <classname>javax.validation.Default</classname> is
      assumed.</para>
    </note>

    <para><example id="example-person">
        <title>Person</title>

        <programlisting>public class Person {
    <emphasis role="bold">@NotNull</emphasis>
    private String name;

    public Person(String name) {
        this.name = name;
    }
    // getters and setters ...
}</programlisting>
      </example>Next we have the class <classname>Driver</classname> (<xref
    linkend="example-driver" />) extending <classname>Person</classname>. Here
    we are adding the properties <property>age</property> and
    <property>hasDrivingLicense</property>. In order to drive you must be at
    least 18 (<classname>@Min(18)</classname>) and you must have a driving
    license (<classname>@AssertTrue</classname>). Both constraints defined on
    these properties belong to the group <classname>DriverChecks</classname>.
    As you can see in <xref linkend="example-group-interfaces" /> the group
    <classname>DriverChecks</classname> is just a simple tagging interface.
    Using interfaces makes the usage of groups type safe and allows for easy
    refactoring. It also means that groups can inherit from each other via
    class inheritance.<note>
        <para>The Bean Validation specification does not enforce that groups
        have to be interfaces. Non interface classes could be used as well,
        but we recommend to stick to interfaces.</para>
      </note><example id="example-driver">
        <title>Driver</title>

        <programlisting>public class Driver extends Person {
    <emphasis role="bold">@Min(value = 18, message = "You have to be 18 to drive a car", groups = DriverChecks.class)</emphasis>
    public int age;

    <emphasis role="bold">@AssertTrue(message = "You first have to pass the driving test", groups = DriverChecks.class)</emphasis>
    public boolean hasDrivingLicense;

    public Driver(String name) {
        super( name );
    }

    public void passedDrivingTest(boolean b) {
        hasDrivingLicense = b;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}</programlisting>
      </example><example id="example-group-interfaces">
        <title>Group interfaces</title>

        <programlisting>public interface DriverChecks {
}

public interface CarChecks {
}</programlisting>
      </example>Last but not least we add the property
    <property>passedVehicleInspection</property> to the
    <classname>Car</classname> class (<xref linkend="example-car" />)
    indicating whether a car passed the road worthy tests.<example
        id="example-car">
        <title>Car</title>

        <programlisting>public class Car {
    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    <emphasis role="bold">@AssertTrue(message = "The car has to pass the vehicle inspection first", groups = CarChecks.class)</emphasis>
    private boolean passedVehicleInspection;

    @Valid
    private Driver driver;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }
}</programlisting>
      </example>Overall three different groups are used in our example.
    <property>Person.name</property>, <property>Car.manufacturer</property>,
    <property>Car.licensePlate</property> and
    <property>Car.seatCount</property> all belong to the
    <classname>Default</classname> group. <property>Driver.age</property> and
    <property>Driver.hasDrivingLicense</property> belong to
    <classname>DriverChecks</classname> and last but not least
    <property>Car.passedVehicleInspection</property> belongs to the group
    <classname>CarChecks</classname>. <xref linkend="example-drive-away" />
    shows how passing different group combinations to the
    <methodname>Validator.validate</methodname> method result in different
    validation results.<example id="example-drive-away">
        <title>Drive away</title>

        <programlisting>public class GroupTest {

    private static Validator validator;

    @BeforeClass
    public static void setUp() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void driveAway() {
        // create a car and check that everything is ok with it.
        Car car = new Car( "Morris", "DD-AB-123", 2 );
        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
        assertEquals( 0, constraintViolations.size() );

        // but has it passed the vehicle inspection?
        constraintViolations = validator.validate( car, CarChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals("The car has to pass the vehicle inspection first", constraintViolations.iterator().next().getMessage());

        // let's go to the vehicle inspection
        car.setPassedVehicleInspection( true );
        assertEquals( 0, validator.validate( car ).size() );

        // now let's add a driver. He is 18, but has not passed the driving test yet
        Driver john = new Driver( "John Doe" );
        john.setAge( 18 );
        car.setDriver( john );
        constraintViolations = validator.validate( car, DriverChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals( "You first have to pass the driving test", constraintViolations.iterator().next().getMessage() );

        // ok, John passes the test
        john.passedDrivingTest( true );
        assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );

        // just checking that everything is in order now
        assertEquals( 0, validator.validate( car, Default.class, CarChecks.class, DriverChecks.class ).size() );
    }
}</programlisting>
      </example>First we create a car and validate it using no explicit group.
    There are no validation errors, even though the property
    <property>passedVehicleInspection</property> is per default
    <constant>false</constant>. However, the constraint defined on this
    property does not belong to the default group.</para>

    <para>Next we just validate the <classname>CarChecks</classname> group
    which will fail until we make sure that the car passes the vehicle
    inspection.</para>

    <para>When we then add a driver to the car and validate against
    <classname>DriverChecks</classname> we get again a constraint violation
    due to the fact that the driver has not yet passed the driving test. Only
    after setting <property>passedDrivingTest</property> to true the
    validation against <classname>DriverChecks</classname> will pass.</para>

    <para>Last but not least, we show that all constraints are passing by
    validating against all defined groups.</para>

    <section revision="1">
      <title>Group sequences</title>

      <para>By default, constraints are evaluated in no particular order and
      this regardless of which groups they belong to. In some situations,
      however, it is useful to control the order of the constraints
      evaluation. In our example from <xref
      linkend="validator-usingvalidator-validationgroups" /> we could for
      example require that first all default car constraints are passing
      before we check the road worthiness of the car. Finally before we drive
      away we check the actual driver constraints. In order to implement such
      an order one would define a new interface and annotate it with
      <classname>@GroupSequence</classname> defining the order in which the
      groups have to be validated.</para>

      <note>
        <para>If at least one constraints fails in a sequenced group none of
        the constraints of the follwoing groups in the sequence get
        validated.</para>
      </note>

      <para><example>
          <title>Interface with @GroupSequence</title>

          <programlisting><emphasis role="bold">@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})</emphasis>
public interface OrderedChecks {
}</programlisting>
        </example></para>

      <para><warning>
          <para>Groups defining a sequence and groups composing a sequence
          must not be involved in a cyclic dependency either directly or
          indirectly, either through cascaded sequence definition or group
          inheritance. If a group containing such a circularity is evaluated,
          a <classname>GroupDefinitionException</classname> is raised.</para>
        </warning>The usage of the new sequence could then look like in <xref
      linkend="example-group-sequence" />.</para>

      <example id="example-group-sequence">
        <title>Usage of a group sequence</title>

        <programlisting>@Test
public void testOrderedChecks() {
    Car car = new Car( "Morris", "DD-AB-123", 2 );
    car.setPassedVehicleInspection( true );

    Driver john = new Driver( "John Doe" );
    john.setAge( 18 );
    john.passedDrivingTest( true );
    car.setDriver( john );

    assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );
}</programlisting>
      </example>
    </section>

    <section id="section-default-group-class">
      <title>Redefining the default group sequence of a class</title>

      <para>The @GroupSequence annotation also fulfills a second purpose. It
      allows you to redefine what the Default group means for a given class.
      To redefine <classname>Default</classname> for a class, place a
      <classname>@GroupSequence</classname> annotation on the class. The
      defined groups in the annotation express the sequence of groups that
      substitute <classname>Default</classname> for this class. <xref
      linkend="example-rental-car" /> introduces a new class RentalCar with a
      redfined default group. With this definition the check for all three
      groups can be rewritten as seen in <xref
      linkend="example-testOrderedChecksWithRedefinedDefault" />.</para>

      <example id="example-rental-car">
        <title>RentalCar</title>

        <programlisting>@GroupSequence({ RentalCar.class, CarChecks.class })
public class RentalCar extends Car {
    public RentalCar(String manufacturer, String licencePlate, int seatCount) {
        super( manufacturer, licencePlate, seatCount );
    }
}</programlisting>
      </example>

      <example id="example-testOrderedChecksWithRedefinedDefault">
        <title>testOrderedChecksWithRedefinedDefault</title>

        <programlisting>@Test
public void testOrderedChecksWithRedefinedDefault() {
    RentalCar rentalCar = new RentalCar( "Morris", "DD-AB-123", 2 );
    rentalCar.setPassedVehicleInspection( true );

    Driver john = new Driver( "John Doe" );
    john.setAge( 18 );
    john.passedDrivingTest( true );
    rentalCar.setDriver( john );

    assertEquals( 0, validator.validate( rentalCar, Default.class, DriverChecks.class ).size() );
}</programlisting>
      </example>

      <note>
        <para>Due to the fact that there cannot be a cyclic dependency in the
        group and group sequence definitions one cannot just add
        <classname>Default</classname> to the sequence redefining
        <classname>Default</classname> for a class. Instead the class itself
        should be added!</para>
      </note>
    </section>
  </section>

  <section id="validator-defineconstraints-builtin" revision="2">
    <title>Built-in constraints</title>

    <para>Hibernate Validator implements all of the default constraints
    specified in Bean Validation as well as some custom ones. <xref
    linkend="table-builtin-constraints" /> list all constraints available in
    Hibernate Validator.</para>

    <table id="table-builtin-constraints">
      <title>Built-in constraints</title>

      <tgroup cols="5">
        <colspec align="left" />

        <thead>
          <row>
            <entry>Annotation</entry>

            <entry>Part of Bean Validation Specification</entry>

            <entry>Apply on</entry>

            <entry>Use</entry>

            <entry>Hibernate Metadata impact</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>@AssertFalse</entry>

            <entry>yes</entry>

            <entry>field/property</entry>

            <entry>check that the annotated element is
            <constant>false</constant>.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@AssertTrue</entry>

            <entry>yes</entry>

            <entry>field/property</entry>

            <entry>check that the annotated element is
            <constant>true</constant>.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@DecimalMax</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective wrappers of the primitive types.</entry>

            <entry>The annotated element must be a number whose value must be
            lower or equal to the specified maximum. The parameter value is
            the string representation of the max value according to the
            <classname>BigDecimal</classname> string representation.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@DecimalMin</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective wrappers of the primitive types.</entry>

            <entry>The annotated element must be a number whose value must be
            higher or equal to the specified minimum. The parameter value is
            the string representation of the min value according to the
            <classname>BigDecimal</classname> string representation.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Digits(integer=, fraction=)</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective wrappers of the primitive types.</entry>

            <entry>Check whether the property is a number having up to
            <literal>integer</literal> digits and <literal>fraction</literal>
            fractional digits.</entry>

            <entry>Define column precision and scale.</entry>
          </row>

          <row>
            <entry>@Email</entry>

            <entry>no</entry>

            <entry>field/property. Needs to be a string.</entry>

            <entry>Check whether the specified string is a valid email
            address.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Future</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>java.util.Date</classname> and
            <classname>java.util.Calendar</classname>.</entry>

            <entry>Checks whether the annotated date is in the future.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Length(min=, max=)</entry>

            <entry>no</entry>

            <entry>field/property. Needs to be a string.</entry>

            <entry>Validate that the annotated string is between
            <parameter>min</parameter> and <parameter>max</parameter>
            included.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Max</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective wrappers of the primitive types.</entry>

            <entry>Checks whether the annotated value is less than or equal to
            the specified maximum.</entry>

            <entry>Add a check constraint on the column.</entry>
          </row>

          <row>
            <entry>@Min</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective wrappers of the primitive types.</entry>

            <entry>Check whether the annotated value is higher than or equal
            to the specified minimum.</entry>

            <entry>Add a check constraint on the column.</entry>
          </row>

          <row>
            <entry>@NotNull</entry>

            <entry>yes</entry>

            <entry>field/property</entry>

            <entry>Check that the annotated value is not
            <constant>null.</constant></entry>

            <entry>Column(s) are not null.</entry>
          </row>

          <row>
            <entry>@NotEmpty</entry>

            <entry>no</entry>

            <entry>field/property. Needs to be a string.</entry>

            <entry>Check if the string is not <constant>null</constant> nor
            empty.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Null</entry>

            <entry>yes</entry>

            <entry>field/property</entry>

            <entry>Check that the annotated value is
            <constant>null.</constant></entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Past</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>java.util.Date</classname> and
            <classname>java.util.Calendar</classname>.</entry>

            <entry>Checks whether the annotated date is in the past.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Pattern(regex=, flag=)</entry>

            <entry>yes</entry>

            <entry>field/property. Needs to be a string.</entry>

            <entry>Check if the annotated string match the regular expression
            <parameter>regex</parameter>.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Range(min=, max=)</entry>

            <entry>no</entry>

            <entry>field/property. Supported types are
            <classname>BigDecimal</classname>,
            <classname>BigInteger</classname>, <classname>String</classname>,
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname> and the
            respective wrappers of the primitive types.</entry>

            <entry>Check whether the annotated value lies between (inclusive)
            the specified minimum and maximum.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Size(min=, max=)</entry>

            <entry>yes</entry>

            <entry>field/property. Supported types are
            <classname>String</classname>, <classname>Collection</classname>,
            <classname>Map</classname> and
            <classname>arrays</classname>.</entry>

            <entry>Check if the annotated element size is between min and max
            (inclusive).</entry>

            <entry>Column length will be set to max.</entry>
          </row>

          <row>
            <entry>@Valid</entry>

            <entry>yes</entry>

            <entry>field/property</entry>

            <entry>Perform validation recursively on the associated
            object.</entry>

            <entry>none</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <note>
      <para>On top of the parameters indicated in <xref
      linkend="table-builtin-constraints" /> each constraint supports the
      parameters <parameter>message</parameter>, <parameter>groups</parameter>
      and <parameter>payload</parameter>. This is a requirement of the Bean
      Validation specification.</para>
    </note>

    <para>In some cases these built-in constraints will not fulfill your
    requirements. In this case you can literally in a minute write your own
    constraints. We will discuss this in <xref
    linkend="validator-customconstraints" /></para>
  </section>
</chapter>
