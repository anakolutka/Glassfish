<html>
<head>
	<title>RelaxNGCC <?ja?>マニュアル<?/ja?><?en?>manual<?/en?></title>
	<link rel="stylesheet" href="ngcc.css"/>
	<?ja?><meta HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=shift_jis"><?/ja?>
</head>
<body>
<a name="top">
<h1>RelaxNGCC <?ja?>マニュアル<?/ja?><?en?>Manual<?/en?></h1>
<div align="right">$Id: manual.htm,v 1.5 2002/06/26 13:08:48 kkawa Exp $</div>
<div><?ja?>目次<?/ja?><?en?>Contents<?/en?></div>
<ul>
<!--li><a href="#scope"><?ja?>スコープ<?/ja?><?en?>Scopes<?/en?></a></li-->
<li><a href="#markup"><?ja?>マークアップ<?/ja?><?en?>Syntax<?/en?></a></li>
	<ol>
		<li><a href="#ann_alias"  ><tt>c:alias</tt></a>
		<li><a href="#ann_java"   ><tt>c:java</tt></a>
		<li><a href="#ann_jbody"  ><tt>c:java-body</tt></a>
		<li><a href="#ann_jimprt" ><tt>c:java-import</tt></a>
		<li><a href="#ann_class"  ><tt>c:class</tt></a>
		<li><a href="#ann_package"><tt>c:package</tt></a>
		<li><a href="#ann_access" ><tt>c:access</tt></a>
		<li><a href="#ann_runtime"><tt>c:runtime-type</tt></a>
		<li><a href="#ann_return" ><tt>c:return-type/c:return-value</tt></a>
		<li><a href="#ann_params" ><tt>c:params/c:with-params</tt></a>
	</ol>
<li><a href="#usage"><?ja?>生成したコードの使い方<?/ja?><?en?>Usage of the Generated Code<?/en?></a></li>
<li><a href="#restrictions"><?ja?>制約事項<?/ja?><?en?>Restrictions<?/en?></a></li>
<li><a href="#tbd"><?ja?>未サポート機能<?/ja?><?en?>Unsupported Features<?/en?></a></li>
</ul>

<!--
<a name="scope">
<h2>1 <?ja?>スコープ<?/ja?><?en?>Scope<?/en?></h2>
<p>
	<?ja?>　RelaxNGCCにとって、スコープという概念が重要です。RelaxNGCCは次のルールでスコープを生成し、スコープ１つに対して１つのJavaのクラスを生成します。<?/ja?>
	<?en?>Scope is an important concept for RelaxNGCC. It generates scopes along following rules and outputs a Java class for each scope.<?/en?></p>
<ul>
<li><?ja?>それぞれのdefineブロック(startエレメントによるものも含む)が１スコープに対応します。<?/ja?><?en?>Each <tt>define</tt> block or <tt>start</tt> block corresponds to a scope.<?/en?></li>
<li><?ja?>ただし、<tt>class</tt>アトリビュート(後述)がついている要素を単独のスコープとして分離します。<?/ja?><?en?>However, elements with <tt>class</tt> attributes (described later) are separated into independent scopes.<?/en?></li>
<li><?ja?>さらに、defineエレメントに<tt>inline</tt>アトリビュートがついているとそのスコープはインライン展開され、別のスコープにとりこまれます。<?/ja?><?en?>Additionally, <tt>define</tt> elements with <tt>inline</tt> attributes are expanded into other scopes.<?/en?></li>
</ul>
<p><?ja?>例えば、次の文法は１つの<tt>start</tt>エレメント、２つの<tt>define</tt>エレメントを含んでいるので３つのスコープが生成されます。<?/ja?><?en?>For example, RelaxNGCC produces 3 scopes from the next grammar since it contains 1 <tt>start</tt> element and 2 <tt>define</tt> elements.<?/en?>
<pre>
&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;start&gt;
    ...
  &lt;/start&gt;
  &lt;define name="A"&gt;
    ...
  &lt;/define&gt;
  &lt;define name="B"&gt;
    ...
  &lt;/define&gt;
&lt;/grammar&gt;
</pre>
-->

<a name="markup">
<h2>1 <?ja?>マークアップ<?/ja?><?en?>Annotation Syntax<?/en?></h2>
<p>
	<?ja?>
		　RelaxNGCC独自のマークアップはすべて<br><br><tt style="font-weight:bold;">http://www.xml.gr.jp/xmlns/relaxngcc</tt><br><br>のnamespace-URIを持ちますが、このマニュアルではプレフィックス "<tt>c</tt>" を使用しています。マークアップは次に説明するように３種のエレメントと５種のアトリビュートから構成されます。
	<?/ja?>
	<?en?>
		all the attributes and elements defined in RelaxNGCC uses <tt style="font-weight:bold;">http://www.xml.gr.jp/xmlns/relaxngcc</tt> as the namespace URI. In this manual, we assume the prefix "<tt>c</tt>" is bound to this namespace URI.
	<?/en?>
</p>



<a name="ann_alias" />
<h3>1.1 <tt>c:alias</tt><?ja?>アトリビュート<?/ja?><?en?> attribute<?/en?></h3>
<p>
	<?ja?>
		　ユーザ定義のコードからアクセスするために、データに名前をつけます。この変数名で、生成されたクラス内にフィールドが追加されます。このアトリビュートをつけることのできるRELAX NGのエレメントは、<tt>data</tt>, <tt>text</tt>, <tt>ref</tt>, <tt>value</tt>, <tt>list</tt>の５つです。
	<?/ja?>
	<?en?>
		Adding this attribute to a RELAX NG pattern will cause the compiler to declare a field declaration inside the generated class. At run-time, if a string in an XML document matches the pattern, then the generated code stores that value to this field. This makes it possible for your code to acess those values. This attribute is applicable to the <tt>data</tt>, <tt>text</tt>, <tt>ref</tt>, <tt>value</tt>, and <tt>list</tt> pattern.
	<?/en?>
</p>
<pre>
&lt;data type="nonNegativeInteger" <em>c:alias="count"</em>/&gt;
</pre>
<p><!--?ja?>　aliasをつけたデータがJavaのオブジェクトとして何になるかは次の表のようにして決まります。<?/ja?>
<?en?> The type of the Java object named by the <tt>alias</tt> attribute is fixed by the following table.<?/en?>
</p>
<table border="1">
<tr><th>RELAX NG element</th><th>type</th></tr>
<tr><td><tt>data</tt></td><td>String (<a href="#modes">plain sax <?en?>mode<?/en?><?ja?>モード<?/ja?></a>), <?en?>otherwise <br>depends on datatype(other mode)<?/en?><?ja?>または<br>データ型に依存(その他のモード)<?/ja?>(*1)</td></tr>
<tr><td><tt>text</tt></td><td>String</td></tr>
<tr><td><tt>ref</tt></td><td><?en?>The class generated by RelaxNGCC for the destination scope of the reference.<?/en?><?ja?>このrefが参照する先のスコープに対応した、RelaxNGCCの生成したクラス<?/ja?></td></tr>
<tr><td><tt>value</tt></td><td>String</td></tr>
<tr><td><tt>list</tt></td><td>String (*2)</td></tr>
</table>
<p><?ja?>(*1) <tt>data</tt>の<tt>type</tt>アトリビュートに依存します。後述の<a href="#typemap">表</a>を参照してください。なお、RELAX NGはXML Schema Part2以外のデータ型を使うことも可能な設計になっていますが、RelaxNGCCは現在XML Schema Part2のみをサポートします。<br>(*2)<tt>list</tt>エレメントに<tt>alias</tt>をつけたときには全体が１個の文字列として扱われます。空白文字による分割は行われません。<?/ja?>
<?en?> (*1) The type depends on <tt>type</tt> attribute of the <tt>data</tt> element. The <a href="#typemap">table</a> in this document describes the correspondence. Although RELAX NG has the design that can use datatypes other than XML Schema Part2, RelaxNGCC supports only XML Schema Part 2.<br> (*2) If you place the <tt>alias</tt> attribute with a <tt>list</tt> element, the entire of the data that matches the <tt>list</tt> element is dealed as a string. RelaxNGCC does not split the data into whitespace-separated sequence of tokens.<?/en?>
</p-->
<p>
	<?ja?>
		<tt>ref</tt>/<tt>parentRef</tt>パターンに<tt>c:alias</tt>をつけた場合、それらが参照する先のスコープで戻り値として指定された値が得られます（一般には、これはスコープに対応するRelaxNGCCが生成したクラスそのものです）。
	<?/ja?>
	<?en?>
		Adding <tt>c:alias</tt> attribute to a <tt>ref</tt> or <tt>parentRef</tt> pattern will cause the specified variable to receive the value specified as the return value in the refrenced scope. By default, this is an instance of the generated class that was used to parse the referenced scope.
	<?/en?>
</p>
<p>
	<?ja?>
		<tt>list</tt>パターンに<tt>c:alias</tt>をつけたときにはリスト全体が１個の文字列として取り出されます。
	<?/ja?>
	<?en?>
		A <tt>c:alias</tt> attribute on a <tt>list</tt> pattern will cause the entire string (that matches to the whole <tt>list</tt> pattern) to be anchored.
	<?/en?>
</p>



<a name="ann_java" />
<h3>1.2 <tt>c:java</tt><?ja?>エレメント<?/ja?><?en?> element<?/en?></h3>
<p>
<?ja?>　ユーザ定義のJavaコードを記述します。コードから<tt>c:alias</tt>アトリビュートで定義した名前を使うことができます。記述したコードは、入力XMLの該当個所を読んだところで実行されます。<?/ja?>
<?en?> You can write a code fragment of Java in a <tt>c:java</tt> element. Within this fragment, you can refer to the data of an XML document by fields declared through <tt>alias</tt> attribites. The content of <tt>java</tt> element is executed when the input hits the position where the <tt>c:java</tt> element is written.<?/en?>
</p>
<pre>
&lt;element name="name"&gt;
  &lt;text <em>c:alias="name"</em>/&gt;
  <em>&lt;c:java&gt;System.out.println(name);&lt;/c:java&gt;</em>
&lt;/element&gt;
</pre>
<p>
<?ja?>　生成されたコードは最終的にはSAX2ベースの処理になるので、外に投げることのできる例外はSAXExceptionとその派生クラスに限られます。<?/ja?>
<?en?>The code fragment can throw <tt>SAXException</tt>s (or unchecked exceptions, as usual.)<?/en?>
</p>
<p>
<?ja?>
	　<tt>java</tt>エレメントは<tt>choice, interleave</tt>以外の子パターンをとる全てのパターンの中に書けます（<tt>start, define, group, optional, zeroOrMore, oneOrMore, mixed, list</tt>パターンの中）。
<?/ja?>
<?en?>
	A <tt>java</tt> element can be written inside any pattern that can take child patterns except <tt>choice</tt> and <tt>interleave</tt> (that is, as a child of <tt>start, define, group, optional, zeroOrMore, oneOrMore, mixed</tt>, and <tt>list</tt>.)
<?/en?>
</p>
<p>
<?ja?>　なおエレメント名に<tt>java</tt>を使っている理由は、将来他のプログラム言語（例えばC#）にも対応するかもしれないからです。<?/ja?>
<?en?> Note that the reason why we use the keyword "<tt>java</tt>" as an element name is that we are planning to support other languages (such as C#) in the future.<?/en?>
</p>



<a name="ann_jbody" />
<h3>1.3 <?ja?><tt>java-body</tt>エレメント<?/ja?><?en?><tt>java-body</tt> element<?/en?></h3>
<p>
	<?ja?>
		　生成されるクラスについて、補助的に使用するメソッドやデータメンバを記述します。ここで定義したものはjavaエレメント内のコードからアクセスできます。
	<?/ja?>
	<?en?>
		The body of this element is copied inside the body of the generate classes. Thus this is usually used to declare additional fields or helper methods.
	<?/en?>
<pre>
&lt;define name="x"&gt;
  <span class="emph-code">&lt;c:java-body&gt;
  private void echo(String msg) {
      System.out.println(msg);
  }
  &lt;/c:java-body&gt;</span>
  ...
&lt;/define&gt;
</pre>
<p>
<?ja?>　たとえばこのようにすると、この<tt>define</tt>ブロックの<tt>java</tt>エレメント内から<tt>echo</tt>メソッドが使えるようになります。<?/ja?>
<?en?> For example, With the above declaration, the <tt>echo</tt> method becomes available from all the <tt>java</tt> elements in this <tt>define</tt> block. <?/en?>
</p>
<p>
<?ja?>　<tt>java-body</tt>エレメントは、次の場所に書くことができます。<?/ja?>
<?en?> A <tt>java-body</tt> element can be written only as children of the following patterns:<?/en?>
<dl>
<dt>a. <?ja?><tt>grammar</tt>エレメントの直下<?/ja?><?en?><tt>grammar</tt> pattern<?/en?></dt>
<dd><?ja?>RelaxNGCCが生成するすべてのクラスのコードに、java-body内のコードが挿入されます。<?/ja?><?en?>The contents of <tt>java-body</tt> is copied to all the classes generated by RelaxNGCC.<?/en?></dd>
<dt>b. <?ja?><tt>start</tt>, <tt>define</tt>エレメントの直下<?/ja?><?en?><tt>start</tt> or <tt>define</tt> pattern<?/en?></dt>
<dd><?ja?>その<tt>start/define</tt>エレメントに対応して生成されるクラスのコードにのみ挿入されます。<?/ja?><?en?>The contents of <tt>java-body</tt> is copied only to the class that corresponds to that <tt>start</tt> or <tt>define</tt> element.<?/en?></dd>
</dl>



<a name="ann_jimprt" />
<h3>1.4 <?ja?><tt>java-import</tt>エレメント<?/ja?><?en?><tt>java-import</tt> element<?/en?></h3>
<p>
<?ja?>　<tt>java-body</tt>と違い、ソースコード中のクラス定義本体の外に記述するコードを記述します。ふつうJavaのimport宣言を記述します。これを置くことのできる位置と効果はjava-bodyと同じです。<?/ja?>
	<?en?>
		Works similar to <tt>c:java-body</tt> elements. The only difference is that the contents of a <tt>java-import</tt> element is copied before the definition of a class. Hence one would usually write import declarations by using the <tt>java-import</tt> element.
	<?/en?>
</p>
<pre>
<em>&lt;c:java-import&gt;
    import java.util.Set;
    import java.util.Iterator;
&lt;/c:java-import&gt;</em>
</pre>


<a name="#ann_class" />
<h3>1.5 <?ja?><tt>c:class</tt>アトリビュート<?/ja?><?en?><tt>c:class</tt> attribute<?/en?></h3>
<p>
	<?ja?>
		　<tt>start</tt>エレメント、<tt>define</tt>エレメントに記述して、それに対応するクラスの名前を指定します。Javaのクラス名として正しい文字列を指定する必要があります。省略時には、RelaxNGCCが適当な名前をつけてソースコードを生成します。
	<?/ja?>
	<?en?>
		The <tt>class</tt> attribute can appear at a <tt>start</tt> pattern or a <tt>define</tt> pattern, and specifies the name of the generated Java class. The value of <tt>class</tt> attribute must be a valid Java class. If it is omitted, RelaxNGCC generates a name for the class.
	<?/en?>
</p>
<pre>
&lt;start <em>c:class="Root"</em>&gt;
...
&lt;/start&gt;
</pre>
<!-- TODO:
<p>
<?ja?>　さらに、<tt>element</tt>、<tt>oneOrMore</tt>のようなRELAX NGの文法要素に<tt>class</tt>アトリビュートを書くこともできます。こうした場合には、アトリビュートを付加した要素に対応する部分を読むコードがJavaクラスとして切り出されます。このクラスはそれを囲む<tt>define/start</tt>エレメントに対応したクラスの内部クラスになるので、外のクラスのインスタンス変数にアクセスすることができます。<?/ja?>
<?en?> Additionally, the <tt>class</tt> attribute can appear at some RELAX NG elements such as <tt>element</tt> element or <tt>oneOrMore</tt> element. In this case, the corresponding block enclosed by the RELAX NG element is chopped off into a Java class. Since the class is located in the inner-class of the class for parent <tt>define</tt>/<tt>start</tt> element, you can access data members of the parent class including data named via <tt>alias</tt> attribute.<?/en?>
<pre>
&lt;define name="parent"&gt;
  &lt;c:body&gt;
  Set _Items = new HashSet();
  &lt;/c:body&gt;
  &lt;zeroOrMore <span class="emph-code">c:class="Item" c:alias="item"</span>&gt;
    &lt;data type="string" c:alias="_uri"/&gt;
    &lt;data type="string" c:alias="_location"/&gt;
    &lt;c:java&gt;
     _Items.add(this);
    &lt;/c:java&gt;
  &lt;/zeroOrMore&gt;
&lt;/define&gt;
</pre>

<p><?ja?>　なお、<tt>combine</tt>アトリビュートのついた<tt>define</tt>エレメントについては、結合先の<tt>define</tt>ブロックとマージされてひとつのクラスになるので、<tt>class</tt>アトリビュートは無視されます。<?/ja?><?en?>Note that the <tt>class</tt> attribute is ignored when the <tt>define</tt> element has <tt>combine</tt> attribute because the <tt>define</tt> block is merged into other block.<?/en?></p>

<h3>2.6 <?ja?><tt>inline</tt>アトリビュート<?/ja?><?en?><tt>inline</tt> attribute<?/en?></h3>
<p>
<?ja?>　スコープをインライン展開することを指定します。<tt>define</tt>エレメントに記入します。<span style="text-decoration:underline">特にテキストのみからなるスコープは、RelaxNGCCの都合上インライン展開しないと処理がうまくできないので注意が必要です。</span><?/ja?>
<?en?> The <tt>inline</tt> attribute can appear in <tt>define</tt> elements and indicates that the scope is expanded into other scopes refering to it. <span style="text-decoration:underline">Especially scopes that consists of only text elements must be expanded</span>. This is a restriction of RelaxNGCC.<?/en?>
</p>
<pre>
&lt;define name="block" <span class="emph-code">c:inline="true"</span>&gt;
...
</pre>
-->


<a name="ann_package" />
<h3>1.6 <tt>c:package</tt><?ja?>アトリビュート<?/ja?><?en?> attribute<?/en?></h3>
<p>
	<?ja?>
		　生成するソースコードがどのパッケージに属すかを指定します。ルートエレメントに記入します。この宣言は生成されるすべてのクラスに対して有効です。
	<?/ja?>
	<?en?>
		The <tt>package</tt> attribute can appear only on the root element of RELAX NG. Adding this attribute will cause a compiler to add the package declaration to all the files it generates.
	<?/en?>
</p>
<pre>
&lt;grammar ... <em>c:package="com.example.project1"</em>&gt;
...
</pre>




<a name="ann_access" />
<h3>1.7 <tt>c:access</tt><?ja?>アトリビュート<?/ja?><?en?> attribute<?/en?></h3>
<p>
	<?ja?>
		　生成するソースコードのアクセス修飾子("public final"など)を指定します。このアトリビュートは<tt>define</tt>エレメント、<tt>start</tt>エレメント、<tt>class</tt>アトリビュートを書いたエレメントに書くことができます。
	<?/ja?>
	<?en?>
		The <tt>c:access</tt> attribute causes the compiler to add the specified access modifiers (such as "public final") to the generated Java class. Only <tt>define</tt> and <tt>start</tt> pattern can carry this attribute.
	<?/en?>
</p>
<pre>
&lt;start <span class="emph-code">c:class="sample1"</span> <span class="emph-code">c:access="public final"</span>&gt;
...
&lt;/start&gt;
</pre>




<a name="ann_runtime" />
<h3>1.8 <tt>c:runtime-type</tt><?ja?>アトリビュート<?/ja?><?en?> attribute<?/en?></h3>
<p>
	<?en?>
		This attribute causes the compiler to use a user-defined runtime class instead of the default <tt>NGCCRuntime</tt> class. The value of the attribute must be a valid Java class that is derived from <tt>NGCCRuntime</tt>.
	<?/en?>
	<?ja?>
		標準の<tt>NGCCRuntime</tt>クラスの代わりに、この属性で指定されたユーザー定義のクラスを使うようにコンパイラに指示します。
	<?/ja?>
</p><p>
	<?en?>
		Only the root element (usually a <tt>&lt;grammar></tt> pattern) in the source schema can carry this attribute.
	<?/en?>
	<?ja?>
		この属性は、RELAX NG文法ファイルのルート要素でのみ指定可能です。
	<?/ja?>
</p>
<pre>
&lt;?xml version="1.0"?>
&lt;grammar <em>c:runtime-type="org.acme.foo.MyNGCCRuntime"</em> ...>
  ....
&lt;/grammar>
</pre>



<a name="ann_return" />
<h3>1.9 <tt>c:return-type/c:return-value</tt><?ja?>アトリビュート<?/ja?><?en?> attribute<?/en?></h3>
<p>
	<?en?>
		These attributes can be specified on <tt>&lt;define></tt> and <tt>&lt;start</tt> patterns, to specify the return value from a handler class.
	<?/en?>
	<?ja?>
		これらの属性を指定することで、生成されたハンドラクラスからの戻り値を指定できるようになります。これらの属性は、どちらも&lt;define>か&lt;start>パターンに対して指定可能です。
	<?/ja?>
</p><p>
	<?en?>
		<tt>c:return-value</tt> specifies the expression that will be evaluated to the return value from a handler, and <tt>c:return-type</tt> specifies its type. The return value will be assigned to the alias specified on the corresponding <tt>&lt;ref></tt> element.
	<tt>c:return-value</tt> defaults to "this", hence by default the handler object itself will be returned and assigned to the alias.
	<?/en?>
	<?ja?>
		<tt>c:return-value</tt>属性には、戻り値として評価される式を書きます。子ハンドラが処理を終了して親ハンドラに戻る際に、この式が評価されて結果が親ハンドラに返ります。親ハンドラ側では、<tt>c:alias</tt>属性を使って戻り値にアクセスすることができます。<tt>c:return-type</tt>属性は、この戻り値の型を指定します。ディフォルトでは、<tt>c:return-value</tt>は"this"になっているので、ハンドラ自身が返されます。
	<?/ja?>
</p><p>
	<?en?>
		In the following example, <tt>makeResult</tt> method will be called and the return value from that method will be returned from the handler.
	<?/en?>
	<?ja?>
		次の例では、<tt>makeResult</tt>関数が呼び出されて、その値が戻り値となります。
	<?/ja?>
</p>
<pre>
&lt;define name="foo" <em>c:return-type="String" c:return-value="makeResult()"</em>>
  &lt;c:java-body>
    private String makeResult() {
      ....
    }
  &lt;/c:java-body>
  ...
&lt;/define>

...


    &lt;ref name="foo" <em>c:alias="someStringVariable"</em>>
</pre>




<a name="ann_params" />
<h3>1.10 <tt>c:params/c:with-params</tt><?ja?>アトリビュート<?/ja?><?en?> attribute<?/en?></h3>
<p>
	<?en?>
		These two annotations are used together to allow a parent handler to pass parameters to the a handler.
	<?/en?>
	<?ja?>
		これらの属性は対で利用され、親ハンドラから子ハンドラへパラメータを渡すのに使われます。
	<?/ja?>
</p><p>
	<?en?>
		The <tt>c:params</tt> attribute can be specified on <tt>&lt;define></tt> and <tt>&lt;start</tt> elements to declare parameters. When a <tt>c:params</tt> is present, the <tt>c:with-params</tt> needs to be specified on the corresponding <tt>&lt;ref></tt> elements.
	<?/en?>
	<?ja?>
		<tt>c:params</tt>属性は、<tt>&lt;define></tt>か<tt>&lt;start></tt>パターンに対して指定でき、パラメータを宣言します。一方、<tt>c:with-params</tt>属性は、パラメータつきで宣言された<tt>&lt;define></tt>を参照する<tt>&lt;ref></tt>パターンに対して指定します。
	<?/ja?>
</p><p>
	<?en?>
		The value of the <tt>c:params</tt> attribute must be a camma(',')-separated list of type and variable name pairs, just like when you define arguments of a function. The value of the <tt>c:with-params</tt> attribute must be a camma-separated list of Java expressions, again just like when you invoke a method.
	<?/en?>
	<?ja?>
		<tt>c:params</tt>属性の値は、カンマ区切りの型-変数名ペアで、ちょうど関数を宣言する時のパラメータリストと同じ書式です。<tt>c:with-params</tt>は、同じくカンマ区切りの式の並びで、やはりちょうど関数を呼び出す時と同じ書式です。
	<?/ja?>
</p><p>
	<?en?>
		Once you specify a <tt>c:params</tt> attribute on a block, you need to have <tt>c:with-params</tt> attributes on all the <tt>&lt;ref/></tt> patterns that refer to it.
	<?/en?>
	<?ja?>
		あるブロックを<tt>c:params</tt>付きで宣言すると、そのブロックを参照する全ての<tt>&lt;ref/></tt>パターンに<tt>c:with-params</tt>が必要になるので注意してください。
	<?/ja?>
</p><p>
	<?en?>
		The compiler generated fields by the same name, and passed parameters are assigned to those fields, so you can access them from <tt>&lt;c:java-body></tt> or <tt>&lt;c:java></tt>.
	<?/en?>
	<?ja?>
		渡されたパラメータは、同名で生成されたフィールド変数にコピーされるので、<tt>&lt;c:java-body></tt>や<tt>&lt;c:java></tt>の中からアクセスできます。
	<?/ja?>
</p>
<pre>
&lt;define name="foo" <em>c:params="String a,boolean b,Object c"</em>>
  ...
  &lt;c:java>
    System.out.println(a);
  &lt;/c:java>
&lt;/define>

...

   &lt;ref name="foo" <em>c:with-params='"xyz",true,null'</em> />

...

   &lt;ref name="foo" <em>c:with-params='"test",false,System.out'</em> />
</pre>

<!--
<a name="modes">
<h2>3 <?ja?>RelaxNGCCの動作モード<?/ja?><?en?>Operation Modes of RelaxNGCC<?/en?></h2>
<p>
<?ja?>　RelaxNGCCでは、出力するソースコードのスタイルを３通りから選べます。それぞれの比較は次のようになります。<?/ja?>
<?en?> In RelaxNGCC, you can choose the style of generated Java source code from three kinds. The features of the three styles are following.<?/en?>
</p>
<table border="1" width="100%">
  
  <tr><th width="25%">&nbsp;</th><th width="25%"><?ja?>MSVモード<?/ja?><?en?>MSV mode<?/en?></th><th width="25%"><?ja?>Typed SAXモード<?/ja?><?en?>Typed SAX mode<?/en?></th><th width="25%"><?ja?>プレーンSAXモード<?/ja?><?en?>plain SAX mode<?/en?></th></tr>
  
  <tr><td><?ja?>RelaxNGCCの起動オプション<?/ja?><?en?>RelaxNGCC options<?/en?></td><td><tt>--msv</tt></td><td><tt>--typedsax</tt></td><td><tt><?ja?>デフォルトです<?/ja?><?en?>(default)<?/en?></tt></td></tr>
  
  <tr>
    <td><?ja?>概要<?/ja?><?en?>Description<?/en?></td>
    <td><?ja?>入力のXML文書はまずMSV(*1)に渡り、次にRelaxNGCCで生成したコードにTypedContentHandlerインタフェース経由で渡ります。<?/ja?><?en?>The input XML instance is checked by the RELAX NG implementation of MSV at first, and the generated code receives it via <tt>TypedContentHandler</tt> interface later.<?/en?></td>
    <td><?ja?>データ型チェックのためにMSV内のデータタイプライブラリを使用します。文書はMSVを介さないでSAX2経由で読まれます。<?/ja?><?en?>The MSV is used for only datatype function. The content of the input XML instance is passed via the SAX2 interface.<?/en?></td>
    <td><?ja?>データ型のサポートはなく、常にString型として扱われます。文書はMSVを介さないでSAX2経由で読まれます。<?/ja?><?en?>The datatypes are not supported. All datatypes are interpreted as string type. The content of the input XML instance is passed via the SAX2 interface.<?/en?></td>
  </tr>
  
  <tr><td><?ja?>必要なライブラリ<?/ja?><?en?>Required Libraries<?/en?></td><td><?ja?>生成したコードの実行にはMSVのフルセットが必要です。<?/ja?><?en?>Whole of MSV is required to execute the generated code.<?/en?></td><td><?ja?>MSVのうちデータタイプライブラリ(xsdlib.jar)のみが必要です。<?/ja?><?en?>Only datatype library(xsdlib.jar) is required.<?/en?></td><td><?ja?>MSVは必要ありません。JAXP準拠のSAXパーサがあれば動作します。<?/ja?><?en?>Only JAXP-based SAX parser is required but not the MSV.<?/en?></td></tr>
  
  <tr><td><?ja?>文書のバリデーション能力<?/ja?><?en?>Validation Ability<?/en?></td><td><?ja?>文書はMSVがチェックするため、不正な入力を検出できます。<?/ja?><?en?>Invalid input is rejected since the MSV validates the input instance.<?/en?></td><td colspan="2"><?ja?>ある程度独自のチェックをしますが、入力によってはinvalidなXML文書を見逃すことがあります。例えば余計なアトリビュートが追加されていても検出はできません。<?/ja?><?en?>The generated code checks the content of input XML instance at some level, but it is not perfect. For example, the generated code outputs no warnings if unnecessary attributes exist.<?/en?></td></tr>
  <tr><td><?ja?>生成したコードの実行時にRELAX NG文法が必要か？<?/ja?><?en?>Is the grammar necessary on execution of generated code?<?/en?></td><td><?ja?>MSVを使うために必要です。<?/ja?><?en?>Yes, the MSV requires the grammar.<?/en?></td><td colspan="2"><?ja?>文法構造は生成したソースコードにとりこまれているので不要です。<?/ja?><?en?>No, the information of the grammar is embedded in the generated code.<?/en?></td></tr>
  <tr><td><?ja?>実行時に必要な<tt>relaxngcc.runtime</tt>パッケージ内のクラス<?/ja?><?en?>Required classes in relaxngcc.runtime package at runtime<?/en?></td><td><tt>NGCCTypedContentHandler</tt></td><td colspan="2"><tt>NGCCPlainHandler</tt></td></tr>
</table>
<p>
<?ja?>(*) MSV: Sun Multi-Schema XML Validator の略。<a href="http://www.sun.com/software/xml/developers/multischema/">http://www.sun.com/software/xml/developers/multischema/</a>からダウンロードできます。<?/ja?>
<?en?>(*) MSV: Sun Multi-Schema XML Validator. It is available from <a href="http://www.sun.com/software/xml/developers/multischema/">http://www.sun.com/software/xml/developers/multischema/</a>.<?/en?>
</p>
<p>
<?ja?>従って、入力文書がvalidであることがすでに分かっている場合や厳密なバリデーションが不要な場合は、SAXTypeやプレーンSAXを使うことで効率化が図れます。<?/ja?>
<?en?> Therefore, when the validity of the input is guaranteed or strict validation is not mandatory, the TypedSAX mode and the plain-SAX mode are more convenient than MSV mode.<?/en?>
</p>
-->



<a name="usage">
<h2>2 <?ja?>生成したコードの使い方<?/ja?><?en?>Usage of the Generated Code<?/en?></h2>
<h3><?ja?>(このセクションはJAXPの知識を仮定しています。)<?/ja?><?en?>(This section assumes you are familiar with JAXP.)<?/en?></h3>
<p>
<?ja?>
	　RelaxNGCCが生成したコードをコンパイルしたり実行するには、JAXP対応のXMLパーサが必要です<?/ja?>
<?en?>
	To compile and run the code generated by RelaxNGCC, a JAXP-compliant XML parser is necessary.
<?/en?>
</p>
<p>
<?ja?>
	　生成したコードは、SAX2イベントを生成するあらゆるコンポーネントと組み合わせて利用可能です。SAX2イベントから生成されたコードを駆動する方法については、もとの文法の<tt>start</tt>エレメントに対応したクラスに付加される<tt>main()</tt>関数を参照してください。
<?/ja?>
<?en?>
	The generated code will work with any component that produces SAX2 events. For details, please refer to the <tt>main()</tt> function located at the class corresponding to the <tt>start</tt> pattern.
<?/en?>
</p>

<h3><?ja?>コンストラクタのカスタマイズ<?/ja?><?en?>Customizing constructors<?/en?></h2>
<p>
	<?ja?>
		　RelaxNGCCはコンストラクタを自分で生成するため、そのままではコンストラクタを書き換えることはできません。オブジェクトの生成時の処理を追加するには、イニシャライザを利用してください。
	<?/ja?>
	<?en?>
		RelaxNGCC uses the consturctor of the generated classes for its own purpose. This makes it impossible to customize the constructors through <tt>c:java-body</tt> elements. To add code executed at the instanciation of an object, use the instance initializer:
	<?/en?>
</p>
<pre>
&lt;define name="foo">
  <em>&lt;c:java-body>
    {// add your code here
        System.out.println("initializer");
    }
  &lt;/c:java-body></em>
</pre>
<!--br>
MSV mode:<br>
<tt>protected NGCCTypedContentHandler(TypeDetecter reader)</tt><br>
<br>
PlainSAX <?ja?>または<?/ja?><?en?>or<?/en?> TypedSAX mode:<br>
<tt>protected NGCCPlainHandler(XMLReader reader)</tt><br>

<p>
<?ja?>引数のreaderは入力データが準備されていなければなりません。<?/ja?><?en?>Note that the argument <tt>reader</tt> must be prepared for the input XML.<?/en?>
</p-->

<!--
<a name="typemap">
<h2>5 <?ja?>型の対応表<?/ja?><?en?>Type Correspondence Table<?/en?></h2>
<p>
<?ja?>　文法に書かれた型とJavaの型とのマッピングは次のようになります。これはRELAX NGのdataエレメントにRelaxNGCCのaliasアトリビュートをつけた場合に適用されます。現在、XML Schema Part2のデータ型のみがサポートされています。<?/ja?>
<?en?> This section describes the correspondences between the datatypes in XML and Java classes. The type of the object you named with alias attribute conforms on this table.<?/en?>
</p>
<table width="70%" border="1" align="center">
<tr><th><?ja?>XML Schema Part2の型<?/ja?><?en?>XML Schema Part2 Types<?/en?></th><th><?ja?>Javaの型<?/ja?><?en?>Java Types<?/en?></th></tr>
<tr><td><tt>boolean</tt></td><td><tt>java.lang.Boolean</tt></td></tr>
<tr><td><tt>byte</tt></td><td><tt>java.lang.Byte</tt></td></tr>
<tr><td><tt>short, unsignedByte</tt></td><td><tt>java.lang.Short</tt></td></tr>
<tr><td><tt>int, unsignedShort</tt></td><td><tt>java.lang.Integer</tt></td></tr>
<tr><td><tt>long, unsignedInt</tt></td><td><tt>java.lang.Long</tt></td></tr>
<tr><td><tt>unsignedLong</tt></td><td><tt>java.math.BigInteger</tt></td></tr>
<tr><td><tt>integer</tt></td><td rowspan="5"><tt>java.math.BigInteger</tt></td></tr>
<tr><td><tt>negativeInteger</tt></td></tr>
<tr><td><tt>positiveInteger</tt></td></tr>
<tr><td><tt>nonNegativeInteger</tt></td></tr>
<tr><td><tt>nonPositiveInteger</tt></td></tr>
<tr><td><tt>float</tt></td><td><tt>java.lang.Float</tt></td></tr>
<tr><td><tt>double</tt></td><td><tt>java.lang.Double</tt></td></tr>
<tr><td><tt>dateTime</tt></td><td rowspan="8"><tt>java.util.GregorianCalendar</tt></td></tr>
<tr><td><tt>date</tt></td></tr>
<tr><td><tt>time</tt></td></tr>
<tr><td><tt>gYear</tt></td></tr>
<tr><td><tt>gYearMonth</tt></td></tr>
<tr><td><tt>gMonth</tt></td></tr>
<tr><td><tt>gMonthDay</tt></td></tr>
<tr><td><tt>gDay</tt></td></tr>
<tr><td><tt>base64Binary</tt></td><td rowspan="2">byte[]</tt></td></tr>
<tr><td><tt>hexBinary</tt></td></tr>
<tr><td><?ja?>その他<?/ja?><?en?>Others<?/en?></td><td><tt>java.lang.String</tt></td></tr>
</table>
<p>
<?ja?>　この変換はMSV内のデータタイプライブラリに依存しています。MSVのドキュメントの、<tt>com.sun.msv.datatype.xsd</tt>パッケージの説明もあわせて参照してください。<?/ja?>
<?en?> These correspondences depend on the datatype library of MSV. See also the documentation of <tt>com.sun.msv.datatype.xsd</tt> package in MSV.<?/en?>
</p>
-->


<a name="restrictions">
<h2>3 <?ja?>制約事項<?/ja?><?en?>Restrictions<?/en?></h2>
<p>
<?ja?>
	　RelaxNGCCでは、どんな文法も読み込めるわけではなく、先読み１個で分岐を判断できる文法だけを受け付けます。
<?/ja?>
<?en?>
	There are grammars that cannot be handled by RelaxNGCC. Specifically, a grammar cannot be handled by RelaxNGCC if it needs a look-ahead.
<?/en?>
</p>
<pre>
 &lt;choice&gt;
   &lt;group&gt;
     &lt;element name="a"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a0");&lt;/c:java&gt;
     &lt;element name="x"&gt;&lt;text/&gt;&lt;/element&gt;
   &lt;/group&gt;
   &lt;group&gt;
     &lt;element name="a"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a1");&lt;/c:java&gt;
     &lt;element name="y"&gt;&lt;text/&gt;&lt;/element&gt;
   &lt;/group&gt;
 &lt;/choice&gt;
</pre>
<p>
<?ja?> このようなとき、最初に<tt>a</tt>エレメントをみただけではどちらのchoiceが正しいのかは判定できません。先読みをすれば<tt>x</tt>または<tt>y</tt>がきて判定可能になりますが、RelaxNGCCはこのような判定はできません。次のように書き換える必要があります。<?/ja?>
<?en?> In the above sample, correct branching on the <tt>choice</tt> pattern cannot be done until you read the next element, because both children of the choice starts with the <tt>a</tt> element. To avoid this, the grammar needs to be rewritten as follows:<?/en?>
</p>
<pre>
&lt;group&gt;
 &lt;element name="a"&gt;&lt;text/&gt;&lt;/element&gt;
 &lt;choice&gt;
   &lt;group&gt;
     &lt;element name="x"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a0");&lt;/c:java&gt;
   &lt;/group&gt;
   &lt;group&gt;
     &lt;element name="y"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a1");&lt;/c:java&gt;
   &lt;/group&gt;
 &lt;/choice&gt;
&lt;/group&gt;
</pre>
<p>
<?ja?>　文法がこの制約を満たさないとき、RelaxNGCCは警告メッセージを発します。特に文法があいまいな場合にはどう変形してもこの制約を逃れることができなくなるので注意が必要です。<?/ja?>
<?en?> If a grammar violates this restriction, RelaxNGCC raises a warning message. Note that some grammars are unable to rewrite in an unambigous way.<?/en?>
</p>
<p>
<?ja?>　情報科学の言葉で言えば、<tt>define</tt>や<tt>start</tt>ブロックを、SAXイベントを終端記号とした文脈自由文法として解釈したとき、それがLL(1)であるときに限りRelaxNGCCは取り扱えます。このあたりの議論はコンパイラの教科書に詳しく載っています。<?/ja?>
<?en?> In terms of information science, when we interpret the given RELAX NG grammar as a context free grammar by treating every SAX event as a terminal symbol, RelaxNGCC can treat only if that grammar is LL(1).<?/en?>
</p>

<a name="tbd">
<h2>4 <?ja?>未サポート機能<?/ja?><?en?>Unsupported Features<?/en?></h2>
<p>
<?ja?>　RELAX NGの仕様のうち、次の機能はまだサポートされていません。将来のバージョンで徐々に実装するつもりです。<?/ja?>
<?en?>RelaxNGCC does not support the following features of RELAX NG. Hopefully they will be implemented in a future version.<?/en?>
</p>
<ul>
<li><tt>externalRef</tt> <?ja?>エレメント<?/ja?><?en?>element<?/en?></li>
<li><?ja?>name-classを使ったアトリビュート<?/ja?><?en?>attributes using name-classes<?/en?></li>
</ul>
<hr>
<div align="right"><a href="index.htm">RelaxNGCC Home</a></div>

</body>
</html>