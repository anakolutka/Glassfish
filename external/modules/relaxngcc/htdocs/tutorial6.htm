<html>
<head>
	<title>RelaxNGCC <?ja?>チュートリアル６<?/ja?><?en?>Tutorial 6<?/en?></title>
	<link rel="stylesheet" href="ngcc.css">
	<?ja?><meta HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=shift_jis"><?/ja?>
</head>
<body>
<h1>RelaxNGCC <?ja?>チュートリアル６<?/ja?><?en?>Tutorial 6<?/en?></h1>
<div align=right>
	$Revision: 1.1 $ by <a href="mailto:kk@kohsuke.org">Kohsuke Kawaguchi</a>
</div>



<p>
	This tutorial describes how you can write code to parse documents by the code generated by the compiler.
	This is a two-step process. First, you set up a <tt>NGCCRuntime</tt> object (or its derived class if you are using <tt>c:runtime-type</tt> customization.) Second, you use another component, such as JAXP, to send SAX events to the generated code.
</p>

<h2>Setting up <tt>NGCCRuntime</tt></h2>
<p>
	Assume <tt>Foo</tt> is one of classes the compiler has generated. Then, the following code sets up a runtime object:
</p>
<pre>
NGCCRuntime runtime = new NGCCRuntime();
Foo foo = new Foo(runtime);
runtime.pushHandler(foo);
</pre>
<p>
	If you are using your own runtime class <tt>MyRuntime</tt>, then replace <tt>NGCCRuntime</tt> with <tt>MyRuntime</tt>. Similarly, if you specify <tt>c:params</tt> on the scope block, then you need to add whatever parameters to the constructor.
</p><p>
	Note that you can start parsing by any generated handler class.
</p>


<h2>Using JAXP</h2>
<p>
	Perhaps the most straight-forward way to parse an XML document is to use JAXP. This is should be very familar to those of you who already know JAXP. First, you need to create a new instance of <tt>XMLReader</tt>.
</p>
<pre>
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(true);
XMLReader reader = factory.newSAXParser().getXMLReader();
</pre>
<p>
	Then you set an <tt>NGCCRuntime</tt>, as initialized as above, as the content handler. 
</p>
<pre>
reader.setContentHandler(runtime);
</pre>
<p>
	Finally, you parse a document and retrieve a parsing result from the root handler object:
</p>
<pre>
reader.parse(inputSource);
doSomethingWith(foo);
</pre>




<h2>Combining with <tt>XMLFilter</tt></h2>
<p>
	Sometimes adding a simple filter between the XML parser and the generated handler makes the processing vastly simple.
</p><p>
	Take RelaxNGCC itself as an example, it uses itself to generate code to parse RELAX NG. RELAX NG allows foreign elements to appear in arbitrary positions, but we don't care about those elements.
</p><p>
	If we are to write a grammar that handles this, we have to have a lot of <tt>&lt;interleave></tt>s to accept those foreign elements. This complicates the grammar, and also bloats the generated code since we need a bigger internal state transition table.
</p><p>
	The other simpler approach is to write a filter and strips away all the irrelevant elements before it even gets to the generated handler.
</p><p>
	Since now the generated handlers don't need to worry about those extras, 
	this makes the schema much simpler.
</p>

<hr>
<div align="right"><a href="index.htm">RelaxNGCC home</a></div>
</body>
</html>